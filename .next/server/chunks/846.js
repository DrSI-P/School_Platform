exports.id = 846;
exports.ids = [846];
exports.modules = {

/***/ 70442:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

//#!/usr/bin/env node

var path = __webpack_require__(71017);
var fs   = __webpack_require__(57147);

var potentialPaths = [
  path.join(process.cwd(), 'node_modules/coffeescript/lib/coffeescript'),
  path.join(process.cwd(), 'node_modules/coffeescript/lib/coffee-script'),
  path.join(process.cwd(), 'node_modules/coffee-script/lib/coffee-script'),
  path.join(__dirname, '../lib/coffee-script')
];

for (var i = 0, len = potentialPaths.length; i < len; i++) {
  if (fs.existsSync(potentialPaths[i])) {
    __webpack_require__(6435)(potentialPaths[i] + "/command").run();
    break;
  }
}


/***/ }),

/***/ 89088:
/***/ (function(__unused_webpack_module, exports) {

(function(global, factory) {
     true ? factory(exports) : 0;
})(this, function(exports1) {
    "use strict";
    // AST walker module for ESTree compatible trees
    // A simple walk is one where you simply specify callbacks to be
    // called on specific nodes. The last two arguments are optional. A
    // simple use would be
    //
    //     walk.simple(myTree, {
    //         Expression: function(node) { ... }
    //     });
    //
    // to do something with all expressions. All ESTree node types
    // can be used to identify node types, as well as Expression and
    // Statement, which denote categories of nodes.
    //
    // The base argument can be used to pass a custom (recursive)
    // walker, and state can be used to give this walked an initial
    // state.
    function simple(node, visitors, baseVisitor, state, override) {
        if (!baseVisitor) {
            baseVisitor = base;
        }
        (function c(node, st, override) {
            var type = override || node.type;
            baseVisitor[type](node, st, c);
            if (visitors[type]) {
                visitors[type](node, st);
            }
        })(node, state, override);
    }
    // An ancestor walk keeps an array of ancestor nodes (including the
    // current node) and passes them to the callback as third parameter
    // (and also as state parameter when no other state is present).
    function ancestor(node, visitors, baseVisitor, state, override) {
        var ancestors = [];
        if (!baseVisitor) {
            baseVisitor = base;
        }
        (function c(node, st, override) {
            var type = override || node.type;
            var isNew = node !== ancestors[ancestors.length - 1];
            if (isNew) {
                ancestors.push(node);
            }
            baseVisitor[type](node, st, c);
            if (visitors[type]) {
                visitors[type](node, st || ancestors, ancestors);
            }
            if (isNew) {
                ancestors.pop();
            }
        })(node, state, override);
    }
    // A recursive walk is one where your functions override the default
    // walkers. They can modify and replace the state parameter that's
    // threaded through the walk, and can opt how and whether to walk
    // their child nodes (by calling their third argument on these
    // nodes).
    function recursive(node, state, funcs, baseVisitor, override) {
        var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;
        (function c(node, st, override) {
            visitor[override || node.type](node, st, c);
        })(node, state, override);
    }
    function makeTest(test) {
        if (typeof test === "string") {
            return function(type) {
                return type === test;
            };
        } else if (!test) {
            return function() {
                return true;
            };
        } else {
            return test;
        }
    }
    var Found = function Found(node, state) {
        this.node = node;
        this.state = state;
    };
    // A full walk triggers the callback on each node
    function full(node, callback, baseVisitor, state, override) {
        if (!baseVisitor) {
            baseVisitor = base;
        }
        var last;
        (function c(node, st, override) {
            var type = override || node.type;
            baseVisitor[type](node, st, c);
            if (last !== node) {
                callback(node, st, type);
                last = node;
            }
        })(node, state, override);
    }
    // An fullAncestor walk is like an ancestor walk, but triggers
    // the callback on each node
    function fullAncestor(node, callback, baseVisitor, state) {
        if (!baseVisitor) {
            baseVisitor = base;
        }
        var ancestors = [], last;
        (function c(node, st, override) {
            var type = override || node.type;
            var isNew = node !== ancestors[ancestors.length - 1];
            if (isNew) {
                ancestors.push(node);
            }
            baseVisitor[type](node, st, c);
            if (last !== node) {
                callback(node, st || ancestors, ancestors, type);
                last = node;
            }
            if (isNew) {
                ancestors.pop();
            }
        })(node, state);
    }
    // Find a node with a given start, end, and type (all are optional,
    // null can be used as wildcard). Returns a {node, state} object, or
    // undefined when it doesn't find a matching node.
    function findNodeAt(node, start, end, test, baseVisitor, state) {
        if (!baseVisitor) {
            baseVisitor = base;
        }
        test = makeTest(test);
        try {
            (function c(node, st, override) {
                var type = override || node.type;
                if ((start == null || node.start <= start) && (end == null || node.end >= end)) {
                    baseVisitor[type](node, st, c);
                }
                if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {
                    throw new Found(node, st);
                }
            })(node, state);
        } catch (e) {
            if (e instanceof Found) {
                return e;
            }
            throw e;
        }
    }
    // Find the innermost node of a given type that contains the given
    // position. Interface similar to findNodeAt.
    function findNodeAround(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
            baseVisitor = base;
        }
        try {
            (function c(node, st, override) {
                var type = override || node.type;
                if (node.start > pos || node.end < pos) {
                    return;
                }
                baseVisitor[type](node, st, c);
                if (test(type, node)) {
                    throw new Found(node, st);
                }
            })(node, state);
        } catch (e) {
            if (e instanceof Found) {
                return e;
            }
            throw e;
        }
    }
    // Find the outermost matching node after a given position.
    function findNodeAfter(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
            baseVisitor = base;
        }
        try {
            (function c(node, st, override) {
                if (node.end < pos) {
                    return;
                }
                var type = override || node.type;
                if (node.start >= pos && test(type, node)) {
                    throw new Found(node, st);
                }
                baseVisitor[type](node, st, c);
            })(node, state);
        } catch (e) {
            if (e instanceof Found) {
                return e;
            }
            throw e;
        }
    }
    // Find the outermost matching node before a given position.
    function findNodeBefore(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
            baseVisitor = base;
        }
        var max;
        (function c(node, st, override) {
            if (node.start > pos) {
                return;
            }
            var type = override || node.type;
            if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {
                max = new Found(node, st);
            }
            baseVisitor[type](node, st, c);
        })(node, state);
        return max;
    }
    // Used to create a custom walker. Will fill in all missing node
    // type properties with the defaults.
    function make(funcs, baseVisitor) {
        var visitor = Object.create(baseVisitor || base);
        for(var type in funcs){
            visitor[type] = funcs[type];
        }
        return visitor;
    }
    function skipThrough(node, st, c) {
        c(node, st);
    }
    function ignore(_node, _st, _c) {}
    // Node walkers.
    var base = {};
    base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
        for(var i = 0, list = node.body; i < list.length; i += 1){
            var stmt = list[i];
            c(stmt, st, "Statement");
        }
    };
    base.Statement = skipThrough;
    base.EmptyStatement = ignore;
    base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
        return c(node.expression, st, "Expression");
    };
    base.IfStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Statement");
        if (node.alternate) {
            c(node.alternate, st, "Statement");
        }
    };
    base.LabeledStatement = function(node, st, c) {
        return c(node.body, st, "Statement");
    };
    base.BreakStatement = base.ContinueStatement = ignore;
    base.WithStatement = function(node, st, c) {
        c(node.object, st, "Expression");
        c(node.body, st, "Statement");
    };
    base.SwitchStatement = function(node, st, c) {
        c(node.discriminant, st, "Expression");
        for(var i = 0, list = node.cases; i < list.length; i += 1){
            var cs = list[i];
            c(cs, st);
        }
    };
    base.SwitchCase = function(node, st, c) {
        if (node.test) {
            c(node.test, st, "Expression");
        }
        for(var i = 0, list = node.consequent; i < list.length; i += 1){
            var cons = list[i];
            c(cons, st, "Statement");
        }
    };
    base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
        if (node.argument) {
            c(node.argument, st, "Expression");
        }
    };
    base.ThrowStatement = base.SpreadElement = function(node, st, c) {
        return c(node.argument, st, "Expression");
    };
    base.TryStatement = function(node, st, c) {
        c(node.block, st, "Statement");
        if (node.handler) {
            c(node.handler, st);
        }
        if (node.finalizer) {
            c(node.finalizer, st, "Statement");
        }
    };
    base.CatchClause = function(node, st, c) {
        if (node.param) {
            c(node.param, st, "Pattern");
        }
        c(node.body, st, "Statement");
    };
    base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.body, st, "Statement");
    };
    base.ForStatement = function(node, st, c) {
        if (node.init) {
            c(node.init, st, "ForInit");
        }
        if (node.test) {
            c(node.test, st, "Expression");
        }
        if (node.update) {
            c(node.update, st, "Expression");
        }
        c(node.body, st, "Statement");
    };
    base.ForInStatement = base.ForOfStatement = function(node, st, c) {
        c(node.left, st, "ForInit");
        c(node.right, st, "Expression");
        c(node.body, st, "Statement");
    };
    base.ForInit = function(node, st, c) {
        if (node.type === "VariableDeclaration") {
            c(node, st);
        } else {
            c(node, st, "Expression");
        }
    };
    base.DebuggerStatement = ignore;
    base.FunctionDeclaration = function(node, st, c) {
        return c(node, st, "Function");
    };
    base.VariableDeclaration = function(node, st, c) {
        for(var i = 0, list = node.declarations; i < list.length; i += 1){
            var decl = list[i];
            c(decl, st);
        }
    };
    base.VariableDeclarator = function(node, st, c) {
        c(node.id, st, "Pattern");
        if (node.init) {
            c(node.init, st, "Expression");
        }
    };
    base.Function = function(node, st, c) {
        if (node.id) {
            c(node.id, st, "Pattern");
        }
        for(var i = 0, list = node.params; i < list.length; i += 1){
            var param = list[i];
            c(param, st, "Pattern");
        }
        c(node.body, st, node.expression ? "Expression" : "Statement");
    };
    base.Pattern = function(node, st, c) {
        if (node.type === "Identifier") {
            c(node, st, "VariablePattern");
        } else if (node.type === "MemberExpression") {
            c(node, st, "MemberPattern");
        } else {
            c(node, st);
        }
    };
    base.VariablePattern = ignore;
    base.MemberPattern = skipThrough;
    base.RestElement = function(node, st, c) {
        return c(node.argument, st, "Pattern");
    };
    base.ArrayPattern = function(node, st, c) {
        for(var i = 0, list = node.elements; i < list.length; i += 1){
            var elt = list[i];
            if (elt) {
                c(elt, st, "Pattern");
            }
        }
    };
    base.ObjectPattern = function(node, st, c) {
        for(var i = 0, list = node.properties; i < list.length; i += 1){
            var prop = list[i];
            if (prop.type === "Property") {
                if (prop.computed) {
                    c(prop.key, st, "Expression");
                }
                c(prop.value, st, "Pattern");
            } else if (prop.type === "RestElement") {
                c(prop.argument, st, "Pattern");
            }
        }
    };
    base.Expression = skipThrough;
    base.ThisExpression = base.Super = base.MetaProperty = ignore;
    base.ArrayExpression = function(node, st, c) {
        for(var i = 0, list = node.elements; i < list.length; i += 1){
            var elt = list[i];
            if (elt) {
                c(elt, st, "Expression");
            }
        }
    };
    base.ObjectExpression = function(node, st, c) {
        for(var i = 0, list = node.properties; i < list.length; i += 1){
            var prop = list[i];
            c(prop, st);
        }
    };
    base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
    base.SequenceExpression = function(node, st, c) {
        for(var i = 0, list = node.expressions; i < list.length; i += 1){
            var expr = list[i];
            c(expr, st, "Expression");
        }
    };
    base.TemplateLiteral = function(node, st, c) {
        for(var i = 0, list = node.quasis; i < list.length; i += 1){
            var quasi = list[i];
            c(quasi, st);
        }
        for(var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1){
            var expr = list$1[i$1];
            c(expr, st, "Expression");
        }
    };
    base.TemplateElement = ignore;
    base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
        c(node.argument, st, "Expression");
    };
    base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
        c(node.left, st, "Expression");
        c(node.right, st, "Expression");
    };
    base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
        c(node.left, st, "Pattern");
        c(node.right, st, "Expression");
    };
    base.ConditionalExpression = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Expression");
        c(node.alternate, st, "Expression");
    };
    base.NewExpression = base.CallExpression = function(node, st, c) {
        c(node.callee, st, "Expression");
        if (node.arguments) {
            for(var i = 0, list = node.arguments; i < list.length; i += 1){
                var arg = list[i];
                c(arg, st, "Expression");
            }
        }
    };
    base.MemberExpression = function(node, st, c) {
        c(node.object, st, "Expression");
        if (node.computed) {
            c(node.property, st, "Expression");
        }
    };
    base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
        if (node.declaration) {
            c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
        }
        if (node.source) {
            c(node.source, st, "Expression");
        }
    };
    base.ExportAllDeclaration = function(node, st, c) {
        if (node.exported) {
            c(node.exported, st);
        }
        c(node.source, st, "Expression");
    };
    base.ImportDeclaration = function(node, st, c) {
        for(var i = 0, list = node.specifiers; i < list.length; i += 1){
            var spec = list[i];
            c(spec, st);
        }
        c(node.source, st, "Expression");
    };
    base.ImportExpression = function(node, st, c) {
        c(node.source, st, "Expression");
    };
    base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
    base.TaggedTemplateExpression = function(node, st, c) {
        c(node.tag, st, "Expression");
        c(node.quasi, st, "Expression");
    };
    base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
        return c(node, st, "Class");
    };
    base.Class = function(node, st, c) {
        if (node.id) {
            c(node.id, st, "Pattern");
        }
        if (node.superClass) {
            c(node.superClass, st, "Expression");
        }
        c(node.body, st);
    };
    base.ClassBody = function(node, st, c) {
        for(var i = 0, list = node.body; i < list.length; i += 1){
            var elt = list[i];
            c(elt, st);
        }
    };
    base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
        if (node.computed) {
            c(node.key, st, "Expression");
        }
        if (node.value) {
            c(node.value, st, "Expression");
        }
    };
    exports1.ancestor = ancestor;
    exports1.base = base;
    exports1.findNodeAfter = findNodeAfter;
    exports1.findNodeAround = findNodeAround;
    exports1.findNodeAt = findNodeAt;
    exports1.findNodeBefore = findNodeBefore;
    exports1.full = full;
    exports1.fullAncestor = fullAncestor;
    exports1.make = make;
    exports1.recursive = recursive;
    exports1.simple = simple;
});


/***/ }),

/***/ 66742:
/***/ (function(__unused_webpack_module, exports) {

(function(global, factory) {
     true ? factory(exports) : 0;
})(this, function(exports1) {
    "use strict";
    // This file was generated. Do not modify manually!
    var astralIdentifierCodes = [
        509,
        0,
        227,
        0,
        150,
        4,
        294,
        9,
        1368,
        2,
        2,
        1,
        6,
        3,
        41,
        2,
        5,
        0,
        166,
        1,
        574,
        3,
        9,
        9,
        7,
        9,
        32,
        4,
        318,
        1,
        80,
        3,
        71,
        10,
        50,
        3,
        123,
        2,
        54,
        14,
        32,
        10,
        3,
        1,
        11,
        3,
        46,
        10,
        8,
        0,
        46,
        9,
        7,
        2,
        37,
        13,
        2,
        9,
        6,
        1,
        45,
        0,
        13,
        2,
        49,
        13,
        9,
        3,
        2,
        11,
        83,
        11,
        7,
        0,
        3,
        0,
        158,
        11,
        6,
        9,
        7,
        3,
        56,
        1,
        2,
        6,
        3,
        1,
        3,
        2,
        10,
        0,
        11,
        1,
        3,
        6,
        4,
        4,
        68,
        8,
        2,
        0,
        3,
        0,
        2,
        3,
        2,
        4,
        2,
        0,
        15,
        1,
        83,
        17,
        10,
        9,
        5,
        0,
        82,
        19,
        13,
        9,
        214,
        6,
        3,
        8,
        28,
        1,
        83,
        16,
        16,
        9,
        82,
        12,
        9,
        9,
        7,
        19,
        58,
        14,
        5,
        9,
        243,
        14,
        166,
        9,
        71,
        5,
        2,
        1,
        3,
        3,
        2,
        0,
        2,
        1,
        13,
        9,
        120,
        6,
        3,
        6,
        4,
        0,
        29,
        9,
        41,
        6,
        2,
        3,
        9,
        0,
        10,
        10,
        47,
        15,
        343,
        9,
        54,
        7,
        2,
        7,
        17,
        9,
        57,
        21,
        2,
        13,
        123,
        5,
        4,
        0,
        2,
        1,
        2,
        6,
        2,
        0,
        9,
        9,
        49,
        4,
        2,
        1,
        2,
        4,
        9,
        9,
        330,
        3,
        10,
        1,
        2,
        0,
        49,
        6,
        4,
        4,
        14,
        10,
        5350,
        0,
        7,
        14,
        11465,
        27,
        2343,
        9,
        87,
        9,
        39,
        4,
        60,
        6,
        26,
        9,
        535,
        9,
        470,
        0,
        2,
        54,
        8,
        3,
        82,
        0,
        12,
        1,
        19628,
        1,
        4178,
        9,
        519,
        45,
        3,
        22,
        543,
        4,
        4,
        5,
        9,
        7,
        3,
        6,
        31,
        3,
        149,
        2,
        1418,
        49,
        513,
        54,
        5,
        49,
        9,
        0,
        15,
        0,
        23,
        4,
        2,
        14,
        1361,
        6,
        2,
        16,
        3,
        6,
        2,
        1,
        2,
        4,
        101,
        0,
        161,
        6,
        10,
        9,
        357,
        0,
        62,
        13,
        499,
        13,
        245,
        1,
        2,
        9,
        726,
        6,
        110,
        6,
        6,
        9,
        4759,
        9,
        787719,
        239
    ];
    // This file was generated. Do not modify manually!
    var astralIdentifierStartCodes = [
        0,
        11,
        2,
        25,
        2,
        18,
        2,
        1,
        2,
        14,
        3,
        13,
        35,
        122,
        70,
        52,
        268,
        28,
        4,
        48,
        48,
        31,
        14,
        29,
        6,
        37,
        11,
        29,
        3,
        35,
        5,
        7,
        2,
        4,
        43,
        157,
        19,
        35,
        5,
        35,
        5,
        39,
        9,
        51,
        13,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        2,
        10,
        2,
        14,
        2,
        6,
        2,
        1,
        4,
        51,
        13,
        310,
        10,
        21,
        11,
        7,
        25,
        5,
        2,
        41,
        2,
        8,
        70,
        5,
        3,
        0,
        2,
        43,
        2,
        1,
        4,
        0,
        3,
        22,
        11,
        22,
        10,
        30,
        66,
        18,
        2,
        1,
        11,
        21,
        11,
        25,
        71,
        55,
        7,
        1,
        65,
        0,
        16,
        3,
        2,
        2,
        2,
        28,
        43,
        28,
        4,
        28,
        36,
        7,
        2,
        27,
        28,
        53,
        11,
        21,
        11,
        18,
        14,
        17,
        111,
        72,
        56,
        50,
        14,
        50,
        14,
        35,
        39,
        27,
        10,
        22,
        251,
        41,
        7,
        1,
        17,
        2,
        60,
        28,
        11,
        0,
        9,
        21,
        43,
        17,
        47,
        20,
        28,
        22,
        13,
        52,
        58,
        1,
        3,
        0,
        14,
        44,
        33,
        24,
        27,
        35,
        30,
        0,
        3,
        0,
        9,
        34,
        4,
        0,
        13,
        47,
        15,
        3,
        22,
        0,
        2,
        0,
        36,
        17,
        2,
        24,
        20,
        1,
        64,
        6,
        2,
        0,
        2,
        3,
        2,
        14,
        2,
        9,
        8,
        46,
        39,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        4,
        0,
        19,
        0,
        13,
        4,
        31,
        9,
        2,
        0,
        3,
        0,
        2,
        37,
        2,
        0,
        26,
        0,
        2,
        0,
        45,
        52,
        19,
        3,
        21,
        2,
        31,
        47,
        21,
        1,
        2,
        0,
        185,
        46,
        42,
        3,
        37,
        47,
        21,
        0,
        60,
        42,
        14,
        0,
        72,
        26,
        38,
        6,
        186,
        43,
        117,
        63,
        32,
        7,
        3,
        0,
        3,
        7,
        2,
        1,
        2,
        23,
        16,
        0,
        2,
        0,
        95,
        7,
        3,
        38,
        17,
        0,
        2,
        0,
        29,
        0,
        11,
        39,
        8,
        0,
        22,
        0,
        12,
        45,
        20,
        0,
        19,
        72,
        200,
        32,
        32,
        8,
        2,
        36,
        18,
        0,
        50,
        29,
        113,
        6,
        2,
        1,
        2,
        37,
        22,
        0,
        26,
        5,
        2,
        1,
        2,
        31,
        15,
        0,
        328,
        18,
        16,
        0,
        2,
        12,
        2,
        33,
        125,
        0,
        80,
        921,
        103,
        110,
        18,
        195,
        2637,
        96,
        16,
        1071,
        18,
        5,
        26,
        3994,
        6,
        582,
        6842,
        29,
        1763,
        568,
        8,
        30,
        18,
        78,
        18,
        29,
        19,
        47,
        17,
        3,
        32,
        20,
        6,
        18,
        433,
        44,
        212,
        63,
        129,
        74,
        6,
        0,
        67,
        12,
        65,
        1,
        2,
        0,
        29,
        6135,
        9,
        1237,
        42,
        9,
        8936,
        3,
        2,
        6,
        2,
        1,
        2,
        290,
        16,
        0,
        30,
        2,
        3,
        0,
        15,
        3,
        9,
        395,
        2309,
        106,
        6,
        12,
        4,
        8,
        8,
        9,
        5991,
        84,
        2,
        70,
        2,
        1,
        3,
        0,
        3,
        1,
        3,
        3,
        2,
        11,
        2,
        0,
        2,
        6,
        2,
        64,
        2,
        3,
        3,
        7,
        2,
        6,
        2,
        27,
        2,
        3,
        2,
        4,
        2,
        0,
        4,
        6,
        2,
        339,
        3,
        24,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        30,
        2,
        24,
        2,
        7,
        1845,
        30,
        7,
        5,
        262,
        61,
        147,
        44,
        11,
        6,
        17,
        0,
        322,
        29,
        19,
        43,
        485,
        27,
        229,
        29,
        3,
        0,
        496,
        6,
        2,
        3,
        2,
        1,
        2,
        14,
        2,
        196,
        60,
        67,
        8,
        0,
        1205,
        3,
        2,
        26,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        9,
        2,
        3,
        2,
        0,
        2,
        0,
        7,
        0,
        5,
        0,
        2,
        0,
        2,
        0,
        2,
        2,
        2,
        1,
        2,
        0,
        3,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        1,
        2,
        0,
        3,
        3,
        2,
        6,
        2,
        3,
        2,
        3,
        2,
        0,
        2,
        9,
        2,
        16,
        6,
        2,
        2,
        4,
        2,
        16,
        4421,
        42719,
        33,
        4153,
        7,
        221,
        3,
        5761,
        15,
        7472,
        16,
        621,
        2467,
        541,
        1507,
        4938,
        6,
        4191
    ];
    // This file was generated. Do not modify manually!
    var nonASCIIidentifierChars = "‌‍\xb7̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
    // This file was generated. Do not modify manually!
    var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
    // These are a run-length and offset encoded representation of the
    // >0xffff code points that are a valid part of identifiers. The
    // offset starts at 0x10000, and each pair of numbers represents an
    // offset to the next range, and then a size of the range.
    // Reserved word lists for various dialects of the language
    var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
    };
    // And the keywords
    var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
    };
    var keywordRelationalOperator = /^in(stanceof)?$/;
    // ## Character categories
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    // This has a complexity linear to the value of the code. The
    // assumption is that looking up astral identifier characters is
    // rare.
    function isInAstralSet(code, set) {
        var pos = 0x10000;
        for(var i = 0; i < set.length; i += 2){
            pos += set[i];
            if (pos > code) {
                return false;
            }
            pos += set[i + 1];
            if (pos >= code) {
                return true;
            }
        }
        return false;
    }
    // Test whether a given character code starts an identifier.
    function isIdentifierStart(code, astral) {
        if (code < 65) {
            return code === 36;
        }
        if (code < 91) {
            return true;
        }
        if (code < 97) {
            return code === 95;
        }
        if (code < 123) {
            return true;
        }
        if (code <= 0xffff) {
            return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
            return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
    }
    // Test whether a given character is part of an identifier.
    function isIdentifierChar(code, astral) {
        if (code < 48) {
            return code === 36;
        }
        if (code < 58) {
            return true;
        }
        if (code < 65) {
            return false;
        }
        if (code < 91) {
            return true;
        }
        if (code < 97) {
            return code === 95;
        }
        if (code < 123) {
            return true;
        }
        if (code <= 0xffff) {
            return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
            return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    // ## Token types
    // The assignment of fine-grained, information-carrying type objects
    // allows the tokenizer to store the information it has about a
    // token in a way that is very cheap for the parser to look up.
    // All token type variables start with an underscore, to make them
    // easy to recognize.
    // The `beforeExpr` property is used to disambiguate between regular
    // expressions and divisions. It is set on all token types that can
    // be followed by an expression (thus, a slash after them would be a
    // regular expression).
    //
    // The `startsExpr` property is used to check if the token ends a
    // `yield` expression. It is set on all token types that either can
    // directly start an expression (like a quotation mark) or can
    // continue an expression (like the body of a string).
    //
    // `isLoop` marks a keyword as starting a loop, which is important
    // to know when parsing a label, in order to allow or disallow
    // continue jumps to that label.
    var TokenType = function TokenType(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
    };
    function binop(name, prec) {
        return new TokenType(name, {
            beforeExpr: true,
            binop: prec
        });
    }
    var beforeExpr = {
        beforeExpr: true
    }, startsExpr = {
        startsExpr: true
    };
    // Map keyword names to token types.
    var keywords = {};
    // Succinct definitions of keyword token types
    function kw(name, options) {
        if (options === void 0) options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
    }
    var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", {
            beforeExpr: true,
            startsExpr: true
        }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", {
            beforeExpr: true,
            startsExpr: true
        }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", {
            beforeExpr: true,
            startsExpr: true
        }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", {
            beforeExpr: true,
            startsExpr: true
        }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", {
            beforeExpr: true,
            isAssign: true
        }),
        assign: new TokenType("_=", {
            beforeExpr: true,
            isAssign: true
        }),
        incDec: new TokenType("++/--", {
            prefix: true,
            postfix: true,
            startsExpr: true
        }),
        prefix: new TokenType("!/~", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", {
            beforeExpr: true,
            binop: 9,
            prefix: true,
            startsExpr: true
        }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", {
            beforeExpr: true
        }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", {
            isLoop: true,
            beforeExpr: true
        }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", {
            isLoop: true
        }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", {
            isLoop: true
        }),
        _with: kw("with"),
        _new: kw("new", {
            beforeExpr: true,
            startsExpr: true
        }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", {
            beforeExpr: true,
            binop: 7
        }),
        _instanceof: kw("instanceof", {
            beforeExpr: true,
            binop: 7
        }),
        _typeof: kw("typeof", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        _void: kw("void", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        }),
        _delete: kw("delete", {
            beforeExpr: true,
            prefix: true,
            startsExpr: true
        })
    };
    // Matches a whole line break (where CRLF is considered a single
    // line break). Used to count lines.
    var lineBreak = /\r\n?|\n|\u2028|\u2029/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code) {
        return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
    }
    function nextLineBreak(code, from, end) {
        if (end === void 0) end = code.length;
        for(var i = from; i < end; i++){
            var next = code.charCodeAt(i);
            if (isNewLine(next)) {
                return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
            }
        }
        return -1;
    }
    var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var ref = Object.prototype;
    var hasOwnProperty = ref.hasOwnProperty;
    var toString = ref.toString;
    var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
    };
    var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
    };
    var regexpCache = Object.create(null);
    function wordsRegexp(words) {
        return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
    }
    function codePointToString(code) {
        // UTF-16 Decoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        code -= 0x10000;
        return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
    }
    var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    // These are used when `options.locations` is on, for the
    // `startLoc` and `endLoc` properties.
    var Position = function Position(line, col) {
        this.line = line;
        this.column = col;
    };
    Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
    };
    var SourceLocation = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
            this.source = p.sourceFile;
        }
    };
    // The `getLineInfo` function is mostly useful when the
    // `locations` option is off (for performance reasons) and you
    // want to find the line/column position for a given character
    // offset. `input` should be the code string that the offset refers
    // into.
    function getLineInfo(input, offset) {
        for(var line = 1, cur = 0;;){
            var nextBreak = nextLineBreak(input, cur, offset);
            if (nextBreak < 0) {
                return new Position(line, offset - cur);
            }
            ++line;
            cur = nextBreak;
        }
    }
    // A second argument must be given to configure the parser process.
    // These options are recognized (only `ecmaVersion` is required):
    var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
    };
    // Interpret and default an options object
    var warnedAboutEcmaVersion = false;
    function getOptions(opts) {
        var options = {};
        for(var opt in defaultOptions){
            options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
            options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
            if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
                warnedAboutEcmaVersion = true;
                console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
            }
            options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
            options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
            options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
            options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function(token) {
                return tokens.push(token);
            };
        }
        if (isArray(options.onComment)) {
            options.onComment = pushComment(options, options.onComment);
        }
        return options;
    }
    function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
            var comment = {
                type: block ? "Block" : "Line",
                value: text,
                start: start,
                end: end
            };
            if (options.locations) {
                comment.loc = new SourceLocation(this, startLoc, endLoc);
            }
            if (options.ranges) {
                comment.range = [
                    start,
                    end
                ];
            }
            array.push(comment);
        };
    }
    // Each scope gets a bitset that may contain these flags
    var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_CLASS_FIELD_INIT = 512, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    // Used in checkLVal* and declareName to determine the type of a binding
    var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5; // Special case for function names as bound inside the function
    var Parser = function Parser(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
            reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
            if (options.sourceType === "module") {
                reserved += " await";
            }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        // Used to signal to callers of `readWord1` whether the word
        // contained any escape sequences. This is needed because words with
        // escape sequences must not be interpreted as keywords.
        this.containsEsc = false;
        // Set up token state
        // The current position of the tokenizer in the input.
        if (startPos) {
            this.pos = startPos;
            this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
            this.pos = this.lineStart = 0;
            this.curLine = 1;
        }
        // Properties of the current token:
        // Its type
        this.type = types$1.eof;
        // For tokens that include more information than their type, the value
        this.value = null;
        // Its start and end offset
        this.start = this.end = this.pos;
        // And, if locations are used, the {line, column} object
        // corresponding to those offsets
        this.startLoc = this.endLoc = this.curPosition();
        // Position information for the previous token
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        // The context stack is used to superficially track syntactic
        // context to predict whether a regular expression is allowed in a
        // given position.
        this.context = this.initialContext();
        this.exprAllowed = true;
        // Figure out if it's a module code.
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        // Used to signify the start of a potential arrow function
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        // Positions to delayed-check that yield/await does not exist in default parameters.
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        // Labels in scope.
        this.labels = [];
        // Thus-far undefined exports.
        this.undefinedExports = Object.create(null);
        // If enabled, skip leading hashbang line.
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
            this.skipLineComment(2);
        }
        // Scope tracking for duplicate variable names (see scope.js)
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        // For RegExp validation
        this.regexpState = null;
        // The stack of private names.
        // Each element has two properties: 'declared' and 'used'.
        // When it exited from the outermost class definition, all used private names must be declared.
        this.privateNameStack = [];
    };
    var prototypeAccessors = {
        inFunction: {
            configurable: true
        },
        inGenerator: {
            configurable: true
        },
        inAsync: {
            configurable: true
        },
        canAwait: {
            configurable: true
        },
        allowSuper: {
            configurable: true
        },
        allowDirectSuper: {
            configurable: true
        },
        treatFunctionsAsVar: {
            configurable: true
        },
        allowNewDotTarget: {
            configurable: true
        },
        inClassStaticBlock: {
            configurable: true
        }
    };
    Parser.prototype.parse = function parse() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
    };
    prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
    };
    prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
    };
    prototypeAccessors.canAwait.get = function() {
        for(var i = this.scopeStack.length - 1; i >= 0; i--){
            var ref = this.scopeStack[i];
            var flags = ref.flags;
            if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
                return false;
            }
            if (flags & SCOPE_FUNCTION) {
                return (flags & SCOPE_ASYNC) > 0;
            }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
        var ref = this.currentThisScope();
        var flags = ref.flags;
        return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
        for(var i = this.scopeStack.length - 1; i >= 0; i--){
            var ref = this.scopeStack[i];
            var flags = ref.flags;
            if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
                return true;
            }
        }
        return false;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while(len--)plugins[len] = arguments[len];
        var cls = this;
        for(var i = 0; i < plugins.length; i++){
            cls = plugins[i](cls);
        }
        return cls;
    };
    Parser.parse = function parse(input, options) {
        return new this(options, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
    };
    Parser.tokenizer = function tokenizer(input, options) {
        return new this(options, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    var pp$9 = Parser.prototype;
    // ## Parser utilities
    var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
            return false;
        }
        for(;;){
            // Try to find string literal.
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            var match = literal.exec(this.input.slice(start));
            if (!match) {
                return false;
            }
            if ((match[1] || match[2]) === "use strict") {
                skipWhiteSpace.lastIndex = start + match[0].length;
                var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
                var next = this.input.charAt(end);
                return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
            }
            start += match[0].length;
            // Skip semicolon, if any.
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            if (this.input[start] === ";") {
                start++;
            }
        }
    };
    // Predicate that tests whether the next token is of the given
    // type, and if yes, consumes it as a side effect.
    pp$9.eat = function(type) {
        if (this.type === type) {
            this.next();
            return true;
        } else {
            return false;
        }
    };
    // Tests whether parsed token is a contextual keyword.
    pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
    };
    // Consumes contextual keyword if possible.
    pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
            return false;
        }
        this.next();
        return true;
    };
    // Asserts that following token is given contextual keyword.
    pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
            this.unexpected();
        }
    };
    // Test whether a semicolon can be inserted at the current position.
    pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
            if (this.options.onInsertedSemicolon) {
                this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
            }
            return true;
        }
    };
    // Consume a semicolon, or, failing that, see if we are allowed to
    // pretend that there is a semicolon at this position.
    pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
            this.unexpected();
        }
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
            if (this.options.onTrailingComma) {
                this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
            }
            if (!notNext) {
                this.next();
            }
            return true;
        }
    };
    // Expect a token of a given type. If found, consume it, otherwise,
    // raise an unexpected token error.
    pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
    };
    // Raise an unexpected token error.
    pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    var DestructuringErrors = function DestructuringErrors() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
            return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
            this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
            this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
            return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
            return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
            this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
            this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
            this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
            this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
    };
    pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
            return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    var pp$8 = Parser.prototype;
    // ### Statement parsing
    // Parse a program. Initializes the parser, reads any number of
    // statements, and wraps them in a Program node.  Optionally takes a
    // `program` argument.  If present, the statements will be appended
    // to its body instead of creating a new node.
    pp$8.parseTopLevel = function(node) {
        var exports1 = Object.create(null);
        if (!node.body) {
            node.body = [];
        }
        while(this.type !== types$1.eof){
            var stmt = this.parseStatement(null, true, exports1);
            node.body.push(stmt);
        }
        if (this.inModule) {
            for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){
                var name = list[i];
                this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
            }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
    };
    var loopLabel = {
        kind: "loop"
    }, switchLabel = {
        kind: "switch"
    };
    pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
            return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        // For ambiguous cases, determine if a LexicalDeclaration (or only a
        // Statement) is allowed here. If context is not empty then only a Statement
        // is allowed. However, `let [` is an explicit negative lookahead for
        // ExpressionStatement, so special-case it first.
        if (nextCh === 91 || nextCh === 92) {
            return true;
        } // '[', '\'
        if (context) {
            return false;
        }
        if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) {
            return true;
        } // '{', astral
        if (isIdentifierStart(nextCh, true)) {
            var pos = next + 1;
            while(isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)){
                ++pos;
            }
            if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) {
                return true;
            }
            var ident = this.input.slice(next, pos);
            if (!keywordRelationalOperator.test(ident)) {
                return true;
            }
        }
        return false;
    };
    // check 'async [no LineTerminator here] function'
    // - 'async /*foo*/ function' is OK.
    // - 'async /*\n*/ function' is invalid.
    pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
            return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));
    };
    // Parse a single statement.
    //
    // If expecting a statement and finding a slash operator, parse a
    // regular expression literal. This is to handle cases like
    // `if (foo) /blah/.exec(foo)`, where looking at the previous token
    // does not help.
    pp$8.parseStatement = function(context, topLevel, exports1) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
            starttype = types$1._var;
            kind = "let";
        }
        // Most types of statements are recognized by the keyword they
        // start with. Many are trivial to parse, some require a bit of
        // complexity.
        switch(starttype){
            case types$1._break:
            case types$1._continue:
                return this.parseBreakContinueStatement(node, starttype.keyword);
            case types$1._debugger:
                return this.parseDebuggerStatement(node);
            case types$1._do:
                return this.parseDoStatement(node);
            case types$1._for:
                return this.parseForStatement(node);
            case types$1._function:
                // Function as sole body of either an if statement or a labeled statement
                // works, but not when it is part of a labeled statement that is the sole
                // body of an if statement.
                if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
                    this.unexpected();
                }
                return this.parseFunctionStatement(node, false, !context);
            case types$1._class:
                if (context) {
                    this.unexpected();
                }
                return this.parseClass(node, true);
            case types$1._if:
                return this.parseIfStatement(node);
            case types$1._return:
                return this.parseReturnStatement(node);
            case types$1._switch:
                return this.parseSwitchStatement(node);
            case types$1._throw:
                return this.parseThrowStatement(node);
            case types$1._try:
                return this.parseTryStatement(node);
            case types$1._const:
            case types$1._var:
                kind = kind || this.value;
                if (context && kind !== "var") {
                    this.unexpected();
                }
                return this.parseVarStatement(node, kind);
            case types$1._while:
                return this.parseWhileStatement(node);
            case types$1._with:
                return this.parseWithStatement(node);
            case types$1.braceL:
                return this.parseBlock(true, node);
            case types$1.semi:
                return this.parseEmptyStatement(node);
            case types$1._export:
            case types$1._import:
                if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
                    skipWhiteSpace.lastIndex = this.pos;
                    var skip = skipWhiteSpace.exec(this.input);
                    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
                    if (nextCh === 40 || nextCh === 46) {
                        return this.parseExpressionStatement(node, this.parseExpression());
                    }
                }
                if (!this.options.allowImportExportEverywhere) {
                    if (!topLevel) {
                        this.raise(this.start, "'import' and 'export' may only appear at the top level");
                    }
                    if (!this.inModule) {
                        this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
                    }
                }
                return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports1);
            // If the statement does not start with a statement keyword or a
            // brace, it's an ExpressionStatement or LabeledStatement. We
            // simply start parsing an expression, and afterwards, if the
            // next token is a colon and the expression was a simple
            // Identifier node, we switch to interpreting it as a label.
            default:
                if (this.isAsyncFunction()) {
                    if (context) {
                        this.unexpected();
                    }
                    this.next();
                    return this.parseFunctionStatement(node, true, !context);
                }
                var maybeName = this.value, expr = this.parseExpression();
                if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
                    return this.parseLabeledStatement(node, maybeName, expr, context);
                } else {
                    return this.parseExpressionStatement(node, expr);
                }
        }
    };
    pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
            node.label = null;
        } else if (this.type !== types$1.name) {
            this.unexpected();
        } else {
            node.label = this.parseIdent();
            this.semicolon();
        }
        // Verify that there is an actual destination to break or
        // continue to.
        var i = 0;
        for(; i < this.labels.length; ++i){
            var lab = this.labels[i];
            if (node.label == null || lab.name === node.label.name) {
                if (lab.kind != null && (isBreak || lab.kind === "loop")) {
                    break;
                }
                if (node.label && isBreak) {
                    break;
                }
            }
        }
        if (i === this.labels.length) {
            this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
            this.eat(types$1.semi);
        } else {
            this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
    };
    // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
    // loop is non-trivial. Basically, we have to parse the init `var`
    // statement or expression, disallowing the `in` operator (see
    // the second parameter to `parseExpression`), and then check
    // whether the next token is `in` or `of`. When there is no init
    // part (semicolon immediately after the opening parenthesis), it
    // is a regular `for` loop.
    pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
            if (awaitAt > -1) {
                this.unexpected(awaitAt);
            }
            return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
                if (this.options.ecmaVersion >= 9) {
                    if (this.type === types$1._in) {
                        if (awaitAt > -1) {
                            this.unexpected(awaitAt);
                        }
                    } else {
                        node.await = awaitAt > -1;
                    }
                }
                return this.parseForIn(node, init$1);
            }
            if (awaitAt > -1) {
                this.unexpected(awaitAt);
            }
            return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var containsEsc = this.containsEsc;
        var refDestructuringErrors = new DestructuringErrors;
        var initPos = this.start;
        var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            if (awaitAt > -1) {
                if (this.type === types$1._in) {
                    this.unexpected(awaitAt);
                }
                node.await = true;
            } else if (isForOf && this.options.ecmaVersion >= 8) {
                if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
                    this.unexpected();
                } else if (this.options.ecmaVersion >= 9) {
                    node.await = false;
                }
            }
            if (startsWithLet && isForOf) {
                this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
            }
            this.toAssignable(init, false, refDestructuringErrors);
            this.checkLValPattern(init);
            return this.parseForIn(node, init);
        } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
            this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
    };
    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        // allow function declarations in branches, but only in non-strict mode
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
            this.raise(this.start, "'return' outside of function");
        }
        this.next();
        // In `return` (and `break`/`continue`), the keywords with
        // optional arguments, we eagerly look for a semicolon or the
        // possibility to insert one.
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
            node.argument = null;
        } else {
            node.argument = this.parseExpression();
            this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        // Statements under must be grouped (by label) in SwitchCase
        // nodes. `cur` is used to keep the node that we are currently
        // adding statements to.
        var cur;
        for(var sawDefault = false; this.type !== types$1.braceR;){
            if (this.type === types$1._case || this.type === types$1._default) {
                var isCase = this.type === types$1._case;
                if (cur) {
                    this.finishNode(cur, "SwitchCase");
                }
                node.cases.push(cur = this.startNode());
                cur.consequent = [];
                this.next();
                if (isCase) {
                    cur.test = this.parseExpression();
                } else {
                    if (sawDefault) {
                        this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
                    }
                    sawDefault = true;
                    cur.test = null;
                }
                this.expect(types$1.colon);
            } else {
                if (!cur) {
                    this.unexpected();
                }
                cur.consequent.push(this.parseStatement(null));
            }
        }
        this.exitScope();
        if (cur) {
            this.finishNode(cur, "SwitchCase");
        }
        this.next(); // Closing brace
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
            this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
    };
    // Reused empty array added for node fields that are always empty.
    var empty$1 = [];
    pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
    };
    pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types$1.parenL)) {
                clause.param = this.parseCatchClauseParam();
            } else {
                if (this.options.ecmaVersion < 10) {
                    this.unexpected();
                }
                clause.param = null;
                this.enterScope(0);
            }
            clause.body = this.parseBlock(false);
            this.exitScope();
            node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
            this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
    };
    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node) {
        if (this.strict) {
            this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){
            var label = list[i$1];
            if (label.name === maybeName) {
                this.raise(expr.start, "Label '" + maybeName + "' is already declared");
            }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for(var i = this.labels.length - 1; i >= 0; i--){
            var label$1 = this.labels[i];
            if (label$1.statementStart === node.start) {
                // Update information about previous labels on this node
                label$1.statementStart = this.start;
                label$1.kind = kind;
            } else {
                break;
            }
        }
        this.labels.push({
            name: maybeName,
            kind: kind,
            statementStart: this.start
        });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
    };
    // Parse a semicolon-enclosed block of statements, handling `"use
    // strict"` declarations when `allowStrict` is true (used for
    // function bodies).
    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node === void 0) node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
            this.enterScope(0);
        }
        while(this.type !== types$1.braceR){
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
        }
        if (exitStrict) {
            this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
            this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
    };
    // Parse a regular `for` loop. The disambiguation code in
    // `parseStatement` will already have parsed the init statement or
    // expression.
    pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
    };
    // Parse a `for`/`in` and `for`/`of` loop, which are almost
    // same from parser's perspective.
    pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
            this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    // Parse a list of variable declarations.
    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for(;;){
            var decl = this.startNode();
            this.parseVarId(decl, kind);
            if (this.eat(types$1.eq)) {
                decl.init = this.parseMaybeAssign(isFor);
            } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
                this.unexpected();
            } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
                this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
            } else {
                decl.init = null;
            }
            node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(types$1.comma)) {
                break;
            }
        }
        return node;
    };
    pp$8.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
    // Parse a function declaration or literal (depending on the
    // `statement & FUNC_STATEMENT`).
    // Remove `allowExpressionBody` for 7.0.0, as it is only called with false
    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
            if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
                this.unexpected();
            }
            node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
            node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
            node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
            if (node.id && !(statement & FUNC_HANGING_STATEMENT)) // If it is a regular function declaration in sloppy mode, then it is
            // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
            // mode depends on properties of the current scope (see
            // treatFunctionsAsVar).
            {
                this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
            }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
            node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
    };
    // Parse a class declaration or literal (depending on the
    // `isStatement` parameter).
    pp$8.parseClass = function(node, isStatement) {
        this.next();
        // ecma-262 14.6 Class Definitions
        // A class definition is always strict mode code.
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while(this.type !== types$1.braceR){
            var element = this.parseClassElement(node.superClass !== null);
            if (element) {
                classBody.body.push(element);
                if (element.type === "MethodDefinition" && element.kind === "constructor") {
                    if (hadConstructor) {
                        this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
                    }
                    hadConstructor = true;
                } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
                    this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
                }
            }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
            return null;
        }
        var ecmaVersion = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
            // Parse static init block
            if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
                this.parseClassStaticBlock(node);
                return node;
            }
            if (this.isClassElementNameStart() || this.type === types$1.star) {
                isStatic = true;
            } else {
                keyName = "static";
            }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
            if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
                isAsync = true;
            } else {
                keyName = "async";
            }
        }
        if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
            isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
            var lastValue = this.value;
            if (this.eatContextual("get") || this.eatContextual("set")) {
                if (this.isClassElementNameStart()) {
                    kind = lastValue;
                } else {
                    keyName = lastValue;
                }
            }
        }
        // Parse element name
        if (keyName) {
            // 'async', 'get', 'set', or 'static' were not a keyword contextually.
            // The last token is any of those. Make it the element name.
            node.computed = false;
            node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
            node.key.name = keyName;
            this.finishNode(node.key, "Identifier");
        } else {
            this.parseClassElementName(node);
        }
        // Parse element value
        if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
            var isConstructor = !node.static && checkKeyName(node, "constructor");
            var allowsDirectSuper = isConstructor && constructorAllowsSuper;
            // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
            if (isConstructor && kind !== "method") {
                this.raise(node.key.start, "Constructor can't have get/set modifier");
            }
            node.kind = isConstructor ? "constructor" : kind;
            this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
            this.parseClassField(node);
        }
        return node;
    };
    pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
            if (this.value === "constructor") {
                this.raise(this.start, "Classes can't have an element named '#constructor'");
            }
            element.computed = false;
            element.key = this.parsePrivateIdent();
        } else {
            this.parsePropertyName(element);
        }
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        // Check key and flags
        var key = method.key;
        if (method.kind === "constructor") {
            if (isGenerator) {
                this.raise(key.start, "Constructor can't be a generator");
            }
            if (isAsync) {
                this.raise(key.start, "Constructor can't be an async method");
            }
        } else if (method.static && checkKeyName(method, "prototype")) {
            this.raise(key.start, "Classes may not have a static property named prototype");
        }
        // Parse value
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        // Check value
        if (method.kind === "get" && value.params.length !== 0) {
            this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
            this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
            this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
            this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
            this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
            // To raise SyntaxError if 'arguments' exists in the initializer.
            this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
            field.value = this.parseMaybeAssign();
            this.exitScope();
        } else {
            field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while(this.type !== types$1.braceR){
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
    };
    pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
            node.id = this.parseIdent();
            if (isStatement) {
                this.checkLValSimple(node.id, BIND_LEXICAL, false);
            }
        } else {
            if (isStatement === true) {
                this.unexpected();
            }
            node.id = null;
        }
    };
    pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
    };
    pp$8.enterClassBody = function() {
        var element = {
            declared: Object.create(null),
            used: []
        };
        this.privateNameStack.push(element);
        return element.declared;
    };
    pp$8.exitClassBody = function() {
        var ref = this.privateNameStack.pop();
        var declared = ref.declared;
        var used = ref.used;
        if (!this.options.checkPrivateFields) {
            return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for(var i = 0; i < used.length; ++i){
            var id = used[i];
            if (!hasOwn(declared, id.name)) {
                if (parent) {
                    parent.used.push(id);
                } else {
                    this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
                }
            }
        }
    };
    function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
            next = (element.static ? "s" : "i") + element.kind;
        }
        // `class { get #a(){}; static set #a(_){} }` is also conflict.
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
            privateNameMap[name] = "true";
            return false;
        } else if (!curr) {
            privateNameMap[name] = next;
            return false;
        } else {
            return true;
        }
    }
    function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
    }
    // Parses module export declaration.
    pp$8.parseExportAllDeclaration = function(node, exports1) {
        if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
                node.exported = this.parseModuleExportName();
                this.checkExport(exports1, node.exported, this.lastTokStart);
            } else {
                node.exported = null;
            }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
            this.unexpected();
        }
        node.source = this.parseExprAtom();
        if (this.options.ecmaVersion >= 16) {
            node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
    };
    pp$8.parseExport = function(node, exports1) {
        this.next();
        // export * from '...'
        if (this.eat(types$1.star)) {
            return this.parseExportAllDeclaration(node, exports1);
        }
        if (this.eat(types$1._default)) {
            this.checkExport(exports1, "default", this.lastTokStart);
            node.declaration = this.parseExportDefaultDeclaration();
            return this.finishNode(node, "ExportDefaultDeclaration");
        }
        // export var|const|let|function|class ...
        if (this.shouldParseExportStatement()) {
            node.declaration = this.parseExportDeclaration(node);
            if (node.declaration.type === "VariableDeclaration") {
                this.checkVariableExport(exports1, node.declaration.declarations);
            } else {
                this.checkExport(exports1, node.declaration.id, node.declaration.id.start);
            }
            node.specifiers = [];
            node.source = null;
            if (this.options.ecmaVersion >= 16) {
                node.attributes = [];
            }
        } else {
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports1);
            if (this.eatContextual("from")) {
                if (this.type !== types$1.string) {
                    this.unexpected();
                }
                node.source = this.parseExprAtom();
                if (this.options.ecmaVersion >= 16) {
                    node.attributes = this.parseWithClause();
                }
            } else {
                for(var i = 0, list = node.specifiers; i < list.length; i += 1){
                    // check for keywords used as local names
                    var spec = list[i];
                    this.checkUnreserved(spec.local);
                    // check if export is defined
                    this.checkLocalExport(spec.local);
                    if (spec.local.type === "Literal") {
                        this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
                    }
                }
                node.source = null;
                if (this.options.ecmaVersion >= 16) {
                    node.attributes = [];
                }
            }
            this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
    };
    pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
                this.next();
            }
            return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
            var cNode = this.startNode();
            return this.parseClass(cNode, "nullableID");
        } else {
            var declaration = this.parseMaybeAssign();
            this.semicolon();
            return declaration;
        }
    };
    pp$8.checkExport = function(exports1, name, pos) {
        if (!exports1) {
            return;
        }
        if (typeof name !== "string") {
            name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports1, name)) {
            this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports1[name] = true;
    };
    pp$8.checkPatternExport = function(exports1, pat) {
        var type = pat.type;
        if (type === "Identifier") {
            this.checkExport(exports1, pat, pat.start);
        } else if (type === "ObjectPattern") {
            for(var i = 0, list = pat.properties; i < list.length; i += 1){
                var prop = list[i];
                this.checkPatternExport(exports1, prop);
            }
        } else if (type === "ArrayPattern") {
            for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){
                var elt = list$1[i$1];
                if (elt) {
                    this.checkPatternExport(exports1, elt);
                }
            }
        } else if (type === "Property") {
            this.checkPatternExport(exports1, pat.value);
        } else if (type === "AssignmentPattern") {
            this.checkPatternExport(exports1, pat.left);
        } else if (type === "RestElement") {
            this.checkPatternExport(exports1, pat.argument);
        }
    };
    pp$8.checkVariableExport = function(exports1, decls) {
        if (!exports1) {
            return;
        }
        for(var i = 0, list = decls; i < list.length; i += 1){
            var decl = list[i];
            this.checkPatternExport(exports1, decl.id);
        }
    };
    pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    // Parses a comma-separated list of module exports.
    pp$8.parseExportSpecifier = function(exports1) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(exports1, node.exported, node.exported.start);
        return this.finishNode(node, "ExportSpecifier");
    };
    pp$8.parseExportSpecifiers = function(exports1) {
        var nodes = [], first = true;
        // export { x, y as z } [from '...']
        this.expect(types$1.braceL);
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.afterTrailingComma(types$1.braceR)) {
                    break;
                }
            } else {
                first = false;
            }
            nodes.push(this.parseExportSpecifier(exports1));
        }
        return nodes;
    };
    // Parses import declaration.
    pp$8.parseImport = function(node) {
        this.next();
        // import '...'
        if (this.type === types$1.string) {
            node.specifiers = empty$1;
            node.source = this.parseExprAtom();
        } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        if (this.options.ecmaVersion >= 16) {
            node.attributes = this.parseWithClause();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
    };
    // Parses a comma-separated list of module imports.
    pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
            node.local = this.parseIdent();
        } else {
            this.checkUnreserved(node.imported);
            node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
    };
    pp$8.parseImportDefaultSpecifier = function() {
        // import defaultObj, { x, y as z } from '...'
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
    };
    pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
    };
    pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
            nodes.push(this.parseImportDefaultSpecifier());
            if (!this.eat(types$1.comma)) {
                return nodes;
            }
        }
        if (this.type === types$1.star) {
            nodes.push(this.parseImportNamespaceSpecifier());
            return nodes;
        }
        this.expect(types$1.braceL);
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.afterTrailingComma(types$1.braceR)) {
                    break;
                }
            } else {
                first = false;
            }
            nodes.push(this.parseImportSpecifier());
        }
        return nodes;
    };
    pp$8.parseWithClause = function() {
        var nodes = [];
        if (!this.eat(types$1._with)) {
            return nodes;
        }
        this.expect(types$1.braceL);
        var attributeKeys = {};
        var first = true;
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.afterTrailingComma(types$1.braceR)) {
                    break;
                }
            } else {
                first = false;
            }
            var attr = this.parseImportAttribute();
            var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
            if (hasOwn(attributeKeys, keyName)) {
                this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
            }
            attributeKeys[keyName] = true;
            nodes.push(attr);
        }
        return nodes;
    };
    pp$8.parseImportAttribute = function() {
        var node = this.startNode();
        node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        this.expect(types$1.colon);
        if (this.type !== types$1.string) {
            this.unexpected();
        }
        node.value = this.parseExprAtom();
        return this.finishNode(node, "ImportAttribute");
    };
    pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
            var stringLiteral = this.parseLiteral(this.value);
            if (loneSurrogate.test(stringLiteral.value)) {
                this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
            }
            return stringLiteral;
        }
        return this.parseIdent(true);
    };
    // Set `ExpressionStatement#directive` property for directive prologues.
    pp$8.adaptDirectivePrologue = function(statements) {
        for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i){
            statements[i].directive = statements[i].expression.raw.slice(1, -1);
        }
    };
    pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    var pp$7 = Parser.prototype;
    // Convert existing expression atom to assignable pattern
    // if possible.
    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
            switch(node.type){
                case "Identifier":
                    if (this.inAsync && node.name === "await") {
                        this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
                    }
                    break;
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                    break;
                case "ObjectExpression":
                    node.type = "ObjectPattern";
                    if (refDestructuringErrors) {
                        this.checkPatternErrors(refDestructuringErrors, true);
                    }
                    for(var i = 0, list = node.properties; i < list.length; i += 1){
                        var prop = list[i];
                        this.toAssignable(prop, isBinding);
                        // Early error:
                        //   AssignmentRestProperty[Yield, Await] :
                        //     `...` DestructuringAssignmentTarget[Yield, Await]
                        //
                        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
                        if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                            this.raise(prop.argument.start, "Unexpected token");
                        }
                    }
                    break;
                case "Property":
                    // AssignmentProperty has type === "Property"
                    if (node.kind !== "init") {
                        this.raise(node.key.start, "Object pattern can't contain getter or setter");
                    }
                    this.toAssignable(node.value, isBinding);
                    break;
                case "ArrayExpression":
                    node.type = "ArrayPattern";
                    if (refDestructuringErrors) {
                        this.checkPatternErrors(refDestructuringErrors, true);
                    }
                    this.toAssignableList(node.elements, isBinding);
                    break;
                case "SpreadElement":
                    node.type = "RestElement";
                    this.toAssignable(node.argument, isBinding);
                    if (node.argument.type === "AssignmentPattern") {
                        this.raise(node.argument.start, "Rest elements cannot have a default value");
                    }
                    break;
                case "AssignmentExpression":
                    if (node.operator !== "=") {
                        this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
                    }
                    node.type = "AssignmentPattern";
                    delete node.operator;
                    this.toAssignable(node.left, isBinding);
                    break;
                case "ParenthesizedExpression":
                    this.toAssignable(node.expression, isBinding, refDestructuringErrors);
                    break;
                case "ChainExpression":
                    this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
                    break;
                case "MemberExpression":
                    if (!isBinding) {
                        break;
                    }
                default:
                    this.raise(node.start, "Assigning to rvalue");
            }
        } else if (refDestructuringErrors) {
            this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
    };
    // Convert list of expression atoms to binding list.
    pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for(var i = 0; i < end; i++){
            var elt = exprList[i];
            if (elt) {
                this.toAssignable(elt, isBinding);
            }
        }
        if (end) {
            var last = exprList[end - 1];
            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
                this.unexpected(last.argument.start);
            }
        }
        return exprList;
    };
    // Parses spread element.
    pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        // RestElement inside of a function parameter must be an identifier
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
            this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
    };
    // Parses lvalue (assignable) atom.
    pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
            switch(this.type){
                case types$1.bracketL:
                    var node = this.startNode();
                    this.next();
                    node.elements = this.parseBindingList(types$1.bracketR, true, true);
                    return this.finishNode(node, "ArrayPattern");
                case types$1.braceL:
                    return this.parseObj(true);
            }
        }
        return this.parseIdent();
    };
    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while(!this.eat(close)){
            if (first) {
                first = false;
            } else {
                this.expect(types$1.comma);
            }
            if (allowEmpty && this.type === types$1.comma) {
                elts.push(null);
            } else if (allowTrailingComma && this.afterTrailingComma(close)) {
                break;
            } else if (this.type === types$1.ellipsis) {
                var rest = this.parseRestBinding();
                this.parseBindingListItem(rest);
                elts.push(rest);
                if (this.type === types$1.comma) {
                    this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                }
                this.expect(close);
                break;
            } else {
                elts.push(this.parseAssignableListItem(allowModifiers));
            }
        }
        return elts;
    };
    pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
    };
    pp$7.parseBindingListItem = function(param) {
        return param;
    };
    // Parses assignment pattern around given atom if possible.
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
            return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
    };
    // The following three functions all verify that a node is an lvalue —
    // something that can be bound, or assigned to. In order to do so, they perform
    // a variety of checks:
    //
    // - Check that none of the bound/assigned-to identifiers are reserved words.
    // - Record name declarations for bindings in the appropriate scope.
    // - Check duplicate argument names, if checkClashes is set.
    //
    // If a complex binding pattern is encountered (e.g., object and array
    // destructuring), the entire pattern is recursively checked.
    //
    // There are three versions of checkLVal*() appropriate for different
    // circumstances:
    //
    // - checkLValSimple() shall be used if the syntactic construct supports
    //   nothing other than identifiers and member expressions. Parenthesized
    //   expressions are also correctly handled. This is generally appropriate for
    //   constructs for which the spec says
    //
    //   > It is a Syntax Error if AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   It is also appropriate for checking if an identifier is valid and not
    //   defined elsewhere, like import declarations or function/class identifiers.
    //
    //   Examples where this is used include:
    //     a += …;
    //     import a from '…';
    //   where a is the node to be checked.
    //
    // - checkLValPattern() shall be used if the syntactic construct supports
    //   anything checkLValSimple() supports, as well as object and array
    //   destructuring patterns. This is generally appropriate for constructs for
    //   which the spec says
    //
    //   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
    //   > an ArrayLiteral and AssignmentTargetType of [the production] is not
    //   > simple.
    //
    //   Examples where this is used include:
    //     (a = …);
    //     const a = …;
    //     try { … } catch (a) { … }
    //   where a is the node to be checked.
    //
    // - checkLValInnerPattern() shall be used if the syntactic construct supports
    //   anything checkLValPattern() supports, as well as default assignment
    //   patterns, rest elements, and other constructs that may appear within an
    //   object or array destructuring pattern.
    //
    //   As a special case, function parameters also use checkLValInnerPattern(),
    //   as they also support defaults and rest constructs.
    //
    // These functions deliberately support both assignment and binding constructs,
    // as the logic for both is exceedingly similar. If the node is the target of
    // an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
    // should be set to the appropriate BIND_* constant, like BIND_VAR or
    // BIND_LEXICAL.
    //
    // If the function is called with a non-BIND_NONE bindingType, then
    // additionally a checkClashes object may be specified to allow checking for
    // duplicate argument names. checkClashes is ignored if the provided construct
    // is an assignment (i.e., bindingType is BIND_NONE).
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch(expr.type){
            case "Identifier":
                if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
                    this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
                }
                if (isBind) {
                    if (bindingType === BIND_LEXICAL && expr.name === "let") {
                        this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
                    }
                    if (checkClashes) {
                        if (hasOwn(checkClashes, expr.name)) {
                            this.raiseRecoverable(expr.start, "Argument name clash");
                        }
                        checkClashes[expr.name] = true;
                    }
                    if (bindingType !== BIND_OUTSIDE) {
                        this.declareName(expr.name, bindingType, expr.start);
                    }
                }
                break;
            case "ChainExpression":
                this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
                break;
            case "MemberExpression":
                if (isBind) {
                    this.raiseRecoverable(expr.start, "Binding member expression");
                }
                break;
            case "ParenthesizedExpression":
                if (isBind) {
                    this.raiseRecoverable(expr.start, "Binding parenthesized expression");
                }
                return this.checkLValSimple(expr.expression, bindingType, checkClashes);
            default:
                this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch(expr.type){
            case "ObjectPattern":
                for(var i = 0, list = expr.properties; i < list.length; i += 1){
                    var prop = list[i];
                    this.checkLValInnerPattern(prop, bindingType, checkClashes);
                }
                break;
            case "ArrayPattern":
                for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){
                    var elem = list$1[i$1];
                    if (elem) {
                        this.checkLValInnerPattern(elem, bindingType, checkClashes);
                    }
                }
                break;
            default:
                this.checkLValSimple(expr, bindingType, checkClashes);
        }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE;
        switch(expr.type){
            case "Property":
                // AssignmentProperty has type === "Property"
                this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
                break;
            case "AssignmentPattern":
                this.checkLValPattern(expr.left, bindingType, checkClashes);
                break;
            case "RestElement":
                this.checkLValPattern(expr.argument, bindingType, checkClashes);
                break;
            default:
                this.checkLValPattern(expr, bindingType, checkClashes);
        }
    };
    // The algorithm used to determine whether a regexp can appear at a
    // given point in the program is loosely based on sweet.js' approach.
    // See https://github.com/mozilla/sweet.js/wiki/design
    var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
    };
    var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
            return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
    };
    var pp$6 = Parser.prototype;
    pp$6.initialContext = function() {
        return [
            types.b_stat
        ];
    };
    pp$6.curContext = function() {
        return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
            return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
            return !parent.isExpr;
        }
        // The check for `tt.name && exprAllowed` detects whether we are
        // after a `yield` or `of` construct. See the `updateContext` for
        // `tt.name`.
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
            return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
            return true;
        }
        if (prevType === types$1.braceL) {
            return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
            return false;
        }
        return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
        for(var i = this.context.length - 1; i >= 1; i--){
            var context = this.context[i];
            if (context.token === "function") {
                return context.generator;
            }
        }
        return false;
    };
    pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
            this.exprAllowed = false;
        } else if (update = type.updateContext) {
            update.call(this, prevType);
        } else {
            this.exprAllowed = type.beforeExpr;
        }
    };
    // Used to handle edge cases when token context could not be inferred correctly during tokenization phase
    pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
            this.context[this.context.length - 1] = tokenCtx;
        }
    };
    // Token-specific context update code
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
            this.exprAllowed = true;
            return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
            out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    // tokExprAllowed stays unchanged
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
            this.context.push(types.f_expr);
        } else {
            this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
    };
    types$1.colon.updateContext = function() {
        if (this.curContext().token === "function") {
            this.context.pop();
        }
        this.exprAllowed = true;
    };
    types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
            this.context.pop();
        } else {
            this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
            var index = this.context.length - 1;
            if (this.context[index] === types.f_expr) {
                this.context[index] = types.f_expr_gen;
            } else {
                this.context[index] = types.f_gen;
            }
        }
        this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
            if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
                allowed = true;
            }
        }
        this.exprAllowed = allowed;
    };
    // A recursive descent parser operates by defining functions for all
    // syntactic elements, and recursively calling those, each function
    // advancing the input stream and returning an AST node. Precedence
    // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
    // instead of `(!x)[1]` is handled by the fact that the parser
    // function that parses unary prefix operators is called first, and
    // in turn calls the function that parses `[]` subscripts — that
    // way, it'll receive the node for `x[1]` already parsed, and wraps
    // *that* in the unary operator node.
    //
    // Acorn uses an [operator precedence parser][opp] to handle binary
    // operator precedence, because it is much more compact than using
    // the technique outlined above, which uses different, nesting
    // functions to specify precedence, for all of the ten binary
    // precedence levels that JavaScript defines.
    //
    // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
    var pp$5 = Parser.prototype;
    // Check if property name clashes with already added.
    // Object/class getters and setters are not allowed to clash —
    // either with each other or with an init property — and in
    // strict mode, init properties are also not allowed to be repeated.
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
            return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
            return;
        }
        var key = prop.key;
        var name;
        switch(key.type){
            case "Identifier":
                name = key.name;
                break;
            case "Literal":
                name = String(key.value);
                break;
            default:
                return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
            if (name === "__proto__" && kind === "init") {
                if (propHash.proto) {
                    if (refDestructuringErrors) {
                        if (refDestructuringErrors.doubleProto < 0) {
                            refDestructuringErrors.doubleProto = key.start;
                        }
                    } else {
                        this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
                    }
                }
                propHash.proto = true;
            }
            return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
            var redefinition;
            if (kind === "init") {
                redefinition = this.strict && other.init || other.get || other.set;
            } else {
                redefinition = other.init || other[kind];
            }
            if (redefinition) {
                this.raiseRecoverable(key.start, "Redefinition of property");
            }
        } else {
            other = propHash[name] = {
                init: false,
                get: false,
                set: false
            };
        }
        other[kind] = true;
    };
    // ### Expression parsing
    // These nest, from the most general expression type at the top to
    // 'atomic', nondivisible expression types at the bottom. Most of
    // the functions will simply let the function(s) below them parse,
    // and, *if* the syntactic construct they handle is present, wrap
    // the AST node that the inner parser gave them in another node.
    // Parse a full expression. The optional arguments are used to
    // forbid the `in` operator (in for loops initalization expressions)
    // and provide reference for storing '=' operator inside shorthand
    // property assignment in contexts where both object expression
    // and object pattern might appear (so it's possible to raise
    // delayed syntax error at correct position).
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            node.expressions = [
                expr
            ];
            while(this.eat(types$1.comma)){
                node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
            }
            return this.finishNode(node, "SequenceExpression");
        }
        return expr;
    };
    // Parse an assignment expression. This includes applications of
    // operators like `+=`.
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
            if (this.inGenerator) {
                return this.parseYield(forInit);
            } else {
                this.exprAllowed = false;
            }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
            oldParenAssign = refDestructuringErrors.parenthesizedAssign;
            oldTrailingComma = refDestructuringErrors.trailingComma;
            oldDoubleProto = refDestructuringErrors.doubleProto;
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
            refDestructuringErrors = new DestructuringErrors;
            ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
            this.potentialArrowAt = this.start;
            this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
            left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
            var node = this.startNodeAt(startPos, startLoc);
            node.operator = this.value;
            if (this.type === types$1.eq) {
                left = this.toAssignable(left, false, refDestructuringErrors);
            }
            if (!ownDestructuringErrors) {
                refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
            }
            if (refDestructuringErrors.shorthandAssign >= left.start) {
                refDestructuringErrors.shorthandAssign = -1;
            } // reset because shorthand default was used correctly
            if (this.type === types$1.eq) {
                this.checkLValPattern(left);
            } else {
                this.checkLValSimple(left);
            }
            node.left = left;
            this.next();
            node.right = this.parseMaybeAssign(forInit);
            if (oldDoubleProto > -1) {
                refDestructuringErrors.doubleProto = oldDoubleProto;
            }
            return this.finishNode(node, "AssignmentExpression");
        } else {
            if (ownDestructuringErrors) {
                this.checkExpressionErrors(refDestructuringErrors, true);
            }
        }
        if (oldParenAssign > -1) {
            refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
            refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
    };
    // Parse a ternary conditional (`?:`) operator.
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
        }
        if (this.eat(types$1.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(types$1.colon);
            node.alternate = this.parseMaybeAssign(forInit);
            return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
    };
    // Start the precedence parser.
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    // Parse binary operators with the operator precedence parsing
    // algorithm. `left` is the left-hand side of the operator.
    // `minPrec` provides context that allows the function to stop and
    // defer further parser to one of its callers when it encounters an
    // operator that has a lower precedence than the set it is parsing.
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
            if (prec > minPrec) {
                var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
                var coalesce = this.type === types$1.coalesce;
                if (coalesce) {
                    // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
                    // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
                    prec = types$1.logicalAND.binop;
                }
                var op = this.value;
                this.next();
                var startPos = this.start, startLoc = this.startLoc;
                var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
                var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
                if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
                    this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
                }
                return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
            }
        }
        return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
            this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
    };
    // Parse unary operators, both prefix and postfix.
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
            expr = this.parseAwait(forInit);
            sawUnary = true;
        } else if (this.type.prefix) {
            var node = this.startNode(), update = this.type === types$1.incDec;
            node.operator = this.value;
            node.prefix = true;
            this.next();
            node.argument = this.parseMaybeUnary(null, true, update, forInit);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) {
                this.checkLValSimple(node.argument);
            } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
                this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
            } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
                this.raiseRecoverable(node.start, "Private fields can not be deleted");
            } else {
                sawUnary = true;
            }
            expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
            if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
                this.unexpected();
            }
            expr = this.parsePrivateIdent();
            // only could be private fields in 'in', such as #x in obj
            if (this.type !== types$1._in) {
                this.unexpected();
            }
        } else {
            expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
            if (this.checkExpressionErrors(refDestructuringErrors)) {
                return expr;
            }
            while(this.type.postfix && !this.canInsertSemicolon()){
                var node$1 = this.startNodeAt(startPos, startLoc);
                node$1.operator = this.value;
                node$1.prefix = false;
                node$1.argument = expr;
                this.checkLValSimple(expr);
                this.next();
                expr = this.finishNode(node$1, "UpdateExpression");
            }
        }
        if (!incDec && this.eat(types$1.starstar)) {
            if (sawUnary) {
                this.unexpected(this.lastTokStart);
            } else {
                return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
            }
        } else {
            return expr;
        }
    };
    function isLocalVariableAccess(node) {
        return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
    }
    function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
    }
    // Parse call, dot, and `[]`-subscript expressions.
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
            return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
            if (refDestructuringErrors.parenthesizedAssign >= result.start) {
                refDestructuringErrors.parenthesizedAssign = -1;
            }
            if (refDestructuringErrors.parenthesizedBind >= result.start) {
                refDestructuringErrors.parenthesizedBind = -1;
            }
            if (refDestructuringErrors.trailingComma >= result.start) {
                refDestructuringErrors.trailingComma = -1;
            }
        }
        return result;
    };
    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while(true){
            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
            if (element.optional) {
                optionalChained = true;
            }
            if (element === base || element.type === "ArrowFunctionExpression") {
                if (optionalChained) {
                    var chainNode = this.startNodeAt(startPos, startLoc);
                    chainNode.expression = element;
                    element = this.finishNode(chainNode, "ChainExpression");
                }
                return element;
            }
            base = element;
        }
    };
    pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
    };
    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    };
    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
            this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            if (computed) {
                node.property = this.parseExpression();
                this.expect(types$1.bracketR);
            } else if (this.type === types$1.privateId && base.type !== "Super") {
                node.property = this.parsePrivateIdent();
            } else {
                node.property = this.parseIdent(this.options.allowReserved !== "never");
            }
            node.computed = !!computed;
            if (optionalSupported) {
                node.optional = optional;
            }
            base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
            this.yieldPos = 0;
            this.awaitPos = 0;
            this.awaitIdentPos = 0;
            var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
                this.checkPatternErrors(refDestructuringErrors, false);
                this.checkYieldAwaitInDefaultParams();
                if (this.awaitIdentPos > 0) {
                    this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
                }
                this.yieldPos = oldYieldPos;
                this.awaitPos = oldAwaitPos;
                this.awaitIdentPos = oldAwaitIdentPos;
                return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base;
            node$1.arguments = exprList;
            if (optionalSupported) {
                node$1.optional = optional;
            }
            base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
            if (optional || optionalChained) {
                this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            }
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base;
            node$2.quasi = this.parseTemplate({
                isTagged: true
            });
            base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
    };
    // Parse an atomic expression — either a single token that is an
    // expression, an expression started by a keyword like `function` or
    // `new`, or an expression wrapped in punctuation like `()`, `[]`,
    // or `{}`.
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        // If a division operator appears in an expression position, the
        // tokenizer got confused, and we force it to read a regexp instead.
        if (this.type === types$1.slash) {
            this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch(this.type){
            case types$1._super:
                if (!this.allowSuper) {
                    this.raise(this.start, "'super' keyword outside a method");
                }
                node = this.startNode();
                this.next();
                if (this.type === types$1.parenL && !this.allowDirectSuper) {
                    this.raise(node.start, "super() call outside constructor of a subclass");
                }
                // The `super` keyword can appear at below:
                // SuperProperty:
                //     super [ Expression ]
                //     super . IdentifierName
                // SuperCall:
                //     super ( Arguments )
                if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
                    this.unexpected();
                }
                return this.finishNode(node, "Super");
            case types$1._this:
                node = this.startNode();
                this.next();
                return this.finishNode(node, "ThisExpression");
            case types$1.name:
                var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
                var id = this.parseIdent(false);
                if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
                    this.overrideContext(types.f_expr);
                    return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
                }
                if (canBeArrow && !this.canInsertSemicolon()) {
                    if (this.eat(types$1.arrow)) {
                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                            id
                        ], false, forInit);
                    }
                    if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                        id = this.parseIdent(false);
                        if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                            this.unexpected();
                        }
                        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
                            id
                        ], true, forInit);
                    }
                }
                return id;
            case types$1.regexp:
                var value = this.value;
                node = this.parseLiteral(value.value);
                node.regex = {
                    pattern: value.pattern,
                    flags: value.flags
                };
                return node;
            case types$1.num:
            case types$1.string:
                return this.parseLiteral(this.value);
            case types$1._null:
            case types$1._true:
            case types$1._false:
                node = this.startNode();
                node.value = this.type === types$1._null ? null : this.type === types$1._true;
                node.raw = this.type.keyword;
                this.next();
                return this.finishNode(node, "Literal");
            case types$1.parenL:
                var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
                if (refDestructuringErrors) {
                    if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                        refDestructuringErrors.parenthesizedAssign = start;
                    }
                    if (refDestructuringErrors.parenthesizedBind < 0) {
                        refDestructuringErrors.parenthesizedBind = start;
                    }
                }
                return expr;
            case types$1.bracketL:
                node = this.startNode();
                this.next();
                node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
                return this.finishNode(node, "ArrayExpression");
            case types$1.braceL:
                this.overrideContext(types.b_expr);
                return this.parseObj(false, refDestructuringErrors);
            case types$1._function:
                node = this.startNode();
                this.next();
                return this.parseFunction(node, 0);
            case types$1._class:
                return this.parseClass(this.startNode(), false);
            case types$1._new:
                return this.parseNew();
            case types$1.backQuote:
                return this.parseTemplate();
            case types$1._import:
                if (this.options.ecmaVersion >= 11) {
                    return this.parseExprImport(forNew);
                } else {
                    return this.unexpected();
                }
            default:
                return this.parseExprAtomDefault();
        }
    };
    pp$5.parseExprAtomDefault = function() {
        this.unexpected();
    };
    pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        // Consume `import` as an identifier for `import.meta`.
        // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
        if (this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        this.next();
        if (this.type === types$1.parenL && !forNew) {
            return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
            var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
            meta.name = "import";
            node.meta = this.finishNode(meta, "Identifier");
            return this.parseImportMeta(node);
        } else {
            this.unexpected();
        }
    };
    pp$5.parseDynamicImport = function(node) {
        this.next(); // skip `(`
        // Parse node.source.
        node.source = this.parseMaybeAssign();
        if (this.options.ecmaVersion >= 16) {
            if (!this.eat(types$1.parenR)) {
                this.expect(types$1.comma);
                if (!this.afterTrailingComma(types$1.parenR)) {
                    node.options = this.parseMaybeAssign();
                    if (!this.eat(types$1.parenR)) {
                        this.expect(types$1.comma);
                        if (!this.afterTrailingComma(types$1.parenR)) {
                            this.unexpected();
                        }
                    }
                } else {
                    node.options = null;
                }
            } else {
                node.options = null;
            }
        } else {
            // Verify ending.
            if (!this.eat(types$1.parenR)) {
                var errorPos = this.start;
                if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
                    this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
                } else {
                    this.unexpected(errorPos);
                }
            }
        }
        return this.finishNode(node, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node) {
        this.next(); // skip `.`
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
            this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
            this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
    };
    pp$5.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
            node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
    };
    pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
    };
    pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
            this.next();
            var innerStartPos = this.start, innerStartLoc = this.startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
            this.yieldPos = 0;
            this.awaitPos = 0;
            // Do not save awaitIdentPos to allow checking awaits nested in parameters
            while(this.type !== types$1.parenR){
                first ? first = false : this.expect(types$1.comma);
                if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
                    lastIsComma = true;
                    break;
                } else if (this.type === types$1.ellipsis) {
                    spreadStart = this.start;
                    exprList.push(this.parseParenItem(this.parseRestBinding()));
                    if (this.type === types$1.comma) {
                        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                    }
                    break;
                } else {
                    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
                }
            }
            var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
            this.expect(types$1.parenR);
            if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
                this.checkPatternErrors(refDestructuringErrors, false);
                this.checkYieldAwaitInDefaultParams();
                this.yieldPos = oldYieldPos;
                this.awaitPos = oldAwaitPos;
                return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
            }
            if (!exprList.length || lastIsComma) {
                this.unexpected(this.lastTokStart);
            }
            if (spreadStart) {
                this.unexpected(spreadStart);
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            if (exprList.length > 1) {
                val = this.startNodeAt(innerStartPos, innerStartLoc);
                val.expressions = exprList;
                this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
                val = exprList[0];
            }
        } else {
            val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression");
        } else {
            return val;
        }
    };
    pp$5.parseParenItem = function(item) {
        return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    // New's precedence is slightly tricky. It must allow its argument to
    // be a `[]` or dot subscript expression, but not a call — at least,
    // not without wrapping it in parentheses. Thus, it uses the noCalls
    // argument to parseSubscripts to prevent it from consuming the
    // argument list.
    var empty = [];
    pp$5.parseNew = function() {
        if (this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
            var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
            meta.name = "new";
            node.meta = this.finishNode(meta, "Identifier");
            this.next();
            var containsEsc = this.containsEsc;
            node.property = this.parseIdent(true);
            if (node.property.name !== "target") {
                this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
            }
            if (containsEsc) {
                this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
            }
            if (!this.allowNewDotTarget) {
                this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
            }
            return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
            node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
            node.arguments = empty;
        }
        return this.finishNode(node, "NewExpression");
    };
    // Parse template expression.
    pp$5.parseTemplateElement = function(ref) {
        var isTagged = ref.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
            if (!isTagged) {
                this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
            }
            elem.value = {
                raw: this.value.replace(/\r\n?/g, "\n"),
                cooked: null
            };
        } else {
            elem.value = {
                raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
                cooked: this.value
            };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref) {
        if (ref === void 0) ref = {};
        var isTagged = ref.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({
            isTagged: isTagged
        });
        node.quasis = [
            curElt
        ];
        while(!curElt.tail){
            if (this.type === types$1.eof) {
                this.raise(this.pos, "Unterminated template literal");
            }
            this.expect(types$1.dollarBraceL);
            node.expressions.push(this.parseExpression());
            this.expect(types$1.braceR);
            node.quasis.push(curElt = this.parseTemplateElement({
                isTagged: isTagged
            }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    // Parse an object literal or binding pattern.
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while(!this.eat(types$1.braceR)){
            if (!first) {
                this.expect(types$1.comma);
                if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
                    break;
                }
            } else {
                first = false;
            }
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            if (!isPattern) {
                this.checkPropClash(prop, propHash, refDestructuringErrors);
            }
            node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
            if (isPattern) {
                prop.argument = this.parseIdent(false);
                if (this.type === types$1.comma) {
                    this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                }
                return this.finishNode(prop, "RestElement");
            }
            // Parse argument.
            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
            // To disallow trailing comma via `this.toAssignable()`.
            if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
                refDestructuringErrors.trailingComma = this.start;
            }
            // Finish
            return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refDestructuringErrors) {
                startPos = this.start;
                startLoc = this.startLoc;
            }
            if (!isPattern) {
                isGenerator = this.eat(types$1.star);
            }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
            this.parsePropertyName(prop);
        } else {
            isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
    };
    pp$5.parseGetterSetter = function(prop) {
        var kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        prop.kind = kind;
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get") {
                this.raiseRecoverable(start, "getter should have no params");
            } else {
                this.raiseRecoverable(start, "setter should have exactly one param");
            }
        } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
                this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
        }
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
            this.unexpected();
        }
        if (this.eat(types$1.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
            if (isPattern) {
                this.unexpected();
            }
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
            prop.kind = "init";
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
            if (isGenerator || isAsync) {
                this.unexpected();
            }
            this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (isGenerator || isAsync) {
                this.unexpected();
            }
            this.checkUnreserved(prop.key);
            if (prop.key.name === "await" && !this.awaitIdentPos) {
                this.awaitIdentPos = startPos;
            }
            if (isPattern) {
                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else if (this.type === types$1.eq && refDestructuringErrors) {
                if (refDestructuringErrors.shorthandAssign < 0) {
                    refDestructuringErrors.shorthandAssign = this.start;
                }
                prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
            } else {
                prop.value = this.copyNode(prop.key);
            }
            prop.kind = "init";
            prop.shorthand = true;
        } else {
            this.unexpected();
        }
    };
    pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
            if (this.eat(types$1.bracketL)) {
                prop.computed = true;
                prop.key = this.parseMaybeAssign();
                this.expect(types$1.bracketR);
                return prop.key;
            } else {
                prop.computed = false;
            }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    // Initialize empty function node.
    pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
            node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
            node.async = false;
        }
    };
    // Parse object or class method.
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
            node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
            node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
    };
    // Parse arrow function expression with given parameters.
    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
            node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
    };
    // Parse function body and check parameters.
    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
            node.body = this.parseMaybeAssign(forInit);
            node.expression = true;
            this.checkParams(node, false);
        } else {
            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
            if (!oldStrict || nonSimple) {
                useStrict = this.strictDirective(this.end);
                // If this is a strict mode function, verify that argument names
                // are not repeated, and it does not try to bind the words `eval`
                // or `arguments`.
                if (useStrict && nonSimple) {
                    this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
                }
            }
            // Start a new scope with regard to labels and the `inFunction`
            // flag (restore them to their old value afterwards).
            var oldLabels = this.labels;
            this.labels = [];
            if (useStrict) {
                this.strict = true;
            }
            // Add the params to varDeclaredNames to ensure that an error is thrown
            // if a let/const declaration in the function clashes with one of the params.
            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
            // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
            if (this.strict && node.id) {
                this.checkLValSimple(node.id, BIND_OUTSIDE);
            }
            node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
            node.expression = false;
            this.adaptDirectivePrologue(node.body.body);
            this.labels = oldLabels;
        }
        this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
        for(var i = 0, list = params; i < list.length; i += 1){
            var param = list[i];
            if (param.type !== "Identifier") {
                return false;
            }
        }
        return true;
    };
    // Checks function params for various disallowed patterns such as using "eval"
    // or "arguments" and duplicate parameters.
    pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = Object.create(null);
        for(var i = 0, list = node.params; i < list.length; i += 1){
            var param = list[i];
            this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
    };
    // Parses a comma-separated list of expressions, and returns them as
    // an array. `close` is the token type that ends the list, and
    // `allowEmpty` can be turned on to allow subsequent commas with
    // nothing in between them to be parsed as `null` (which is needed
    // for array literals).
    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while(!this.eat(close)){
            if (!first) {
                this.expect(types$1.comma);
                if (allowTrailingComma && this.afterTrailingComma(close)) {
                    break;
                }
            } else {
                first = false;
            }
            var elt = void 0;
            if (allowEmpty && this.type === types$1.comma) {
                elt = null;
            } else if (this.type === types$1.ellipsis) {
                elt = this.parseSpread(refDestructuringErrors);
                if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
                    refDestructuringErrors.trailingComma = this.start;
                }
            } else {
                elt = this.parseMaybeAssign(false, refDestructuringErrors);
            }
            elts.push(elt);
        }
        return elts;
    };
    pp$5.checkUnreserved = function(ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;
        if (this.inGenerator && name === "yield") {
            this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
            this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
            this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
            this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
            return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
            if (!this.inAsync && name === "await") {
                this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
            }
            this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
    };
    // Parse the next token as an identifier. If `liberal` is true (used
    // when parsing properties), it will also convert keywords into
    // identifiers.
    pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
            this.checkUnreserved(node);
            if (node.name === "await" && !this.awaitIdentPos) {
                this.awaitIdentPos = node.start;
            }
        }
        return node;
    };
    pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
            node.name = this.value;
        } else if (this.type.keyword) {
            node.name = this.type.keyword;
            // To fix https://github.com/acornjs/acorn/issues/575
            // `class` and `function` keywords push new context into this.context.
            // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
            // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
            if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
                this.context.pop();
            }
            this.type = types$1.name;
        } else {
            this.unexpected();
        }
        return node;
    };
    pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
            node.name = this.value;
        } else {
            this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        // For validating existence
        if (this.options.checkPrivateFields) {
            if (this.privateNameStack.length === 0) {
                this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
            } else {
                this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
            }
        }
        return node;
    };
    // Parses yield expression inside generator.
    pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
            this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
            node.delegate = false;
            node.argument = null;
        } else {
            node.delegate = this.eat(types$1.star);
            node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
            this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
    };
    var pp$4 = Parser.prototype;
    // This function is used to raise exceptions on parse errors. It
    // takes an offset integer (into the current `input`) to indicate
    // the location of the error, attaches the position to the end
    // of the error message, and then raises a `SyntaxError` with that
    // message.
    pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        if (this.sourceFile) {
            message += " in " + this.sourceFile;
        }
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
        if (this.options.locations) {
            return new Position(this.curLine, this.pos - this.lineStart);
        }
    };
    var pp$3 = Parser.prototype;
    var Scope = function Scope(flags) {
        this.flags = flags;
        // A list of var-declared names in the current lexical scope
        this.var = [];
        // A list of lexically-declared names in the current lexical scope
        this.lexical = [];
        // A list of lexically-declared FunctionDeclaration names in the current lexical scope
        this.functions = [];
    };
    // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.
    pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
    };
    pp$3.exitScope = function() {
        this.scopeStack.pop();
    };
    // The spec says:
    // > At the top level of a function, or script, function declarations are
    // > treated like var declarations rather than like lexical declarations.
    pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
            scope.lexical.push(name);
            if (this.inModule && scope.flags & SCOPE_TOP) {
                delete this.undefinedExports[name];
            }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
            var scope$1 = this.currentScope();
            scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
            var scope$2 = this.currentScope();
            if (this.treatFunctionsAsVar) {
                redeclared = scope$2.lexical.indexOf(name) > -1;
            } else {
                redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
            }
            scope$2.functions.push(name);
        } else {
            for(var i = this.scopeStack.length - 1; i >= 0; --i){
                var scope$3 = this.scopeStack[i];
                if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                    redeclared = true;
                    break;
                }
                scope$3.var.push(name);
                if (this.inModule && scope$3.flags & SCOPE_TOP) {
                    delete this.undefinedExports[name];
                }
                if (scope$3.flags & SCOPE_VAR) {
                    break;
                }
            }
        }
        if (redeclared) {
            this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
    };
    pp$3.checkLocalExport = function(id) {
        // scope.functions must be empty as Module code is always strict.
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
            this.undefinedExports[id.name] = id;
        }
    };
    pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
        for(var i = this.scopeStack.length - 1;; i--){
            var scope = this.scopeStack[i];
            if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
                return scope;
            }
        }
    };
    // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
    pp$3.currentThisScope = function() {
        for(var i = this.scopeStack.length - 1;; i--){
            var scope = this.scopeStack[i];
            if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
                return scope;
            }
        }
    };
    var Node = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
            this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
            this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
            this.range = [
                pos,
                0
            ];
        }
    };
    // Start an AST node, attaching a start offset.
    var pp$2 = Parser.prototype;
    pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
    };
    // Finish an AST node, adding `type` and `end` properties.
    function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
            node.loc.end = loc;
        }
        if (this.options.ranges) {
            node.range[1] = pos;
        }
        return node;
    }
    pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    // Finish node at given position
    pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
    };
    pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for(var prop in node){
            newNode[prop] = node[prop];
        }
        return newNode;
    };
    // This file was generated by "bin/generate-unicode-script-values.js". Do not modify manually!
    var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
    // This file contains Unicode properties extracted from the ECMAScript specification.
    // The lists are extracted like so:
    // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)
    // #table-binary-unicode-properties
    var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    var ecma11BinaryProperties = ecma10BinaryProperties;
    var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    var ecma13BinaryProperties = ecma12BinaryProperties;
    var ecma14BinaryProperties = ecma13BinaryProperties;
    var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
    };
    // #table-binary-unicode-properties-of-strings
    var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
    var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
    };
    // #table-unicode-general-category-values
    var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    // #table-unicode-script-values
    var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
    var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
    };
    var data = {};
    function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
            binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
            nonBinary: {
                General_Category: wordsRegexp(unicodeGeneralCategoryValues),
                Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
            }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
    }
    for(var i = 0, list = [
        9,
        10,
        11,
        12,
        13,
        14
    ]; i < list.length; i += 1){
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
    }
    var pp$1 = Parser.prototype;
    // Track disjunction structure to determine whether a duplicate
    // capture group name is allowed because it is in a separate branch.
    var BranchID = function BranchID(parent, base) {
        // Parent disjunction branch
        this.parent = parent;
        // Identifies this set of sibling branches
        this.base = base || this;
    };
    BranchID.prototype.separatedFrom = function separatedFrom(alt) {
        // A branch is separate from another branch if they or any of
        // their parents are siblings in a given disjunction
        for(var self1 = this; self1; self1 = self1.parent){
            for(var other = alt; other; other = other.parent){
                if (self1.base === other.base && self1 !== other) {
                    return true;
                }
            }
        }
        return false;
    };
    BranchID.prototype.sibling = function sibling() {
        return new BranchID(this.parent, this.base);
    };
    var RegExpValidationState = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = Object.create(null);
        this.backReferenceNames = [];
        this.branchID = null;
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
            this.switchU = true;
            this.switchV = true;
            this.switchN = true;
        } else {
            this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
            this.switchV = false;
            this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
    };
    RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    // If u flag is given, this returns the code point at the index (it combines a surrogate pair).
    // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
    RegExpValidationState.prototype.at = function at(i, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
            return -1;
        }
        var c = s.charCodeAt(i);
        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
            return c;
        }
        var next = s.charCodeAt(i + 1);
        return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i >= l) {
            return l;
        }
        var c = s.charCodeAt(i), next;
        if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
            return i + 1;
        }
        return i + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
            this.advance(forceU);
            return true;
        }
        return false;
    };
    RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0) forceU = false;
        var pos = this.pos;
        for(var i = 0, list = chs; i < list.length; i += 1){
            var ch = list[i];
            var current = this.at(pos, forceU);
            if (current === -1 || current !== ch) {
                return false;
            }
            pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
    };
    /**
   * Validate the flags part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */ pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for(var i = 0; i < flags.length; i++){
            var flag = flags.charAt(i);
            if (validFlags.indexOf(flag) === -1) {
                this.raise(state.start, "Invalid regular expression flag");
            }
            if (flags.indexOf(flag, i + 1) > -1) {
                this.raise(state.start, "Duplicate regular expression flag");
            }
            if (flag === "u") {
                u = true;
            }
            if (flag === "v") {
                v = true;
            }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
            this.raise(state.start, "Invalid regular expression flag");
        }
    };
    function hasProp(obj) {
        for(var _ in obj){
            return true;
        }
        return false;
    }
    /**
   * Validate the pattern part of a given RegExpLiteral.
   *
   * @param {RegExpValidationState} state The state to validate RegExp.
   * @returns {void}
   */ pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
        // parsing contains a |GroupName|, reparse with the goal symbol
        // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
        // exception if _P_ did not conform to the grammar, if any elements of _P_
        // were not matched by the parse, or if any Early Error conditions exist.
        if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
            state.switchN = true;
            this.regexp_pattern(state);
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
    pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames = Object.create(null);
        state.backReferenceNames.length = 0;
        state.branchID = null;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
            // Make the same messages as V8.
            if (state.eat(0x29 /* ) */ )) {
                state.raise("Unmatched ')'");
            }
            if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) {
                state.raise("Lone quantifier brackets");
            }
        }
        if (state.maxBackReference > state.numCapturingParens) {
            state.raise("Invalid escape");
        }
        for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){
            var name = list[i];
            if (!state.groupNames[name]) {
                state.raise("Invalid named capture referenced");
            }
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
    pp$1.regexp_disjunction = function(state) {
        var trackDisjunction = this.options.ecmaVersion >= 16;
        if (trackDisjunction) {
            state.branchID = new BranchID(state.branchID, null);
        }
        this.regexp_alternative(state);
        while(state.eat(0x7C /* | */ )){
            if (trackDisjunction) {
                state.branchID = state.branchID.sibling();
            }
            this.regexp_alternative(state);
        }
        if (trackDisjunction) {
            state.branchID = state.branchID.parent;
        }
        // Make the same message as V8.
        if (this.regexp_eatQuantifier(state, true)) {
            state.raise("Nothing to repeat");
        }
        if (state.eat(0x7B /* { */ )) {
            state.raise("Lone quantifier brackets");
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
    pp$1.regexp_alternative = function(state) {
        while(state.pos < state.source.length && this.regexp_eatTerm(state)){}
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
    pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
            // Handle `QuantifiableAssertion Quantifier` alternative.
            // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
            // is a QuantifiableAssertion.
            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
                // Make the same message as V8.
                if (state.switchU) {
                    state.raise("Invalid quantifier");
                }
            }
            return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
            this.regexp_eatQuantifier(state);
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
    pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        // ^, $
        if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) {
            return true;
        }
        // \b \B
        if (state.eat(0x5C /* \ */ )) {
            if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) {
                return true;
            }
            state.pos = start;
        }
        // Lookahead / Lookbehind
        if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {
            var lookbehind = false;
            if (this.options.ecmaVersion >= 9) {
                lookbehind = state.eat(0x3C /* < */ );
            }
            if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {
                this.regexp_disjunction(state);
                if (!state.eat(0x29 /* ) */ )) {
                    state.raise("Unterminated group");
                }
                state.lastAssertionIsQuantifiable = !lookbehind;
                return true;
            }
        }
        state.pos = start;
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
    pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
            state.eat(0x3F /* ? */ );
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(0x7B /* { */ )) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state)) {
                min = state.lastIntValue;
                if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) {
                    max = state.lastIntValue;
                }
                if (state.eat(0x7D /* } */ )) {
                    // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
                    if (max !== -1 && max < min && !noError) {
                        state.raise("numbers out of order in {} quantifier");
                    }
                    return true;
                }
            }
            if (state.switchU && !noError) {
                state.raise("Incomplete quantifier");
            }
            state.pos = start;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
    pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatAtomEscape(state)) {
                return true;
            }
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(0x28 /* ( */ )) {
            if (state.eat(0x3F /* ? */ )) {
                if (this.options.ecmaVersion >= 16) {
                    var addModifiers = this.regexp_eatModifiers(state);
                    var hasHyphen = state.eat(0x2D /* - */ );
                    if (addModifiers || hasHyphen) {
                        for(var i = 0; i < addModifiers.length; i++){
                            var modifier = addModifiers.charAt(i);
                            if (addModifiers.indexOf(modifier, i + 1) > -1) {
                                state.raise("Duplicate regular expression modifiers");
                            }
                        }
                        if (hasHyphen) {
                            var removeModifiers = this.regexp_eatModifiers(state);
                            if (!addModifiers && !removeModifiers && state.current() === 0x3A /* : */ ) {
                                state.raise("Invalid regular expression modifiers");
                            }
                            for(var i$1 = 0; i$1 < removeModifiers.length; i$1++){
                                var modifier$1 = removeModifiers.charAt(i$1);
                                if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                                    state.raise("Duplicate regular expression modifiers");
                                }
                            }
                        }
                    }
                }
                if (state.eat(0x3A /* : */ )) {
                    this.regexp_disjunction(state);
                    if (state.eat(0x29 /* ) */ )) {
                        return true;
                    }
                    state.raise("Unterminated group");
                }
            }
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(0x28 /* ( */ )) {
            if (this.options.ecmaVersion >= 9) {
                this.regexp_groupSpecifier(state);
            } else if (state.current() === 0x3F /* ? */ ) {
                state.raise("Invalid group");
            }
            this.regexp_disjunction(state);
            if (state.eat(0x29 /* ) */ )) {
                state.numCapturingParens += 1;
                return true;
            }
            state.raise("Unterminated group");
        }
        return false;
    };
    // RegularExpressionModifiers ::
    //   [empty]
    //   RegularExpressionModifiers RegularExpressionModifier
    pp$1.regexp_eatModifiers = function(state) {
        var modifiers = "";
        var ch = 0;
        while((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)){
            modifiers += codePointToString(ch);
            state.advance();
        }
        return modifiers;
    };
    // RegularExpressionModifier :: one of
    //   `i` `m` `s`
    function isRegularExpressionModifier(ch) {
        return ch === 0x69 /* i */  || ch === 0x6d /* m */  || ch === 0x73 /* s */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
    pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
            state.raise("Nothing to repeat");
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
    pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    function isSyntaxCharacter(ch) {
        return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
    // But eat eager.
    pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)){
            state.advance();
        }
        return state.pos !== start;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {
            state.advance();
            return true;
        }
        return false;
    };
    // GroupSpecifier ::
    //   [empty]
    //   `?` GroupName
    pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(0x3F /* ? */ )) {
            if (!this.regexp_eatGroupName(state)) {
                state.raise("Invalid group");
            }
            var trackDisjunction = this.options.ecmaVersion >= 16;
            var known = state.groupNames[state.lastStringValue];
            if (known) {
                if (trackDisjunction) {
                    for(var i = 0, list = known; i < list.length; i += 1){
                        var altID = list[i];
                        if (!altID.separatedFrom(state.branchID)) {
                            state.raise("Duplicate capture group name");
                        }
                    }
                } else {
                    state.raise("Duplicate capture group name");
                }
            }
            if (trackDisjunction) {
                (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
            } else {
                state.groupNames[state.lastStringValue] = true;
            }
        }
    };
    // GroupName ::
    //   `<` RegExpIdentifierName `>`
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(0x3C /* < */ )) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) {
                return true;
            }
            state.raise("Invalid capture group name");
        }
        return false;
    };
    // RegExpIdentifierName ::
    //   RegExpIdentifierStart
    //   RegExpIdentifierName RegExpIdentifierPart
    // Note: this updates `state.lastStringValue` property with the eaten name.
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
            while(this.regexp_eatRegExpIdentifierPart(state)){
                state.lastStringValue += codePointToString(state.lastIntValue);
            }
            return true;
        }
        return false;
    };
    // RegExpIdentifierStart ::
    //   UnicodeIDStart
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
            state.lastIntValue = ch;
            return true;
        }
        state.pos = start;
        return false;
    };
    function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;
    }
    // RegExpIdentifierPart ::
    //   UnicodeIDContinue
    //   `$`
    //   `_`
    //   `\` RegExpUnicodeEscapeSequence[+U]
    //   <ZWNJ>
    //   <ZWJ>
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 0x5C /* \ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
            ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
            state.lastIntValue = ch;
            return true;
        }
        state.pos = start;
        return false;
    };
    function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
    pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
            return true;
        }
        if (state.switchU) {
            // Make the same message as V8.
            if (state.current() === 0x63 /* c */ ) {
                state.raise("Invalid unicode escape");
            }
            state.raise("Invalid escape");
        }
        return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
            var n = state.lastIntValue;
            if (state.switchU) {
                // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
                if (n > state.maxBackReference) {
                    state.maxBackReference = n;
                }
                return true;
            }
            if (n <= state.numCapturingParens) {
                return true;
            }
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(0x6B /* k */ )) {
            if (this.regexp_eatGroupName(state)) {
                state.backReferenceNames.push(state.lastStringValue);
                return true;
            }
            state.raise("Invalid named reference");
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
    pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(0x63 /* c */ )) {
            if (this.regexp_eatControlLetter(state)) {
                return true;
            }
            state.pos = start;
        }
        return false;
    };
    pp$1.regexp_eatZero = function(state) {
        if (state.current() === 0x30 /* 0 */  && !isDecimalDigit(state.lookahead())) {
            state.lastIntValue = 0;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
    pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 0x74 /* t */ ) {
            state.lastIntValue = 0x09; /* \t */ 
            state.advance();
            return true;
        }
        if (ch === 0x6E /* n */ ) {
            state.lastIntValue = 0x0A; /* \n */ 
            state.advance();
            return true;
        }
        if (ch === 0x76 /* v */ ) {
            state.lastIntValue = 0x0B; /* \v */ 
            state.advance();
            return true;
        }
        if (ch === 0x66 /* f */ ) {
            state.lastIntValue = 0x0C; /* \f */ 
            state.advance();
            return true;
        }
        if (ch === 0x72 /* r */ ) {
            state.lastIntValue = 0x0D; /* \r */ 
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
    pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true;
        }
        return false;
    };
    function isControlLetter(ch) {
        return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(0x75 /* u */ )) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
                var lead = state.lastIntValue;
                if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
                    var leadSurrogateEnd = state.pos;
                    if (state.eat(0x5C /* \ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {
                        var trail = state.lastIntValue;
                        if (trail >= 0xDC00 && trail <= 0xDFFF) {
                            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                            return true;
                        }
                    }
                    state.pos = leadSurrogateEnd;
                    state.lastIntValue = lead;
                }
                return true;
            }
            if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && isValidUnicode(state.lastIntValue)) {
                return true;
            }
            if (switchU) {
                state.raise("Invalid unicode escape");
            }
            state.pos = start;
        }
        return false;
    };
    function isValidUnicode(ch) {
        return ch >= 0 && ch <= 0x10FFFF;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
    pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
            if (this.regexp_eatSyntaxCharacter(state)) {
                return true;
            }
            if (state.eat(0x2F /* / */ )) {
                state.lastIntValue = 0x2F; /* / */ 
                return true;
            }
            return false;
        }
        var ch = state.current();
        if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
    pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {
            do {
                state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
                state.advance();
            }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );
            return true;
        }
        return false;
    };
    // Return values used by character set parsing methods, needed to
    // forbid negation of sets that can match strings.
    var CharSetNone = 0; // Nothing parsed
    var CharSetOk = 1; // Construct parsed, cannot contain strings
    var CharSetString = 2; // Construct parsed, can contain strings
    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
    pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
            state.lastIntValue = -1;
            state.advance();
            return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {
            state.lastIntValue = -1;
            state.advance();
            var result;
            if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {
                if (negate && result === CharSetString) {
                    state.raise("Invalid property name");
                }
                return result;
            }
            state.raise("Invalid property name");
        }
        return CharSetNone;
    };
    function isCharacterClassEscape(ch) {
        return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;
    }
    // UnicodePropertyValueExpression ::
    //   UnicodePropertyName `=` UnicodePropertyValue
    //   LoneUnicodePropertyNameOrValue
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        // UnicodePropertyName `=` UnicodePropertyValue
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {
            var name = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
                var value = state.lastStringValue;
                this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
                return CharSetOk;
            }
        }
        state.pos = start;
        // LoneUnicodePropertyNameOrValue
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
            state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
            state.raise("Invalid property value");
        }
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
            return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
            return CharSetString;
        }
        state.raise("Invalid property name");
    };
    // UnicodePropertyName ::
    //   UnicodePropertyNameCharacters
    pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while(isUnicodePropertyNameCharacter(ch = state.current())){
            state.lastStringValue += codePointToString(ch);
            state.advance();
        }
        return state.lastStringValue !== "";
    };
    function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 0x5F /* _ */ ;
    }
    // UnicodePropertyValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while(isUnicodePropertyValueCharacter(ch = state.current())){
            state.lastStringValue += codePointToString(ch);
            state.advance();
        }
        return state.lastStringValue !== "";
    };
    function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
    }
    // LoneUnicodePropertyNameOrValue ::
    //   UnicodePropertyValueCharacters
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
    pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(0x5B /* [ */ )) {
            var negate = state.eat(0x5E /* ^ */ );
            var result = this.regexp_classContents(state);
            if (!state.eat(0x5D /* ] */ )) {
                state.raise("Unterminated character class");
            }
            if (negate && result === CharSetString) {
                state.raise("Negated character class may contain strings");
            }
            return true;
        }
        return false;
    };
    // https://tc39.es/ecma262/#prod-ClassContents
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
    pp$1.regexp_classContents = function(state) {
        if (state.current() === 0x5D /* ] */ ) {
            return CharSetOk;
        }
        if (state.switchV) {
            return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
    // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
    pp$1.regexp_nonEmptyClassRanges = function(state) {
        while(this.regexp_eatClassAtom(state)){
            var left = state.lastIntValue;
            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {
                var right = state.lastIntValue;
                if (state.switchU && (left === -1 || right === -1)) {
                    state.raise("Invalid character class");
                }
                if (left !== -1 && right !== -1 && left > right) {
                    state.raise("Range out of order in character class");
                }
            }
        }
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
    // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
    pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatClassEscape(state)) {
                return true;
            }
            if (state.switchU) {
                // Make the same message as V8.
                var ch$1 = state.current();
                if (ch$1 === 0x63 /* c */  || isOctalDigit(ch$1)) {
                    state.raise("Invalid class escape");
                }
                state.raise("Invalid escape");
            }
            state.pos = start;
        }
        var ch = state.current();
        if (ch !== 0x5D /* ] */ ) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
    pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(0x62 /* b */ )) {
            state.lastIntValue = 0x08; /* <BS> */ 
            return true;
        }
        if (state.switchU && state.eat(0x2D /* - */ )) {
            state.lastIntValue = 0x2D; /* - */ 
            return true;
        }
        if (!state.switchU && state.eat(0x63 /* c */ )) {
            if (this.regexp_eatClassControlLetter(state)) {
                return true;
            }
            state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    // https://tc39.es/ecma262/#prod-ClassSetExpression
    // https://tc39.es/ecma262/#prod-ClassUnion
    // https://tc39.es/ecma262/#prod-ClassIntersection
    // https://tc39.es/ecma262/#prod-ClassSubtraction
    pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state)) ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
            if (subResult === CharSetString) {
                result = CharSetString;
            }
            // https://tc39.es/ecma262/#prod-ClassIntersection
            var start = state.pos;
            while(state.eatChars([
                0x26,
                0x26
            ])){
                if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {
                    if (subResult !== CharSetString) {
                        result = CharSetOk;
                    }
                    continue;
                }
                state.raise("Invalid character in character class");
            }
            if (start !== state.pos) {
                return result;
            }
            // https://tc39.es/ecma262/#prod-ClassSubtraction
            while(state.eatChars([
                0x2D,
                0x2D
            ])){
                if (this.regexp_eatClassSetOperand(state)) {
                    continue;
                }
                state.raise("Invalid character in character class");
            }
            if (start !== state.pos) {
                return result;
            }
        } else {
            state.raise("Invalid character in character class");
        }
        // https://tc39.es/ecma262/#prod-ClassUnion
        for(;;){
            if (this.regexp_eatClassSetRange(state)) {
                continue;
            }
            subResult = this.regexp_eatClassSetOperand(state);
            if (!subResult) {
                return result;
            }
            if (subResult === CharSetString) {
                result = CharSetString;
            }
        }
    };
    // https://tc39.es/ecma262/#prod-ClassSetRange
    pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
            var left = state.lastIntValue;
            if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {
                var right = state.lastIntValue;
                if (left !== -1 && right !== -1 && left > right) {
                    state.raise("Range out of order in character class");
                }
                return true;
            }
            state.pos = start;
        }
        return false;
    };
    // https://tc39.es/ecma262/#prod-ClassSetOperand
    pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
            return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
    };
    // https://tc39.es/ecma262/#prod-NestedClass
    pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(0x5B /* [ */ )) {
            var negate = state.eat(0x5E /* ^ */ );
            var result = this.regexp_classContents(state);
            if (state.eat(0x5D /* ] */ )) {
                if (negate && result === CharSetString) {
                    state.raise("Negated character class may contain strings");
                }
                return result;
            }
            state.pos = start;
        }
        if (state.eat(0x5C /* \ */ )) {
            var result$1 = this.regexp_eatCharacterClassEscape(state);
            if (result$1) {
                return result$1;
            }
            state.pos = start;
        }
        return null;
    };
    // https://tc39.es/ecma262/#prod-ClassStringDisjunction
    pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars([
            0x5C,
            0x71
        ])) {
            if (state.eat(0x7B /* { */ )) {
                var result = this.regexp_classStringDisjunctionContents(state);
                if (state.eat(0x7D /* } */ )) {
                    return result;
                }
            } else {
                // Make the same message as V8.
                state.raise("Invalid escape");
            }
            state.pos = start;
        }
        return null;
    };
    // https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
    pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while(state.eat(0x7C /* | */ )){
            if (this.regexp_classString(state) === CharSetString) {
                result = CharSetString;
            }
        }
        return result;
    };
    // https://tc39.es/ecma262/#prod-ClassString
    // https://tc39.es/ecma262/#prod-NonEmptyClassString
    pp$1.regexp_classString = function(state) {
        var count = 0;
        while(this.regexp_eatClassSetCharacter(state)){
            count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
    };
    // https://tc39.es/ecma262/#prod-ClassSetCharacter
    pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(0x5C /* \ */ )) {
            if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
                return true;
            }
            if (state.eat(0x62 /* b */ )) {
                state.lastIntValue = 0x08; /* <BS> */ 
                return true;
            }
            state.pos = start;
            return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
            return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
            return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
    };
    // https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
    function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;
    }
    // https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
    function isClassSetSyntaxCharacter(ch) {
        return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;
    }
    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true;
        }
        return false;
    };
    // https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
    function isClassSetReservedPunctuator(ch) {
        return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
    pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(0x78 /* x */ )) {
            if (this.regexp_eatFixedHexDigits(state, 2)) {
                return true;
            }
            if (state.switchU) {
                state.raise("Invalid escape");
            }
            state.pos = start;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
    pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while(isDecimalDigit(ch = state.current())){
            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );
            state.advance();
        }
        return state.pos !== start;
    };
    function isDecimalDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
    pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while(isHexDigit(ch = state.current())){
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
        }
        return state.pos !== start;
    };
    function isHexDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;
    }
    function hexToInt(ch) {
        if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) {
            return 10 + (ch - 0x41 /* A */ );
        }
        if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) {
            return 10 + (ch - 0x61 /* a */ );
        }
        return ch - 0x30 /* 0 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
    // Allows only 0-377(octal) i.e. 0-255(decimal).
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
                var n2 = state.lastIntValue;
                if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
                    state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
                } else {
                    state.lastIntValue = n1 * 8 + n2;
                }
            } else {
                state.lastIntValue = n1;
            }
            return true;
        }
        return false;
    };
    // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
    pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
            state.lastIntValue = ch - 0x30; /* 0 */ 
            state.advance();
            return true;
        }
        state.lastIntValue = 0;
        return false;
    };
    function isOctalDigit(ch) {
        return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;
    }
    // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
    // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
    // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for(var i = 0; i < length; ++i){
            var ch = state.current();
            if (!isHexDigit(ch)) {
                state.pos = start;
                return false;
            }
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
        }
        return true;
    };
    // Object type used to represent tokens. Note that normally, tokens
    // simply exist as properties on the parser object. This is only
    // used for the onToken callback and the external tokenizer.
    var Token = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
            this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
            this.range = [
                p.start,
                p.end
            ];
        }
    };
    // ## Tokenizer
    var pp = Parser.prototype;
    // Move to the next token
    pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
            this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
            this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
    };
    pp.getToken = function() {
        this.next();
        return new Token(this);
    };
    // If we're in an ES6 environment, make parsers iterable
    if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
            var this$1$1 = this;
            return {
                next: function() {
                    var token = this$1$1.getToken();
                    return {
                        done: token.type === types$1.eof,
                        value: token
                    };
                }
            };
        };
    }
    // Toggle strict mode. Re-reads the next number or string to please
    // pedantic tests (`"use strict"; 010;` should fail).
    // Read a single token, updating the parser object's token-related
    // properties.
    pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
            this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
            this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
            return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
            return curContext.override(this);
        } else {
            this.readToken(this.fullCharCodeAtPos());
        }
    };
    pp.readToken = function(code) {
        // Identifier or keyword. '\uXXXX' sequences are allowed in
        // identifiers, so '\' also dispatches to that.
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */ ) {
            return this.readWord();
        }
        return this.getTokenFromCode(code);
    };
    pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 0xd7ff || code >= 0xdc00) {
            return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;
    };
    pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
            this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
            for(var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;){
                ++this.curLine;
                pos = this.lineStart = nextBreak;
            }
        }
        if (this.options.onComment) {
            this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
        }
    };
    pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while(this.pos < this.input.length && !isNewLine(ch)){
            ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
            this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
        }
    };
    // Called at the start of the parse and after every token. Skips
    // whitespace and comments, and.
    pp.skipSpace = function() {
        loop: while(this.pos < this.input.length){
            var ch = this.input.charCodeAt(this.pos);
            switch(ch){
                case 32:
                case 160:
                    ++this.pos;
                    break;
                case 13:
                    if (this.input.charCodeAt(this.pos + 1) === 10) {
                        ++this.pos;
                    }
                case 10:
                case 8232:
                case 8233:
                    ++this.pos;
                    if (this.options.locations) {
                        ++this.curLine;
                        this.lineStart = this.pos;
                    }
                    break;
                case 47:
                    switch(this.input.charCodeAt(this.pos + 1)){
                        case 42:
                            this.skipBlockComment();
                            break;
                        case 47:
                            this.skipLineComment(2);
                            break;
                        default:
                            break loop;
                    }
                    break;
                default:
                    if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                        ++this.pos;
                    } else {
                        break loop;
                    }
            }
        }
    };
    // Called at the end of every token. Sets `end`, `val`, and
    // maintains `context` and `exprAllowed`, and skips the space after
    // the token, so that the next one's `start` will point at the
    // right position.
    pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
            this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
    };
    // ### Token reading
    // This is the function that is called to fetch the next token. It
    // is somewhat obscure, because it works in character codes rather
    // than characters, and because operator parsing has been inlined
    // into it.
    //
    // All in the name of speed.
    //
    pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
            return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
            this.pos += 3;
            return this.finishToken(types$1.ellipsis);
        } else {
            ++this.pos;
            return this.finishToken(types$1.dot);
        }
    };
    pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
            ++this.pos;
            return this.readRegexp();
        }
        if (next === 61) {
            return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
    };
    pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        // exponentiation operator ** and **=
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
            ++size;
            tokentype = types$1.starstar;
            next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
            return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
    };
    pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
            if (this.options.ecmaVersion >= 12) {
                var next2 = this.input.charCodeAt(this.pos + 2);
                if (next2 === 61) {
                    return this.finishOp(types$1.assign, 3);
                }
            }
            return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
            return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
            return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
                // A `-->` line comment
                this.skipLineComment(3);
                this.skipSpace();
                return this.nextToken();
            }
            return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
            return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
    };
    pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(this.pos + size) === 61) {
                return this.finishOp(types$1.assign, size + 1);
            }
            return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
            // `<!--`, an XML-style comment that should be interpreted as a line comment
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken();
        }
        if (next === 61) {
            size = 2;
        }
        return this.finishOp(types$1.relational, size);
    };
    pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
            return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
            this.pos += 2;
            return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp.readToken_question = function() {
        var ecmaVersion = this.options.ecmaVersion;
        if (ecmaVersion >= 11) {
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 46) {
                var next2 = this.input.charCodeAt(this.pos + 2);
                if (next2 < 48 || next2 > 57) {
                    return this.finishOp(types$1.questionDot, 2);
                }
            }
            if (next === 63) {
                if (ecmaVersion >= 12) {
                    var next2$1 = this.input.charCodeAt(this.pos + 2);
                    if (next2$1 === 61) {
                        return this.finishOp(types$1.assign, 3);
                    }
                }
                return this.finishOp(types$1.coalesce, 2);
            }
        }
        return this.finishOp(types$1.question, 1);
    };
    pp.readToken_numberSign = function() {
        var ecmaVersion = this.options.ecmaVersion;
        var code = 35; // '#'
        if (ecmaVersion >= 13) {
            ++this.pos;
            code = this.fullCharCodeAtPos();
            if (isIdentifierStart(code, true) || code === 92 /* '\' */ ) {
                return this.finishToken(types$1.privateId, this.readWord1());
            }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.getTokenFromCode = function(code) {
        switch(code){
            // The interpretation of a dot depends on whether it is followed
            // by a digit or another two dots.
            case 46:
                return this.readToken_dot();
            // Punctuation tokens.
            case 40:
                ++this.pos;
                return this.finishToken(types$1.parenL);
            case 41:
                ++this.pos;
                return this.finishToken(types$1.parenR);
            case 59:
                ++this.pos;
                return this.finishToken(types$1.semi);
            case 44:
                ++this.pos;
                return this.finishToken(types$1.comma);
            case 91:
                ++this.pos;
                return this.finishToken(types$1.bracketL);
            case 93:
                ++this.pos;
                return this.finishToken(types$1.bracketR);
            case 123:
                ++this.pos;
                return this.finishToken(types$1.braceL);
            case 125:
                ++this.pos;
                return this.finishToken(types$1.braceR);
            case 58:
                ++this.pos;
                return this.finishToken(types$1.colon);
            case 96:
                if (this.options.ecmaVersion < 6) {
                    break;
                }
                ++this.pos;
                return this.finishToken(types$1.backQuote);
            case 48:
                var next = this.input.charCodeAt(this.pos + 1);
                if (next === 120 || next === 88) {
                    return this.readRadixNumber(16);
                } // '0x', '0X' - hex number
                if (this.options.ecmaVersion >= 6) {
                    if (next === 111 || next === 79) {
                        return this.readRadixNumber(8);
                    } // '0o', '0O' - octal number
                    if (next === 98 || next === 66) {
                        return this.readRadixNumber(2);
                    } // '0b', '0B' - binary number
                }
            // Anything else beginning with a digit is an integer, octal
            // number, or float.
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
                return this.readNumber(false);
            // Quotes produce strings.
            case 34:
            case 39:
                return this.readString(code);
            // Operators are parsed inline in tiny state machines. '=' (61) is
            // often referred to. `finishOp` simply skips the amount of
            // characters it is given as second argument, and returns a token
            // of the type given by its first argument.
            case 47:
                return this.readToken_slash();
            case 37:
            case 42:
                return this.readToken_mult_modulo_exp(code);
            case 124:
            case 38:
                return this.readToken_pipe_amp(code);
            case 94:
                return this.readToken_caret();
            case 43:
            case 45:
                return this.readToken_plus_min(code);
            case 60:
            case 62:
                return this.readToken_lt_gt(code);
            case 61:
            case 33:
                return this.readToken_eq_excl(code);
            case 63:
                return this.readToken_question();
            case 126:
                return this.finishOp(types$1.prefix, 1);
            case 35:
                return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
    };
    pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for(;;){
            if (this.pos >= this.input.length) {
                this.raise(start, "Unterminated regular expression");
            }
            var ch = this.input.charAt(this.pos);
            if (lineBreak.test(ch)) {
                this.raise(start, "Unterminated regular expression");
            }
            if (!escaped) {
                if (ch === "[") {
                    inClass = true;
                } else if (ch === "]" && inClass) {
                    inClass = false;
                } else if (ch === "/" && !inClass) {
                    break;
                }
                escaped = ch === "\\";
            } else {
                escaped = false;
            }
            ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
            this.unexpected(flagsStart);
        }
        // Validate pattern
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        // Create Literal#value property value.
        var value = null;
        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
        // ESTree requires null if it failed to instantiate RegExp object.
        // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
        }
        return this.finishToken(types$1.regexp, {
            pattern: pattern,
            flags: flags,
            value: value
        });
    };
    // Read an integer in the given radix. Return null if zero digits
    // were read, the integer value otherwise. When `len` is given, this
    // will return `null` unless the integer has exactly `len` digits.
    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        // `len` is used for character escape sequences. In that case, disallow separators.
        var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
        // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
        // and isn't fraction part nor exponent part. In that case, if the first digit
        // is zero then disallow separators.
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){
            var code = this.input.charCodeAt(this.pos), val = void 0;
            if (allowSeparators && code === 95) {
                if (isLegacyOctalNumericLiteral) {
                    this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
                }
                if (lastCode === 95) {
                    this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
                }
                if (i === 0) {
                    this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
                }
                lastCode = code;
                continue;
            }
            if (code >= 97) {
                val = code - 97 + 10;
            } else if (code >= 65) {
                val = code - 65 + 10;
            } else if (code >= 48 && code <= 57) {
                val = code - 48;
            } else {
                val = Infinity;
            }
            if (val >= radix) {
                break;
            }
            lastCode = code;
            total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
            this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
            return null;
        }
        return total;
    };
    function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
            return parseInt(str, 8);
        }
        // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
        return parseFloat(str.replace(/_/g, ""));
    }
    function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
            return null;
        }
        // `BigInt(value)` throws syntax error if the string contains numeric separators.
        return BigInt(str.replace(/_/g, ""));
    }
    pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2; // 0x
        var val = this.readInt(radix);
        if (val == null) {
            this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
            val = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
    };
    // Read an integer, octal integer, or floating-point number.
    pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, undefined, true) === null) {
            this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
            this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
            var val$1 = stringToBigInt(this.input.slice(start, this.pos));
            ++this.pos;
            if (isIdentifierStart(this.fullCharCodeAtPos())) {
                this.raise(this.pos, "Identifier directly after number");
            }
            return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
            octal = false;
        }
        if (next === 46 && !octal) {
            ++this.pos;
            this.readInt(10);
            next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
            next = this.input.charCodeAt(++this.pos);
            if (next === 43 || next === 45) {
                ++this.pos;
            } // '+-'
            if (this.readInt(10) === null) {
                this.raise(start, "Invalid number");
            }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
    };
    // Read a string value, interpreting backslash-escapes.
    pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
            if (this.options.ecmaVersion < 6) {
                this.unexpected();
            }
            var codePos = ++this.pos;
            code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
            ++this.pos;
            if (code > 0x10FFFF) {
                this.invalidStringToken(codePos, "Code point out of bounds");
            }
        } else {
            code = this.readHexChar(4);
        }
        return code;
    };
    pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for(;;){
            if (this.pos >= this.input.length) {
                this.raise(this.start, "Unterminated string constant");
            }
            var ch = this.input.charCodeAt(this.pos);
            if (ch === quote) {
                break;
            }
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.readEscapedChar(false);
                chunkStart = this.pos;
            } else if (ch === 0x2028 || ch === 0x2029) {
                if (this.options.ecmaVersion < 10) {
                    this.raise(this.start, "Unterminated string constant");
                }
                ++this.pos;
                if (this.options.locations) {
                    this.curLine++;
                    this.lineStart = this.pos;
                }
            } else {
                if (isNewLine(ch)) {
                    this.raise(this.start, "Unterminated string constant");
                }
                ++this.pos;
            }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
    };
    // Reads template string tokens.
    var INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
            this.readTmplToken();
        } catch (err) {
            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
                this.readInvalidTemplateToken();
            } else {
                throw err;
            }
        }
        this.inTemplateElement = false;
    };
    pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
            throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
            this.raise(position, message);
        }
    };
    pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for(;;){
            if (this.pos >= this.input.length) {
                this.raise(this.start, "Unterminated template");
            }
            var ch = this.input.charCodeAt(this.pos);
            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
                if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
                    if (ch === 36) {
                        this.pos += 2;
                        return this.finishToken(types$1.dollarBraceL);
                    } else {
                        ++this.pos;
                        return this.finishToken(types$1.backQuote);
                    }
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(types$1.template, out);
            }
            if (ch === 92) {
                out += this.input.slice(chunkStart, this.pos);
                out += this.readEscapedChar(true);
                chunkStart = this.pos;
            } else if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.pos);
                ++this.pos;
                switch(ch){
                    case 13:
                        if (this.input.charCodeAt(this.pos) === 10) {
                            ++this.pos;
                        }
                    case 10:
                        out += "\n";
                        break;
                    default:
                        out += String.fromCharCode(ch);
                        break;
                }
                if (this.options.locations) {
                    ++this.curLine;
                    this.lineStart = this.pos;
                }
                chunkStart = this.pos;
            } else {
                ++this.pos;
            }
        }
    };
    // Reads a template token to search for the end, without validating any escape sequences
    pp.readInvalidTemplateToken = function() {
        for(; this.pos < this.input.length; this.pos++){
            switch(this.input[this.pos]){
                case "\\":
                    ++this.pos;
                    break;
                case "$":
                    if (this.input[this.pos + 1] !== "{") {
                        break;
                    }
                // fall through
                case "`":
                    return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
                case "\r":
                    if (this.input[this.pos + 1] === "\n") {
                        ++this.pos;
                    }
                // fall through
                case "\n":
                case "\u2028":
                case "\u2029":
                    ++this.curLine;
                    this.lineStart = this.pos + 1;
                    break;
            }
        }
        this.raise(this.start, "Unterminated template");
    };
    // Used to read escaped characters
    pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch(ch){
            case 110:
                return "\n" // 'n' -> '\n'
                ;
            case 114:
                return "\r" // 'r' -> '\r'
                ;
            case 120:
                return String.fromCharCode(this.readHexChar(2)) // 'x'
                ;
            case 117:
                return codePointToString(this.readCodePoint()) // 'u'
                ;
            case 116:
                return "	" // 't' -> '\t'
                ;
            case 98:
                return "\b" // 'b' -> '\b'
                ;
            case 118:
                return "\v" // 'v' -> '\u000b'
                ;
            case 102:
                return "\f" // 'f' -> '\f'
                ;
            case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                    ++this.pos;
                } // '\r\n'
            case 10:
                if (this.options.locations) {
                    this.lineStart = this.pos;
                    ++this.curLine;
                }
                return "";
            case 56:
            case 57:
                if (this.strict) {
                    this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
                }
                if (inTemplate) {
                    var codePos = this.pos - 1;
                    this.invalidStringToken(codePos, "Invalid escape sequence in template string");
                }
            default:
                if (ch >= 48 && ch <= 55) {
                    var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
                    var octal = parseInt(octalStr, 8);
                    if (octal > 255) {
                        octalStr = octalStr.slice(0, -1);
                        octal = parseInt(octalStr, 8);
                    }
                    this.pos += octalStr.length - 1;
                    ch = this.input.charCodeAt(this.pos);
                    if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                        this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
                    }
                    return String.fromCharCode(octal);
                }
                if (isNewLine(ch)) {
                    // Unicode new line characters after \ get removed from output in both
                    // template literals and strings
                    if (this.options.locations) {
                        this.lineStart = this.pos;
                        ++this.curLine;
                    }
                    return "";
                }
                return String.fromCharCode(ch);
        }
    };
    // Used to read character escape sequences ('\x', '\u', '\U').
    pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
            this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
    };
    // Read an identifier, and return it as a string. Sets `this.containsEsc`
    // to whether the word contained a '\u' escape.
    //
    // Incrementally adds only escaped chars, adding other chunks as-is
    // as a micro-optimization.
    pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while(this.pos < this.input.length){
            var ch = this.fullCharCodeAtPos();
            if (isIdentifierChar(ch, astral)) {
                this.pos += ch <= 0xffff ? 1 : 2;
            } else if (ch === 92) {
                this.containsEsc = true;
                word += this.input.slice(chunkStart, this.pos);
                var escStart = this.pos;
                if (this.input.charCodeAt(++this.pos) !== 117) {
                    this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
                }
                ++this.pos;
                var esc = this.readCodePoint();
                if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
                    this.invalidStringToken(escStart, "Invalid Unicode escape");
                }
                word += codePointToString(esc);
                chunkStart = this.pos;
            } else {
                break;
            }
            first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
    };
    // Read an identifier or keyword token. Will check for reserved
    // words when necessary.
    pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
            type = keywords[word];
        }
        return this.finishToken(type, word);
    };
    // Acorn is a tiny, fast JavaScript parser written in JavaScript.
    //
    // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
    // various contributors and released under an MIT license.
    //
    // Git repositories for Acorn are available at
    //
    //     http://marijnhaverbeke.nl/git/acorn
    //     https://github.com/acornjs/acorn.git
    //
    // Please use the [github bug tracker][ghbt] to report issues.
    //
    // [ghbt]: https://github.com/acornjs/acorn/issues
    //
    // [walk]: util/walk.js
    var version = "8.14.1";
    Parser.acorn = {
        Parser: Parser,
        version: version,
        defaultOptions: defaultOptions,
        Position: Position,
        SourceLocation: SourceLocation,
        getLineInfo: getLineInfo,
        Node: Node,
        TokenType: TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext: TokContext,
        tokContexts: types,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        Token: Token,
        isNewLine: isNewLine,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace
    };
    // The main exported interface (under `self.acorn` when in the
    // browser) is a `parse` function that takes a code string and returns
    // an abstract syntax tree as specified by the [ESTree spec][estree].
    //
    // [estree]: https://github.com/estree/estree
    function parse(input, options) {
        return Parser.parse(input, options);
    }
    // This function tries to parse a single expression at a given
    // offset in a string. Useful for parsing mixed-language formats
    // that embed JavaScript expressions.
    function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
    }
    // Acorn is organized as a tokenizer and a recursive-descent parser.
    // The `tokenizer` export provides an interface to the tokenizer.
    function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
    }
    exports1.Node = Node;
    exports1.Parser = Parser;
    exports1.Position = Position;
    exports1.SourceLocation = SourceLocation;
    exports1.TokContext = TokContext;
    exports1.Token = Token;
    exports1.TokenType = TokenType;
    exports1.defaultOptions = defaultOptions;
    exports1.getLineInfo = getLineInfo;
    exports1.isIdentifierChar = isIdentifierChar;
    exports1.isIdentifierStart = isIdentifierStart;
    exports1.isNewLine = isNewLine;
    exports1.keywordTypes = keywords;
    exports1.lineBreak = lineBreak;
    exports1.lineBreakG = lineBreakG;
    exports1.nonASCIIwhitespace = nonASCIIwhitespace;
    exports1.parse = parse;
    exports1.parseExpressionAt = parseExpressionAt;
    exports1.tokContexts = types;
    exports1.tokTypes = types$1;
    exports1.tokenizer = tokenizer;
    exports1.version = version;
});


/***/ }),

/***/ 88933:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
    var Lexer, SourceMap, base64encode, compile, ext, fn1, formatSourcePosition, fs, getSourceMap, helpers, i, len, lexer, packageJson, parser, path, ref, sourceMaps, sources, vm, withPrettyErrors, hasProp = {}.hasOwnProperty;
    fs = __webpack_require__(57147);
    vm = __webpack_require__(26144);
    path = __webpack_require__(71017);
    Lexer = (__webpack_require__(78061).Lexer);
    parser = (__webpack_require__(52631).parser);
    helpers = __webpack_require__(18765);
    SourceMap = __webpack_require__(56313);
    packageJson = __webpack_require__(82682);
    exports.VERSION = packageJson.version;
    exports.FILE_EXTENSIONS = [
        ".coffee",
        ".litcoffee",
        ".coffee.md"
    ];
    exports.helpers = helpers;
    base64encode = function(src) {
        switch(false){
            case typeof Buffer !== "function":
                return new Buffer(src).toString("base64");
            case typeof btoa !== "function":
                return btoa(encodeURIComponent(src).replace(/%([0-9A-F]{2})/g, function(match, p1) {
                    return String.fromCharCode("0x" + p1);
                }));
            default:
                throw new Error("Unable to base64 encode inline sourcemap.");
        }
    };
    withPrettyErrors = function(fn) {
        return function(code, options) {
            var err;
            if (options == null) {
                options = {};
            }
            try {
                return fn.call(this, code, options);
            } catch (error) {
                err = error;
                if (typeof code !== "string") {
                    throw err;
                }
                throw helpers.updateSyntaxError(err, code, options.filename);
            }
        };
    };
    sources = {};
    sourceMaps = {};
    exports.compile = compile = withPrettyErrors(function(code, options) {
        var currentColumn, currentLine, encoded, extend, filename, fragment, fragments, generateSourceMap, header, i, j, js, len, len1, map, merge, newLines, ref, ref1, sourceMapDataURI, sourceURL, token, tokens, v3SourceMap;
        merge = helpers.merge, extend = helpers.extend;
        options = extend({}, options);
        generateSourceMap = options.sourceMap || options.inlineMap || options.filename == null;
        filename = options.filename || "<anonymous>";
        sources[filename] = code;
        if (generateSourceMap) {
            map = new SourceMap;
        }
        tokens = lexer.tokenize(code, options);
        options.referencedVars = function() {
            var i, len, results;
            results = [];
            for(i = 0, len = tokens.length; i < len; i++){
                token = tokens[i];
                if (token[0] === "IDENTIFIER") {
                    results.push(token[1]);
                }
            }
            return results;
        }();
        if (!(options.bare != null && options.bare === true)) {
            for(i = 0, len = tokens.length; i < len; i++){
                token = tokens[i];
                if ((ref = token[0]) === "IMPORT" || ref === "EXPORT") {
                    options.bare = true;
                    break;
                }
            }
        }
        fragments = parser.parse(tokens).compileToFragments(options);
        currentLine = 0;
        if (options.header) {
            currentLine += 1;
        }
        if (options.shiftLine) {
            currentLine += 1;
        }
        currentColumn = 0;
        js = "";
        for(j = 0, len1 = fragments.length; j < len1; j++){
            fragment = fragments[j];
            if (generateSourceMap) {
                if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
                    map.add([
                        fragment.locationData.first_line,
                        fragment.locationData.first_column
                    ], [
                        currentLine,
                        currentColumn
                    ], {
                        noReplace: true
                    });
                }
                newLines = helpers.count(fragment.code, "\n");
                currentLine += newLines;
                if (newLines) {
                    currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
                } else {
                    currentColumn += fragment.code.length;
                }
            }
            js += fragment.code;
        }
        if (options.header) {
            header = "Generated by CoffeeScript " + this.VERSION;
            js = "// " + header + "\n" + js;
        }
        if (generateSourceMap) {
            v3SourceMap = map.generate(options, code);
            sourceMaps[filename] = map;
        }
        if (options.inlineMap) {
            encoded = base64encode(JSON.stringify(v3SourceMap));
            sourceMapDataURI = "//# sourceMappingURL=data:application/json;base64," + encoded;
            sourceURL = "//# sourceURL=" + ((ref1 = options.filename) != null ? ref1 : "coffeescript");
            js = js + "\n" + sourceMapDataURI + "\n" + sourceURL;
        }
        if (options.sourceMap) {
            return {
                js: js,
                sourceMap: map,
                v3SourceMap: JSON.stringify(v3SourceMap, null, 2)
            };
        } else {
            return js;
        }
    });
    exports.tokens = withPrettyErrors(function(code, options) {
        return lexer.tokenize(code, options);
    });
    exports.nodes = withPrettyErrors(function(source, options) {
        if (typeof source === "string") {
            return parser.parse(lexer.tokenize(source, options));
        } else {
            return parser.parse(source);
        }
    });
    exports.run = function(code, options) {
        var answer, dir, mainModule, ref;
        if (options == null) {
            options = {};
        }
        mainModule = __webpack_require__.c[__webpack_require__.s];
        mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : "<anonymous>";
        mainModule.moduleCache && (mainModule.moduleCache = {});
        dir = options.filename != null ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync(".");
        mainModule.paths = (__webpack_require__(98188)._nodeModulePaths)(dir);
        if (!helpers.isCoffee(mainModule.filename) || (void 0)) {
            answer = compile(code, options);
            code = (ref = answer.js) != null ? ref : answer;
        }
        return mainModule._compile(code, mainModule.filename);
    };
    exports.eval = function(code, options) {
        var Module, _module, _require, createContext, i, isContext, js, k, len, o, r, ref, ref1, ref2, ref3, sandbox, v;
        if (options == null) {
            options = {};
        }
        if (!(code = code.trim())) {
            return;
        }
        createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;
        isContext = (ref1 = vm.isContext) != null ? ref1 : function(ctx) {
            return options.sandbox instanceof createContext().constructor;
        };
        if (createContext) {
            if (options.sandbox != null) {
                if (isContext(options.sandbox)) {
                    sandbox = options.sandbox;
                } else {
                    sandbox = createContext();
                    ref2 = options.sandbox;
                    for(k in ref2){
                        if (!hasProp.call(ref2, k)) continue;
                        v = ref2[k];
                        sandbox[k] = v;
                    }
                }
                sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
            } else {
                sandbox = global;
            }
            sandbox.__filename = options.filename || "eval";
            sandbox.__dirname = path.dirname(sandbox.__filename);
            if (!(sandbox !== global || sandbox.module || sandbox.require)) {
                Module = __webpack_require__(98188);
                sandbox.module = _module = new Module(options.modulename || "eval");
                sandbox.require = _require = function(path) {
                    return Module._load(path, _module, true);
                };
                _module.filename = sandbox.__filename;
                ref3 = Object.getOwnPropertyNames(__webpack_require__(36837));
                for(i = 0, len = ref3.length; i < len; i++){
                    r = ref3[i];
                    if (r !== "paths" && r !== "arguments" && r !== "caller") {
                        _require[r] = __webpack_require__(36837)[r];
                    }
                }
                _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
                _require.resolve = function(request) {
                    return Module._resolveFilename(request, _module);
                };
            }
        }
        o = {};
        for(k in options){
            if (!hasProp.call(options, k)) continue;
            v = options[k];
            o[k] = v;
        }
        o.bare = true;
        js = compile(code, o);
        if (sandbox === global) {
            return vm.runInThisContext(js);
        } else {
            return vm.runInContext(js, sandbox);
        }
    };
    exports.register = function() {
        return __webpack_require__(21957);
    };
    if ((void 0)) {
        ref = this.FILE_EXTENSIONS;
        fn1 = function(ext) {
            var base;
            return (base = (void 0))[ext] != null ? base[ext] : base[ext] = function() {
                throw new Error("Use CoffeeScript.register() or require the coffee-script/register module to require " + ext + " files.");
            };
        };
        for(i = 0, len = ref.length; i < len; i++){
            ext = ref[i];
            fn1(ext);
        }
    }
    exports._compileFile = function(filename, sourceMap, inlineMap) {
        var answer, err, raw, stripped;
        if (sourceMap == null) {
            sourceMap = false;
        }
        if (inlineMap == null) {
            inlineMap = false;
        }
        raw = fs.readFileSync(filename, "utf8");
        stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
        try {
            answer = compile(stripped, {
                filename: filename,
                sourceMap: sourceMap,
                inlineMap: inlineMap,
                sourceFiles: [
                    filename
                ],
                literate: helpers.isLiterate(filename)
            });
        } catch (error) {
            err = error;
            throw helpers.updateSyntaxError(err, stripped, filename);
        }
        return answer;
    };
    lexer = new Lexer;
    parser.lexer = {
        lex: function() {
            var tag, token;
            token = parser.tokens[this.pos++];
            if (token) {
                tag = token[0], this.yytext = token[1], this.yylloc = token[2];
                parser.errorToken = token.origin || token;
                this.yylineno = this.yylloc.first_line;
            } else {
                tag = "";
            }
            return tag;
        },
        setInput: function(tokens) {
            parser.tokens = tokens;
            return this.pos = 0;
        },
        upcomingInput: function() {
            return "";
        }
    };
    parser.yy = __webpack_require__(45987);
    parser.yy.parseError = function(message, arg) {
        var errorLoc, errorTag, errorText, errorToken, token, tokens;
        token = arg.token;
        errorToken = parser.errorToken, tokens = parser.tokens;
        errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];
        errorText = function() {
            switch(false){
                case errorToken !== tokens[tokens.length - 1]:
                    return "end of input";
                case errorTag !== "INDENT" && errorTag !== "OUTDENT":
                    return "indentation";
                case errorTag !== "IDENTIFIER" && errorTag !== "NUMBER" && errorTag !== "INFINITY" && errorTag !== "STRING" && errorTag !== "STRING_START" && errorTag !== "REGEX" && errorTag !== "REGEX_START":
                    return errorTag.replace(/_START$/, "").toLowerCase();
                default:
                    return helpers.nameWhitespaceCharacter(errorText);
            }
        }();
        return helpers.throwSyntaxError("unexpected " + errorText, errorLoc);
    };
    formatSourcePosition = function(frame, getSourceMapping) {
        var as, column, fileLocation, filename, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
        filename = void 0;
        fileLocation = "";
        if (frame.isNative()) {
            fileLocation = "native";
        } else {
            if (frame.isEval()) {
                filename = frame.getScriptNameOrSourceURL();
                if (!filename) {
                    fileLocation = frame.getEvalOrigin() + ", ";
                }
            } else {
                filename = frame.getFileName();
            }
            filename || (filename = "<anonymous>");
            line = frame.getLineNumber();
            column = frame.getColumnNumber();
            source = getSourceMapping(filename, line, column);
            fileLocation = source ? filename + ":" + source[0] + ":" + source[1] : filename + ":" + line + ":" + column;
        }
        functionName = frame.getFunctionName();
        isConstructor = frame.isConstructor();
        isMethodCall = !(frame.isToplevel() || isConstructor);
        if (isMethodCall) {
            methodName = frame.getMethodName();
            typeName = frame.getTypeName();
            if (functionName) {
                tp = as = "";
                if (typeName && functionName.indexOf(typeName)) {
                    tp = typeName + ".";
                }
                if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
                    as = " [as " + methodName + "]";
                }
                return "" + tp + functionName + as + " (" + fileLocation + ")";
            } else {
                return typeName + "." + (methodName || "<anonymous>") + " (" + fileLocation + ")";
            }
        } else if (isConstructor) {
            return "new " + (functionName || "<anonymous>") + " (" + fileLocation + ")";
        } else if (functionName) {
            return functionName + " (" + fileLocation + ")";
        } else {
            return fileLocation;
        }
    };
    getSourceMap = function(filename) {
        var answer;
        if (sourceMaps[filename] != null) {
            return sourceMaps[filename];
        } else if (sourceMaps["<anonymous>"] != null) {
            return sourceMaps["<anonymous>"];
        } else if (sources[filename] != null) {
            answer = compile(sources[filename], {
                filename: filename,
                sourceMap: true,
                literate: helpers.isLiterate(filename)
            });
            return answer.sourceMap;
        } else {
            return null;
        }
    };
    Error.prepareStackTrace = function(err, stack) {
        var frame, frames, getSourceMapping;
        getSourceMapping = function(filename, line, column) {
            var answer, sourceMap;
            sourceMap = getSourceMap(filename);
            if (sourceMap != null) {
                answer = sourceMap.sourceLocation([
                    line - 1,
                    column - 1
                ]);
            }
            if (answer != null) {
                return [
                    answer[0] + 1,
                    answer[1] + 1
                ];
            } else {
                return null;
            }
        };
        frames = function() {
            var j, len1, results;
            results = [];
            for(j = 0, len1 = stack.length; j < len1; j++){
                frame = stack[j];
                if (frame.getFunction() === exports.run) {
                    break;
                }
                results.push("    at " + formatSourcePosition(frame, getSourceMapping));
            }
            return results;
        }();
        return err.toString() + "\n" + frames.join("\n") + "\n";
    };
}).call(this);


/***/ }),

/***/ 18765:
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
    var buildLocationData, extend, flatten, ref, repeat, syntaxErrorToString;
    exports.starts = function(string, literal, start) {
        return literal === string.substr(start, literal.length);
    };
    exports.ends = function(string, literal, back) {
        var len;
        len = literal.length;
        return literal === string.substr(string.length - len - (back || 0), len);
    };
    exports.repeat = repeat = function(str, n) {
        var res;
        res = "";
        while(n > 0){
            if (n & 1) {
                res += str;
            }
            n >>>= 1;
            str += str;
        }
        return res;
    };
    exports.compact = function(array) {
        var i, item, len1, results;
        results = [];
        for(i = 0, len1 = array.length; i < len1; i++){
            item = array[i];
            if (item) {
                results.push(item);
            }
        }
        return results;
    };
    exports.count = function(string, substr) {
        var num, pos;
        num = pos = 0;
        if (!substr.length) {
            return 1 / 0;
        }
        while(pos = 1 + string.indexOf(substr, pos)){
            num++;
        }
        return num;
    };
    exports.merge = function(options, overrides) {
        return extend(extend({}, options), overrides);
    };
    extend = exports.extend = function(object, properties) {
        var key, val;
        for(key in properties){
            val = properties[key];
            object[key] = val;
        }
        return object;
    };
    exports.flatten = flatten = function(array) {
        var element, flattened, i, len1;
        flattened = [];
        for(i = 0, len1 = array.length; i < len1; i++){
            element = array[i];
            if ("[object Array]" === Object.prototype.toString.call(element)) {
                flattened = flattened.concat(flatten(element));
            } else {
                flattened.push(element);
            }
        }
        return flattened;
    };
    exports.del = function(obj, key) {
        var val;
        val = obj[key];
        delete obj[key];
        return val;
    };
    exports.some = (ref = Array.prototype.some) != null ? ref : function(fn) {
        var e, i, len1, ref1;
        ref1 = this;
        for(i = 0, len1 = ref1.length; i < len1; i++){
            e = ref1[i];
            if (fn(e)) {
                return true;
            }
        }
        return false;
    };
    exports.invertLiterate = function(code) {
        var line, lines, maybe_code;
        maybe_code = true;
        lines = function() {
            var i, len1, ref1, results;
            ref1 = code.split("\n");
            results = [];
            for(i = 0, len1 = ref1.length; i < len1; i++){
                line = ref1[i];
                if (maybe_code && /^([ ]{4}|[ ]{0,3}\t)/.test(line)) {
                    results.push(line);
                } else if (maybe_code = /^\s*$/.test(line)) {
                    results.push(line);
                } else {
                    results.push("# " + line);
                }
            }
            return results;
        }();
        return lines.join("\n");
    };
    buildLocationData = function(first, last) {
        if (!last) {
            return first;
        } else {
            return {
                first_line: first.first_line,
                first_column: first.first_column,
                last_line: last.last_line,
                last_column: last.last_column
            };
        }
    };
    exports.addLocationDataFn = function(first, last) {
        return function(obj) {
            if (typeof obj === "object" && !!obj["updateLocationDataIfMissing"]) {
                obj.updateLocationDataIfMissing(buildLocationData(first, last));
            }
            return obj;
        };
    };
    exports.locationDataToString = function(obj) {
        var locationData;
        if ("2" in obj && "first_line" in obj[2]) {
            locationData = obj[2];
        } else if ("first_line" in obj) {
            locationData = obj;
        }
        if (locationData) {
            return locationData.first_line + 1 + ":" + (locationData.first_column + 1) + "-" + (locationData.last_line + 1 + ":" + (locationData.last_column + 1));
        } else {
            return "No location data";
        }
    };
    exports.baseFileName = function(file, stripExt, useWinPathSep) {
        var parts, pathSep;
        if (stripExt == null) {
            stripExt = false;
        }
        if (useWinPathSep == null) {
            useWinPathSep = false;
        }
        pathSep = useWinPathSep ? /\\|\// : /\//;
        parts = file.split(pathSep);
        file = parts[parts.length - 1];
        if (!(stripExt && file.indexOf(".") >= 0)) {
            return file;
        }
        parts = file.split(".");
        parts.pop();
        if (parts[parts.length - 1] === "coffee" && parts.length > 1) {
            parts.pop();
        }
        return parts.join(".");
    };
    exports.isCoffee = function(file) {
        return /\.((lit)?coffee|coffee\.md)$/.test(file);
    };
    exports.isLiterate = function(file) {
        return /\.(litcoffee|coffee\.md)$/.test(file);
    };
    exports.throwSyntaxError = function(message, location) {
        var error;
        error = new SyntaxError(message);
        error.location = location;
        error.toString = syntaxErrorToString;
        error.stack = error.toString();
        throw error;
    };
    exports.updateSyntaxError = function(error, code, filename) {
        if (error.toString === syntaxErrorToString) {
            error.code || (error.code = code);
            error.filename || (error.filename = filename);
            error.stack = error.toString();
        }
        return error;
    };
    syntaxErrorToString = function() {
        var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, ref4, start;
        if (!(this.code && this.location)) {
            return Error.prototype.toString.call(this);
        }
        ref1 = this.location, first_line = ref1.first_line, first_column = ref1.first_column, last_line = ref1.last_line, last_column = ref1.last_column;
        if (last_line == null) {
            last_line = first_line;
        }
        if (last_column == null) {
            last_column = first_column;
        }
        filename = this.filename || "[stdin]";
        codeLine = this.code.split("\n")[first_line];
        start = first_column;
        end = first_line === last_line ? last_column + 1 : codeLine.length;
        marker = codeLine.slice(0, start).replace(/[^\s]/g, " ") + repeat("^", end - start);
        if (typeof process !== "undefined" && process !== null) {
            colorsEnabled = ((ref2 = process.stdout) != null ? ref2.isTTY : void 0) && !((ref3 = process.env) != null ? ref3.NODE_DISABLE_COLORS : void 0);
        }
        if ((ref4 = this.colorful) != null ? ref4 : colorsEnabled) {
            colorize = function(str) {
                return "\x1b[1;31m" + str + "\x1b[0m";
            };
            codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
            marker = colorize(marker);
        }
        return filename + ":" + (first_line + 1) + ":" + (first_column + 1) + ": error: " + this.message + "\n" + codeLine + "\n" + marker;
    };
    exports.nameWhitespaceCharacter = function(string) {
        switch(string){
            case " ":
                return "space";
            case "\n":
                return "newline";
            case "\r":
                return "carriage return";
            case "	":
                return "tab";
            default:
                return string;
        }
    };
}).call(this);


/***/ }),

/***/ 78061:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
    var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_OMIT, HERE_JSTOKEN, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVERSES, JSTOKEN, JS_KEYWORDS, LEADING_BLANK_LINE, LINE_BREAK, LINE_CONTINUER, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, REGEX_INVALID_ESCAPE, RELATION, RESERVED, Rewriter, SHIFT, SIMPLE_STRING_OMIT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_INVALID_ESCAPE, STRING_OMIT, STRING_SINGLE, STRING_START, TRAILING_BLANK_LINE, TRAILING_SPACES, UNARY, UNARY_MATH, UNFINISHED, UNICODE_CODE_POINT_ESCAPE, VALID_FLAGS, WHITESPACE, compact, count, invertLiterate, isForFrom, isUnassignable, key, locationDataToString, ref, ref1, repeat, starts, throwSyntaxError, indexOf = [].indexOf || function(item) {
        for(var i = 0, l = this.length; i < l; i++){
            if (i in this && this[i] === item) return i;
        }
        return -1;
    }, slice = [].slice;
    ref = __webpack_require__(56106), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;
    ref1 = __webpack_require__(18765), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;
    exports.Lexer = Lexer = function() {
        function Lexer() {}
        Lexer.prototype.tokenize = function(code, opts) {
            var consumed, end, i, ref2;
            if (opts == null) {
                opts = {};
            }
            this.literate = opts.literate;
            this.indent = 0;
            this.baseIndent = 0;
            this.indebt = 0;
            this.outdebt = 0;
            this.indents = [];
            this.ends = [];
            this.tokens = [];
            this.seenFor = false;
            this.seenImport = false;
            this.seenExport = false;
            this.importSpecifierList = false;
            this.exportSpecifierList = false;
            this.chunkLine = opts.line || 0;
            this.chunkColumn = opts.column || 0;
            code = this.clean(code);
            i = 0;
            while(this.chunk = code.slice(i)){
                consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
                ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];
                i += consumed;
                if (opts.untilBalanced && this.ends.length === 0) {
                    return {
                        tokens: this.tokens,
                        index: i
                    };
                }
            }
            this.closeIndentation();
            if (end = this.ends.pop()) {
                this.error("missing " + end.tag, end.origin[2]);
            }
            if (opts.rewrite === false) {
                return this.tokens;
            }
            return (new Rewriter).rewrite(this.tokens);
        };
        Lexer.prototype.clean = function(code) {
            if (code.charCodeAt(0) === BOM) {
                code = code.slice(1);
            }
            code = code.replace(/\r/g, "").replace(TRAILING_SPACES, "");
            if (WHITESPACE.test(code)) {
                code = "\n" + code;
                this.chunkLine--;
            }
            if (this.literate) {
                code = invertLiterate(code);
            }
            return code;
        };
        Lexer.prototype.identifierToken = function() {
            var alias, colon, colonOffset, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tag, tagToken;
            if (!(match = IDENTIFIER.exec(this.chunk))) {
                return 0;
            }
            input = match[0], id = match[1], colon = match[2];
            idLength = id.length;
            poppedToken = void 0;
            if (id === "own" && this.tag() === "FOR") {
                this.token("OWN", id);
                return id.length;
            }
            if (id === "from" && this.tag() === "YIELD") {
                this.token("FROM", id);
                return id.length;
            }
            if (id === "as" && this.seenImport) {
                if (this.value() === "*") {
                    this.tokens[this.tokens.length - 1][0] = "IMPORT_ALL";
                } else if (ref2 = this.value(), indexOf.call(COFFEE_KEYWORDS, ref2) >= 0) {
                    this.tokens[this.tokens.length - 1][0] = "IDENTIFIER";
                }
                if ((ref3 = this.tag()) === "DEFAULT" || ref3 === "IMPORT_ALL" || ref3 === "IDENTIFIER") {
                    this.token("AS", id);
                    return id.length;
                }
            }
            if (id === "as" && this.seenExport && ((ref4 = this.tag()) === "IDENTIFIER" || ref4 === "DEFAULT")) {
                this.token("AS", id);
                return id.length;
            }
            if (id === "default" && this.seenExport && ((ref5 = this.tag()) === "EXPORT" || ref5 === "AS")) {
                this.token("DEFAULT", id);
                return id.length;
            }
            ref6 = this.tokens, prev = ref6[ref6.length - 1];
            tag = colon || prev != null && ((ref7 = prev[0]) === "." || ref7 === "?." || ref7 === "::" || ref7 === "?::" || !prev.spaced && prev[0] === "@") ? "PROPERTY" : "IDENTIFIER";
            if (tag === "IDENTIFIER" && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0) && !(this.exportSpecifierList && indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {
                tag = id.toUpperCase();
                if (tag === "WHEN" && (ref8 = this.tag(), indexOf.call(LINE_BREAK, ref8) >= 0)) {
                    tag = "LEADING_WHEN";
                } else if (tag === "FOR") {
                    this.seenFor = true;
                } else if (tag === "UNLESS") {
                    tag = "IF";
                } else if (tag === "IMPORT") {
                    this.seenImport = true;
                } else if (tag === "EXPORT") {
                    this.seenExport = true;
                } else if (indexOf.call(UNARY, tag) >= 0) {
                    tag = "UNARY";
                } else if (indexOf.call(RELATION, tag) >= 0) {
                    if (tag !== "INSTANCEOF" && this.seenFor) {
                        tag = "FOR" + tag;
                        this.seenFor = false;
                    } else {
                        tag = "RELATION";
                        if (this.value() === "!") {
                            poppedToken = this.tokens.pop();
                            id = "!" + id;
                        }
                    }
                }
            } else if (tag === "IDENTIFIER" && this.seenFor && id === "from" && isForFrom(prev)) {
                tag = "FORFROM";
                this.seenFor = false;
            }
            if (tag === "IDENTIFIER" && indexOf.call(RESERVED, id) >= 0) {
                this.error("reserved word '" + id + "'", {
                    length: id.length
                });
            }
            if (tag !== "PROPERTY") {
                if (indexOf.call(COFFEE_ALIASES, id) >= 0) {
                    alias = id;
                    id = COFFEE_ALIAS_MAP[id];
                }
                tag = function() {
                    switch(id){
                        case "!":
                            return "UNARY";
                        case "==":
                        case "!=":
                            return "COMPARE";
                        case "true":
                        case "false":
                            return "BOOL";
                        case "break":
                        case "continue":
                        case "debugger":
                            return "STATEMENT";
                        case "&&":
                        case "||":
                            return id;
                        default:
                            return tag;
                    }
                }();
            }
            tagToken = this.token(tag, id, 0, idLength);
            if (alias) {
                tagToken.origin = [
                    tag,
                    alias,
                    tagToken[2]
                ];
            }
            if (poppedToken) {
                ref9 = [
                    poppedToken[2].first_line,
                    poppedToken[2].first_column
                ], tagToken[2].first_line = ref9[0], tagToken[2].first_column = ref9[1];
            }
            if (colon) {
                colonOffset = input.lastIndexOf(":");
                this.token(":", ":", colonOffset, colon.length);
            }
            return input.length;
        };
        Lexer.prototype.numberToken = function() {
            var base, lexedLength, match, number, numberValue, ref2, tag;
            if (!(match = NUMBER.exec(this.chunk))) {
                return 0;
            }
            number = match[0];
            lexedLength = number.length;
            switch(false){
                case !/^0[BOX]/.test(number):
                    this.error("radix prefix in '" + number + "' must be lowercase", {
                        offset: 1
                    });
                    break;
                case !/^(?!0x).*E/.test(number):
                    this.error("exponential notation in '" + number + "' must be indicated with a lowercase 'e'", {
                        offset: number.indexOf("E")
                    });
                    break;
                case !/^0\d*[89]/.test(number):
                    this.error("decimal literal '" + number + "' must not be prefixed with '0'", {
                        length: lexedLength
                    });
                    break;
                case !/^0\d+/.test(number):
                    this.error("octal literal '" + number + "' must be prefixed with '0o'", {
                        length: lexedLength
                    });
            }
            base = function() {
                switch(number.charAt(1)){
                    case "b":
                        return 2;
                    case "o":
                        return 8;
                    case "x":
                        return 16;
                    default:
                        return null;
                }
            }();
            numberValue = base != null ? parseInt(number.slice(2), base) : parseFloat(number);
            if ((ref2 = number.charAt(1)) === "b" || ref2 === "o") {
                number = "0x" + numberValue.toString(16);
            }
            tag = numberValue === Infinity ? "INFINITY" : "NUMBER";
            this.token(tag, number, 0, lexedLength);
            return lexedLength;
        };
        Lexer.prototype.stringToken = function() {
            var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;
            quote = (STRING_START.exec(this.chunk) || [])[0];
            if (!quote) {
                return 0;
            }
            if (this.tokens.length && this.value() === "from" && (this.seenImport || this.seenExport)) {
                this.tokens[this.tokens.length - 1][0] = "FROM";
            }
            regex = function() {
                switch(quote){
                    case "'":
                        return STRING_SINGLE;
                    case '"':
                        return STRING_DOUBLE;
                    case "'''":
                        return HEREDOC_SINGLE;
                    case '"""':
                        return HEREDOC_DOUBLE;
                }
            }();
            heredoc = quote.length === 3;
            ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;
            $ = tokens.length - 1;
            delimiter = quote.charAt(0);
            if (heredoc) {
                indent = null;
                doc = (function() {
                    var j, len, results;
                    results = [];
                    for(i = j = 0, len = tokens.length; j < len; i = ++j){
                        token = tokens[i];
                        if (token[0] === "NEOSTRING") {
                            results.push(token[1]);
                        }
                    }
                    return results;
                })().join("#{}");
                while(match = HEREDOC_INDENT.exec(doc)){
                    attempt = match[1];
                    if (indent === null || 0 < (ref3 = attempt.length) && ref3 < indent.length) {
                        indent = attempt;
                    }
                }
                if (indent) {
                    indentRegex = RegExp("\\n" + indent, "g");
                }
                this.mergeInterpolationTokens(tokens, {
                    delimiter: delimiter
                }, function(_this) {
                    return function(value, i) {
                        value = _this.formatString(value, {
                            delimiter: quote
                        });
                        if (indentRegex) {
                            value = value.replace(indentRegex, "\n");
                        }
                        if (i === 0) {
                            value = value.replace(LEADING_BLANK_LINE, "");
                        }
                        if (i === $) {
                            value = value.replace(TRAILING_BLANK_LINE, "");
                        }
                        return value;
                    };
                }(this));
            } else {
                this.mergeInterpolationTokens(tokens, {
                    delimiter: delimiter
                }, function(_this) {
                    return function(value, i) {
                        value = _this.formatString(value, {
                            delimiter: quote
                        });
                        value = value.replace(SIMPLE_STRING_OMIT, function(match, offset) {
                            if (i === 0 && offset === 0 || i === $ && offset + match.length === value.length) {
                                return "";
                            } else {
                                return " ";
                            }
                        });
                        return value;
                    };
                }(this));
            }
            return end;
        };
        Lexer.prototype.commentToken = function() {
            var comment, here, match;
            if (!(match = this.chunk.match(COMMENT))) {
                return 0;
            }
            comment = match[0], here = match[1];
            if (here) {
                if (match = HERECOMMENT_ILLEGAL.exec(comment)) {
                    this.error("block comments cannot contain " + match[0], {
                        offset: match.index,
                        length: match[0].length
                    });
                }
                if (here.indexOf("\n") >= 0) {
                    here = here.replace(RegExp("\\n" + repeat(" ", this.indent), "g"), "\n");
                }
                this.token("HERECOMMENT", here, 0, comment.length);
            }
            return comment.length;
        };
        Lexer.prototype.jsToken = function() {
            var match, script;
            if (!(this.chunk.charAt(0) === "`" && (match = HERE_JSTOKEN.exec(this.chunk) || JSTOKEN.exec(this.chunk)))) {
                return 0;
            }
            script = match[1].replace(/\\+(`|$)/g, function(string) {
                return string.slice(-Math.ceil(string.length / 2));
            });
            this.token("JS", script, 0, match[0].length);
            return match[0].length;
        };
        Lexer.prototype.regexToken = function() {
            var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;
            switch(false){
                case !(match = REGEX_ILLEGAL.exec(this.chunk)):
                    this.error("regular expressions cannot begin with " + match[2], {
                        offset: match.index + match[1].length
                    });
                    break;
                case !(match = this.matchWithInterpolations(HEREGEX, "///")):
                    tokens = match.tokens, index = match.index;
                    break;
                case !(match = REGEX.exec(this.chunk)):
                    regex = match[0], body = match[1], closed = match[2];
                    this.validateEscapes(body, {
                        isRegex: true,
                        offsetInChunk: 1
                    });
                    body = this.formatRegex(body, {
                        delimiter: "/"
                    });
                    index = regex.length;
                    ref2 = this.tokens, prev = ref2[ref2.length - 1];
                    if (prev) {
                        if (prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) {
                            if (!closed || POSSIBLY_DIVISION.test(regex)) {
                                return 0;
                            }
                        } else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) >= 0) {
                            return 0;
                        }
                    }
                    if (!closed) {
                        this.error("missing / (unclosed regex)");
                    }
                    break;
                default:
                    return 0;
            }
            flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];
            end = index + flags.length;
            origin = this.makeToken("REGEX", null, 0, end);
            switch(false){
                case !!VALID_FLAGS.test(flags):
                    this.error("invalid regular expression flags " + flags, {
                        offset: index,
                        length: flags.length
                    });
                    break;
                case !(regex || tokens.length === 1):
                    if (body == null) {
                        body = this.formatHeregex(tokens[0][1]);
                    }
                    this.token("REGEX", "" + this.makeDelimitedLiteral(body, {
                        delimiter: "/"
                    }) + flags, 0, end, origin);
                    break;
                default:
                    this.token("REGEX_START", "(", 0, 0, origin);
                    this.token("IDENTIFIER", "RegExp", 0, 0);
                    this.token("CALL_START", "(", 0, 0);
                    this.mergeInterpolationTokens(tokens, {
                        delimiter: '"',
                        double: true
                    }, this.formatHeregex);
                    if (flags) {
                        this.token(",", ",", index - 1, 0);
                        this.token("STRING", '"' + flags + '"', index - 1, flags.length);
                    }
                    this.token(")", ")", end - 1, 0);
                    this.token("REGEX_END", ")", end - 1, 0);
            }
            return end;
        };
        Lexer.prototype.lineToken = function() {
            var diff, indent, match, noNewlines, size;
            if (!(match = MULTI_DENT.exec(this.chunk))) {
                return 0;
            }
            indent = match[0];
            this.seenFor = false;
            if (!this.importSpecifierList) {
                this.seenImport = false;
            }
            if (!this.exportSpecifierList) {
                this.seenExport = false;
            }
            size = indent.length - 1 - indent.lastIndexOf("\n");
            noNewlines = this.unfinished();
            if (size - this.indebt === this.indent) {
                if (noNewlines) {
                    this.suppressNewlines();
                } else {
                    this.newlineToken(0);
                }
                return indent.length;
            }
            if (size > this.indent) {
                if (noNewlines) {
                    this.indebt = size - this.indent;
                    this.suppressNewlines();
                    return indent.length;
                }
                if (!this.tokens.length) {
                    this.baseIndent = this.indent = size;
                    return indent.length;
                }
                diff = size - this.indent + this.outdebt;
                this.token("INDENT", diff, indent.length - size, size);
                this.indents.push(diff);
                this.ends.push({
                    tag: "OUTDENT"
                });
                this.outdebt = this.indebt = 0;
                this.indent = size;
            } else if (size < this.baseIndent) {
                this.error("missing indentation", {
                    offset: indent.length
                });
            } else {
                this.indebt = 0;
                this.outdentToken(this.indent - size, noNewlines, indent.length);
            }
            return indent.length;
        };
        Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) {
            var decreasedIndent, dent, lastIndent, ref2;
            decreasedIndent = this.indent - moveOut;
            while(moveOut > 0){
                lastIndent = this.indents[this.indents.length - 1];
                if (!lastIndent) {
                    moveOut = 0;
                } else if (lastIndent === this.outdebt) {
                    moveOut -= this.outdebt;
                    this.outdebt = 0;
                } else if (lastIndent < this.outdebt) {
                    this.outdebt -= lastIndent;
                    moveOut -= lastIndent;
                } else {
                    dent = this.indents.pop() + this.outdebt;
                    if (outdentLength && (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) >= 0)) {
                        decreasedIndent -= dent - moveOut;
                        moveOut = dent;
                    }
                    this.outdebt = 0;
                    this.pair("OUTDENT");
                    this.token("OUTDENT", moveOut, 0, outdentLength);
                    moveOut -= dent;
                }
            }
            if (dent) {
                this.outdebt -= moveOut;
            }
            while(this.value() === ";"){
                this.tokens.pop();
            }
            if (!(this.tag() === "TERMINATOR" || noNewlines)) {
                this.token("TERMINATOR", "\n", outdentLength, 0);
            }
            this.indent = decreasedIndent;
            return this;
        };
        Lexer.prototype.whitespaceToken = function() {
            var match, nline, prev, ref2;
            if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === "\n"))) {
                return 0;
            }
            ref2 = this.tokens, prev = ref2[ref2.length - 1];
            if (prev) {
                prev[match ? "spaced" : "newLine"] = true;
            }
            if (match) {
                return match[0].length;
            } else {
                return 0;
            }
        };
        Lexer.prototype.newlineToken = function(offset) {
            while(this.value() === ";"){
                this.tokens.pop();
            }
            if (this.tag() !== "TERMINATOR") {
                this.token("TERMINATOR", "\n", offset, 0);
            }
            return this;
        };
        Lexer.prototype.suppressNewlines = function() {
            if (this.value() === "\\") {
                this.tokens.pop();
            }
            return this;
        };
        Lexer.prototype.literalToken = function() {
            var match, message, origin, prev, ref2, ref3, ref4, ref5, ref6, skipToken, tag, token, value;
            if (match = OPERATOR.exec(this.chunk)) {
                value = match[0];
                if (CODE.test(value)) {
                    this.tagParameters();
                }
            } else {
                value = this.chunk.charAt(0);
            }
            tag = value;
            ref2 = this.tokens, prev = ref2[ref2.length - 1];
            if (prev && indexOf.call([
                "="
            ].concat(slice.call(COMPOUND_ASSIGN)), value) >= 0) {
                skipToken = false;
                if (value === "=" && ((ref3 = prev[1]) === "||" || ref3 === "&&") && !prev.spaced) {
                    prev[0] = "COMPOUND_ASSIGN";
                    prev[1] += "=";
                    prev = this.tokens[this.tokens.length - 2];
                    skipToken = true;
                }
                if (prev && prev[0] !== "PROPERTY") {
                    origin = (ref4 = prev.origin) != null ? ref4 : prev;
                    message = isUnassignable(prev[1], origin[1]);
                    if (message) {
                        this.error(message, origin[2]);
                    }
                }
                if (skipToken) {
                    return value.length;
                }
            }
            if (value === "{" && this.seenImport) {
                this.importSpecifierList = true;
            } else if (this.importSpecifierList && value === "}") {
                this.importSpecifierList = false;
            } else if (value === "{" && (prev != null ? prev[0] : void 0) === "EXPORT") {
                this.exportSpecifierList = true;
            } else if (this.exportSpecifierList && value === "}") {
                this.exportSpecifierList = false;
            }
            if (value === ";") {
                this.seenFor = this.seenImport = this.seenExport = false;
                tag = "TERMINATOR";
            } else if (value === "*" && prev[0] === "EXPORT") {
                tag = "EXPORT_ALL";
            } else if (indexOf.call(MATH, value) >= 0) {
                tag = "MATH";
            } else if (indexOf.call(COMPARE, value) >= 0) {
                tag = "COMPARE";
            } else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
                tag = "COMPOUND_ASSIGN";
            } else if (indexOf.call(UNARY, value) >= 0) {
                tag = "UNARY";
            } else if (indexOf.call(UNARY_MATH, value) >= 0) {
                tag = "UNARY_MATH";
            } else if (indexOf.call(SHIFT, value) >= 0) {
                tag = "SHIFT";
            } else if (value === "?" && (prev != null ? prev.spaced : void 0)) {
                tag = "BIN?";
            } else if (prev && !prev.spaced) {
                if (value === "(" && (ref5 = prev[0], indexOf.call(CALLABLE, ref5) >= 0)) {
                    if (prev[0] === "?") {
                        prev[0] = "FUNC_EXIST";
                    }
                    tag = "CALL_START";
                } else if (value === "[" && (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) >= 0)) {
                    tag = "INDEX_START";
                    switch(prev[0]){
                        case "?":
                            prev[0] = "INDEX_SOAK";
                    }
                }
            }
            token = this.makeToken(tag, value);
            switch(value){
                case "(":
                case "{":
                case "[":
                    this.ends.push({
                        tag: INVERSES[value],
                        origin: token
                    });
                    break;
                case ")":
                case "}":
                case "]":
                    this.pair(value);
            }
            this.tokens.push(token);
            return value.length;
        };
        Lexer.prototype.tagParameters = function() {
            var i, stack, tok, tokens;
            if (this.tag() !== ")") {
                return this;
            }
            stack = [];
            tokens = this.tokens;
            i = tokens.length;
            tokens[--i][0] = "PARAM_END";
            while(tok = tokens[--i]){
                switch(tok[0]){
                    case ")":
                        stack.push(tok);
                        break;
                    case "(":
                    case "CALL_START":
                        if (stack.length) {
                            stack.pop();
                        } else if (tok[0] === "(") {
                            tok[0] = "PARAM_START";
                            return this;
                        } else {
                            return this;
                        }
                }
            }
            return this;
        };
        Lexer.prototype.closeIndentation = function() {
            return this.outdentToken(this.indent);
        };
        Lexer.prototype.matchWithInterpolations = function(regex, delimiter) {
            var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;
            tokens = [];
            offsetInChunk = delimiter.length;
            if (this.chunk.slice(0, offsetInChunk) !== delimiter) {
                return null;
            }
            str = this.chunk.slice(offsetInChunk);
            while(true){
                strPart = regex.exec(str)[0];
                this.validateEscapes(strPart, {
                    isRegex: delimiter.charAt(0) === "/",
                    offsetInChunk: offsetInChunk
                });
                tokens.push(this.makeToken("NEOSTRING", strPart, offsetInChunk));
                str = str.slice(strPart.length);
                offsetInChunk += strPart.length;
                if (str.slice(0, 2) !== "#{") {
                    break;
                }
                ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];
                ref3 = new Lexer().tokenize(str.slice(1), {
                    line: line,
                    column: column,
                    untilBalanced: true
                }), nested = ref3.tokens, index = ref3.index;
                index += 1;
                open = nested[0], close = nested[nested.length - 1];
                open[0] = open[1] = "(";
                close[0] = close[1] = ")";
                close.origin = [
                    "",
                    "end of interpolation",
                    close[2]
                ];
                if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === "TERMINATOR") {
                    nested.splice(1, 1);
                }
                tokens.push([
                    "TOKENS",
                    nested
                ]);
                str = str.slice(index);
                offsetInChunk += index;
            }
            if (str.slice(0, delimiter.length) !== delimiter) {
                this.error("missing " + delimiter, {
                    length: delimiter.length
                });
            }
            firstToken = tokens[0], lastToken = tokens[tokens.length - 1];
            firstToken[2].first_column -= delimiter.length;
            if (lastToken[1].substr(-1) === "\n") {
                lastToken[2].last_line += 1;
                lastToken[2].last_column = delimiter.length - 1;
            } else {
                lastToken[2].last_column += delimiter.length;
            }
            if (lastToken[1].length === 0) {
                lastToken[2].last_column -= 1;
            }
            return {
                tokens: tokens,
                index: offsetInChunk + delimiter.length
            };
        };
        Lexer.prototype.mergeInterpolationTokens = function(tokens, options, fn) {
            var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;
            if (tokens.length > 1) {
                lparen = this.token("STRING_START", "(", 0, 0);
            }
            firstIndex = this.tokens.length;
            for(i = j = 0, len = tokens.length; j < len; i = ++j){
                token = tokens[i];
                tag = token[0], value = token[1];
                switch(tag){
                    case "TOKENS":
                        if (value.length === 2) {
                            continue;
                        }
                        locationToken = value[0];
                        tokensToPush = value;
                        break;
                    case "NEOSTRING":
                        converted = fn.call(this, token[1], i);
                        if (converted.length === 0) {
                            if (i === 0) {
                                firstEmptyStringIndex = this.tokens.length;
                            } else {
                                continue;
                            }
                        }
                        if (i === 2 && firstEmptyStringIndex != null) {
                            this.tokens.splice(firstEmptyStringIndex, 2);
                        }
                        token[0] = "STRING";
                        token[1] = this.makeDelimitedLiteral(converted, options);
                        locationToken = token;
                        tokensToPush = [
                            token
                        ];
                }
                if (this.tokens.length > firstIndex) {
                    plusToken = this.token("+", "+");
                    plusToken[2] = {
                        first_line: locationToken[2].first_line,
                        first_column: locationToken[2].first_column,
                        last_line: locationToken[2].first_line,
                        last_column: locationToken[2].first_column
                    };
                }
                (ref2 = this.tokens).push.apply(ref2, tokensToPush);
            }
            if (lparen) {
                lastToken = tokens[tokens.length - 1];
                lparen.origin = [
                    "STRING",
                    null,
                    {
                        first_line: lparen[2].first_line,
                        first_column: lparen[2].first_column,
                        last_line: lastToken[2].last_line,
                        last_column: lastToken[2].last_column
                    }
                ];
                rparen = this.token("STRING_END", ")");
                return rparen[2] = {
                    first_line: lastToken[2].last_line,
                    first_column: lastToken[2].last_column,
                    last_line: lastToken[2].last_line,
                    last_column: lastToken[2].last_column
                };
            }
        };
        Lexer.prototype.pair = function(tag) {
            var lastIndent, prev, ref2, ref3, wanted;
            ref2 = this.ends, prev = ref2[ref2.length - 1];
            if (tag !== (wanted = prev != null ? prev.tag : void 0)) {
                if ("OUTDENT" !== wanted) {
                    this.error("unmatched " + tag);
                }
                ref3 = this.indents, lastIndent = ref3[ref3.length - 1];
                this.outdentToken(lastIndent, true);
                return this.pair(tag);
            }
            return this.ends.pop();
        };
        Lexer.prototype.getLineAndColumnFromChunk = function(offset) {
            var column, lastLine, lineCount, ref2, string;
            if (offset === 0) {
                return [
                    this.chunkLine,
                    this.chunkColumn
                ];
            }
            if (offset >= this.chunk.length) {
                string = this.chunk;
            } else {
                string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
            }
            lineCount = count(string, "\n");
            column = this.chunkColumn;
            if (lineCount > 0) {
                ref2 = string.split("\n"), lastLine = ref2[ref2.length - 1];
                column = lastLine.length;
            } else {
                column += string.length;
            }
            return [
                this.chunkLine + lineCount,
                column
            ];
        };
        Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) {
            var lastCharacter, locationData, ref2, ref3, token;
            if (offsetInChunk == null) {
                offsetInChunk = 0;
            }
            if (length == null) {
                length = value.length;
            }
            locationData = {};
            ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];
            lastCharacter = length > 0 ? length - 1 : 0;
            ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];
            token = [
                tag,
                value,
                locationData
            ];
            return token;
        };
        Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) {
            var token;
            token = this.makeToken(tag, value, offsetInChunk, length);
            if (origin) {
                token.origin = origin;
            }
            this.tokens.push(token);
            return token;
        };
        Lexer.prototype.tag = function() {
            var ref2, token;
            ref2 = this.tokens, token = ref2[ref2.length - 1];
            return token != null ? token[0] : void 0;
        };
        Lexer.prototype.value = function() {
            var ref2, token;
            ref2 = this.tokens, token = ref2[ref2.length - 1];
            return token != null ? token[1] : void 0;
        };
        Lexer.prototype.unfinished = function() {
            var ref2;
            return LINE_CONTINUER.test(this.chunk) || (ref2 = this.tag(), indexOf.call(UNFINISHED, ref2) >= 0);
        };
        Lexer.prototype.formatString = function(str, options) {
            return this.replaceUnicodeCodePointEscapes(str.replace(STRING_OMIT, "$1"), options);
        };
        Lexer.prototype.formatHeregex = function(str) {
            return this.formatRegex(str.replace(HEREGEX_OMIT, "$1$2"), {
                delimiter: "///"
            });
        };
        Lexer.prototype.formatRegex = function(str, options) {
            return this.replaceUnicodeCodePointEscapes(str, options);
        };
        Lexer.prototype.unicodeCodePointToUnicodeEscapes = function(codePoint) {
            var high, low, toUnicodeEscape;
            toUnicodeEscape = function(val) {
                var str;
                str = val.toString(16);
                return "\\u" + repeat("0", 4 - str.length) + str;
            };
            if (codePoint < 0x10000) {
                return toUnicodeEscape(codePoint);
            }
            high = Math.floor((codePoint - 0x10000) / 0x400) + 0xD800;
            low = (codePoint - 0x10000) % 0x400 + 0xDC00;
            return "" + toUnicodeEscape(high) + toUnicodeEscape(low);
        };
        Lexer.prototype.replaceUnicodeCodePointEscapes = function(str, options) {
            return str.replace(UNICODE_CODE_POINT_ESCAPE, function(_this) {
                return function(match, escapedBackslash, codePointHex, offset) {
                    var codePointDecimal;
                    if (escapedBackslash) {
                        return escapedBackslash;
                    }
                    codePointDecimal = parseInt(codePointHex, 16);
                    if (codePointDecimal > 0x10ffff) {
                        _this.error("unicode code point escapes greater than \\u{10ffff} are not allowed", {
                            offset: offset + options.delimiter.length,
                            length: codePointHex.length + 4
                        });
                    }
                    return _this.unicodeCodePointToUnicodeEscapes(codePointDecimal);
                };
            }(this));
        };
        Lexer.prototype.validateEscapes = function(str, options) {
            var before, hex, invalidEscape, invalidEscapeRegex, match, message, octal, ref2, unicode, unicodeCodePoint;
            if (options == null) {
                options = {};
            }
            invalidEscapeRegex = options.isRegex ? REGEX_INVALID_ESCAPE : STRING_INVALID_ESCAPE;
            match = invalidEscapeRegex.exec(str);
            if (!match) {
                return;
            }
            match[0], before = match[1], octal = match[2], hex = match[3], unicodeCodePoint = match[4], unicode = match[5];
            message = octal ? "octal escape sequences are not allowed" : "invalid escape sequence";
            invalidEscape = "\\" + (octal || hex || unicodeCodePoint || unicode);
            return this.error(message + " " + invalidEscape, {
                offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,
                length: invalidEscape.length
            });
        };
        Lexer.prototype.makeDelimitedLiteral = function(body, options) {
            var regex;
            if (options == null) {
                options = {};
            }
            if (body === "" && options.delimiter === "/") {
                body = "(?:)";
            }
            regex = RegExp("(\\\\\\\\)|(\\\\0(?=[1-7]))|\\\\?(" + options.delimiter + ")|\\\\?(?:(\\n)|(\\r)|(\\u2028)|(\\u2029))|(\\\\.)", "g");
            body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) {
                switch(false){
                    case !backslash:
                        if (options.double) {
                            return backslash + backslash;
                        } else {
                            return backslash;
                        }
                    case !nul:
                        return "\\x00";
                    case !delimiter:
                        return "\\" + delimiter;
                    case !lf:
                        return "\\n";
                    case !cr:
                        return "\\r";
                    case !ls:
                        return "\\u2028";
                    case !ps:
                        return "\\u2029";
                    case !other:
                        if (options.double) {
                            return "\\" + other;
                        } else {
                            return other;
                        }
                }
            });
            return "" + options.delimiter + body + options.delimiter;
        };
        Lexer.prototype.error = function(message, options) {
            var first_column, first_line, location, ref2, ref3, ref4;
            if (options == null) {
                options = {};
            }
            location = "first_line" in options ? options : (ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3, {
                first_line: first_line,
                first_column: first_column,
                last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1
            });
            return throwSyntaxError(message, location);
        };
        return Lexer;
    }();
    isUnassignable = function(name, displayName) {
        if (displayName == null) {
            displayName = name;
        }
        switch(false){
            case indexOf.call(slice.call(JS_KEYWORDS).concat(slice.call(COFFEE_KEYWORDS)), name) < 0:
                return "keyword '" + displayName + "' can't be assigned";
            case indexOf.call(STRICT_PROSCRIBED, name) < 0:
                return "'" + displayName + "' can't be assigned";
            case indexOf.call(RESERVED, name) < 0:
                return "reserved word '" + displayName + "' can't be assigned";
            default:
                return false;
        }
    };
    exports.isUnassignable = isUnassignable;
    isForFrom = function(prev) {
        var ref2;
        if (prev[0] === "IDENTIFIER") {
            if (prev[1] === "from") {
                prev[1][0] = "IDENTIFIER";
                true;
            }
            return true;
        } else if (prev[0] === "FOR") {
            return false;
        } else if ((ref2 = prev[1]) === "{" || ref2 === "[" || ref2 === "," || ref2 === ":") {
            return false;
        } else {
            return true;
        }
    };
    JS_KEYWORDS = [
        "true",
        "false",
        "null",
        "this",
        "new",
        "delete",
        "typeof",
        "in",
        "instanceof",
        "return",
        "throw",
        "break",
        "continue",
        "debugger",
        "yield",
        "if",
        "else",
        "switch",
        "for",
        "while",
        "do",
        "try",
        "catch",
        "finally",
        "class",
        "extends",
        "super",
        "import",
        "export",
        "default"
    ];
    COFFEE_KEYWORDS = [
        "undefined",
        "Infinity",
        "NaN",
        "then",
        "unless",
        "until",
        "loop",
        "of",
        "by",
        "when"
    ];
    COFFEE_ALIAS_MAP = {
        and: "&&",
        or: "||",
        is: "==",
        isnt: "!=",
        not: "!",
        yes: "true",
        no: "false",
        on: "true",
        off: "false"
    };
    COFFEE_ALIASES = function() {
        var results;
        results = [];
        for(key in COFFEE_ALIAS_MAP){
            results.push(key);
        }
        return results;
    }();
    COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);
    RESERVED = [
        "case",
        "function",
        "var",
        "void",
        "with",
        "const",
        "let",
        "enum",
        "native",
        "implements",
        "interface",
        "package",
        "private",
        "protected",
        "public",
        "static"
    ];
    STRICT_PROSCRIBED = [
        "arguments",
        "eval"
    ];
    exports.JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);
    BOM = 65279;
    IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)([^\n\S]*:(?!:))?/;
    NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;
    OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/;
    WHITESPACE = /^[^\n\S]+/;
    COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/;
    CODE = /^[-=]>/;
    MULTI_DENT = /^(?:\n[^\n\S]*)+/;
    JSTOKEN = /^`(?!``)((?:[^`\\]|\\[\s\S])*)`/;
    HERE_JSTOKEN = /^```((?:[^`\\]|\\[\s\S]|`(?!``))*)```/;
    STRING_START = /^(?:'''|"""|'|")/;
    STRING_SINGLE = /^(?:[^\\']|\\[\s\S])*/;
    STRING_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|\#(?!\{))*/;
    HEREDOC_SINGLE = /^(?:[^\\']|\\[\s\S]|'(?!''))*/;
    HEREDOC_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|"(?!"")|\#(?!\{))*/;
    STRING_OMIT = /((?:\\\\)+)|\\[^\S\n]*\n\s*/g;
    SIMPLE_STRING_OMIT = /\s*\n\s*/g;
    HEREDOC_INDENT = /\n+([^\n\S]*)(?=\S)/g;
    REGEX = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;
    REGEX_FLAGS = /^\w*/;
    VALID_FLAGS = /^(?!.*(.).*\1)[imguy]*$/;
    HEREGEX = /^(?:[^\\\/#]|\\[\s\S]|\/(?!\/\/)|\#(?!\{))*/;
    HEREGEX_OMIT = /((?:\\\\)+)|\\(\s)|\s+(?:#.*)?/g;
    REGEX_ILLEGAL = /^(\/|\/{3}\s*)(\*)/;
    POSSIBLY_DIVISION = /^\/=?\s/;
    HERECOMMENT_ILLEGAL = /\*\//;
    LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;
    STRING_INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0[0-7]|[1-7])|(x(?![\da-fA-F]{2}).{0,2})|(u\{(?![\da-fA-F]{1,}\})[^}]*\}?)|(u(?!\{|[\da-fA-F]{4}).{0,4}))/;
    REGEX_INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0[0-7])|(x(?![\da-fA-F]{2}).{0,2})|(u\{(?![\da-fA-F]{1,}\})[^}]*\}?)|(u(?!\{|[\da-fA-F]{4}).{0,4}))/;
    UNICODE_CODE_POINT_ESCAPE = /(\\\\)|\\u\{([\da-fA-F]+)\}/g;
    LEADING_BLANK_LINE = /^[^\n\S]*\n/;
    TRAILING_BLANK_LINE = /\n[^\n\S]*$/;
    TRAILING_SPACES = /\s+$/;
    COMPOUND_ASSIGN = [
        "-=",
        "+=",
        "/=",
        "*=",
        "%=",
        "||=",
        "&&=",
        "?=",
        "<<=",
        ">>=",
        ">>>=",
        "&=",
        "^=",
        "|=",
        "**=",
        "//=",
        "%%="
    ];
    UNARY = [
        "NEW",
        "TYPEOF",
        "DELETE",
        "DO"
    ];
    UNARY_MATH = [
        "!",
        "~"
    ];
    SHIFT = [
        "<<",
        ">>",
        ">>>"
    ];
    COMPARE = [
        "==",
        "!=",
        "<",
        ">",
        "<=",
        ">="
    ];
    MATH = [
        "*",
        "/",
        "%",
        "//",
        "%%"
    ];
    RELATION = [
        "IN",
        "OF",
        "INSTANCEOF"
    ];
    BOOL = [
        "TRUE",
        "FALSE"
    ];
    CALLABLE = [
        "IDENTIFIER",
        "PROPERTY",
        ")",
        "]",
        "?",
        "@",
        "THIS",
        "SUPER"
    ];
    INDEXABLE = CALLABLE.concat([
        "NUMBER",
        "INFINITY",
        "NAN",
        "STRING",
        "STRING_END",
        "REGEX",
        "REGEX_END",
        "BOOL",
        "NULL",
        "UNDEFINED",
        "}",
        "::"
    ]);
    NOT_REGEX = INDEXABLE.concat([
        "++",
        "--"
    ]);
    LINE_BREAK = [
        "INDENT",
        "OUTDENT",
        "TERMINATOR"
    ];
    INDENTABLE_CLOSERS = [
        ")",
        "}",
        "]"
    ];
    UNFINISHED = [
        "\\",
        ".",
        "?.",
        "?::",
        "UNARY",
        "MATH",
        "UNARY_MATH",
        "+",
        "-",
        "**",
        "SHIFT",
        "RELATION",
        "COMPARE",
        "&",
        "^",
        "|",
        "&&",
        "||",
        "BIN?",
        "THROW",
        "EXTENDS",
        "DEFAULT"
    ];
}).call(this);


/***/ }),

/***/ 45987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
    var Access, Arr, Assign, Base, Block, BooleanLiteral, Call, Class, Code, CodeFragment, Comment, Existence, Expansion, ExportAllDeclaration, ExportDeclaration, ExportDefaultDeclaration, ExportNamedDeclaration, ExportSpecifier, ExportSpecifierList, Extends, For, IdentifierLiteral, If, ImportClause, ImportDeclaration, ImportDefaultSpecifier, ImportNamespaceSpecifier, ImportSpecifier, ImportSpecifierList, In, Index, InfinityLiteral, JS_FORBIDDEN, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, Literal, ModuleDeclaration, ModuleSpecifier, ModuleSpecifierList, NEGATE, NO, NaNLiteral, NullLiteral, NumberLiteral, Obj, Op, Param, Parens, PassthroughLiteral, PropertyName, Range, RegexLiteral, RegexWithInterpolations, Return, SIMPLENUM, Scope, Slice, Splat, StatementLiteral, StringLiteral, StringWithInterpolations, SuperCall, Switch, TAB, THIS, TaggedTemplateCall, ThisLiteral, Throw, Try, UTILITIES, UndefinedLiteral, Value, While, YES, YieldReturn, addLocationDataFn, compact, del, ends, extend, flatten, fragmentsToText, isComplexOrAssignable, isLiteralArguments, isLiteralThis, isUnassignable, locationDataToString, merge, multident, ref1, ref2, some, starts, throwSyntaxError, unfoldSoak, utility, extend1 = function(child, parent) {
        for(var key in parent){
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty, indexOf = [].indexOf || function(item) {
        for(var i = 0, l = this.length; i < l; i++){
            if (i in this && this[i] === item) return i;
        }
        return -1;
    }, slice = [].slice;
    Error.stackTraceLimit = Infinity;
    Scope = (__webpack_require__(35533).Scope);
    ref1 = __webpack_require__(78061), isUnassignable = ref1.isUnassignable, JS_FORBIDDEN = ref1.JS_FORBIDDEN;
    ref2 = __webpack_require__(18765), compact = ref2.compact, flatten = ref2.flatten, extend = ref2.extend, merge = ref2.merge, del = ref2.del, starts = ref2.starts, ends = ref2.ends, some = ref2.some, addLocationDataFn = ref2.addLocationDataFn, locationDataToString = ref2.locationDataToString, throwSyntaxError = ref2.throwSyntaxError;
    exports.extend = extend;
    exports.addLocationDataFn = addLocationDataFn;
    YES = function() {
        return true;
    };
    NO = function() {
        return false;
    };
    THIS = function() {
        return this;
    };
    NEGATE = function() {
        this.negated = !this.negated;
        return this;
    };
    exports.CodeFragment = CodeFragment = function() {
        function CodeFragment(parent, code) {
            var ref3;
            this.code = "" + code;
            this.locationData = parent != null ? parent.locationData : void 0;
            this.type = (parent != null ? (ref3 = parent.constructor) != null ? ref3.name : void 0 : void 0) || "unknown";
        }
        CodeFragment.prototype.toString = function() {
            return "" + this.code + (this.locationData ? ": " + locationDataToString(this.locationData) : "");
        };
        return CodeFragment;
    }();
    fragmentsToText = function(fragments) {
        var fragment;
        return (function() {
            var j, len1, results;
            results = [];
            for(j = 0, len1 = fragments.length; j < len1; j++){
                fragment = fragments[j];
                results.push(fragment.code);
            }
            return results;
        })().join("");
    };
    exports.Base = Base = function() {
        function Base() {}
        Base.prototype.compile = function(o, lvl) {
            return fragmentsToText(this.compileToFragments(o, lvl));
        };
        Base.prototype.compileToFragments = function(o, lvl) {
            var node;
            o = extend({}, o);
            if (lvl) {
                o.level = lvl;
            }
            node = this.unfoldSoak(o) || this;
            node.tab = o.indent;
            if (o.level === LEVEL_TOP || !node.isStatement(o)) {
                return node.compileNode(o);
            } else {
                return node.compileClosure(o);
            }
        };
        Base.prototype.compileClosure = function(o) {
            var args, argumentsNode, func, jumpNode, meth, parts, ref3;
            if (jumpNode = this.jumps()) {
                jumpNode.error("cannot use a pure statement in an expression");
            }
            o.sharedScope = true;
            func = new Code([], Block.wrap([
                this
            ]));
            args = [];
            if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {
                args = [
                    new ThisLiteral
                ];
                if (argumentsNode) {
                    meth = "apply";
                    args.push(new IdentifierLiteral("arguments"));
                } else {
                    meth = "call";
                }
                func = new Value(func, [
                    new Access(new PropertyName(meth))
                ]);
            }
            parts = new Call(func, args).compileNode(o);
            if (func.isGenerator || ((ref3 = func.base) != null ? ref3.isGenerator : void 0)) {
                parts.unshift(this.makeCode("(yield* "));
                parts.push(this.makeCode(")"));
            }
            return parts;
        };
        Base.prototype.cache = function(o, level, isComplex) {
            var complex, ref, sub;
            complex = isComplex != null ? isComplex(this) : this.isComplex();
            if (complex) {
                ref = new IdentifierLiteral(o.scope.freeVariable("ref"));
                sub = new Assign(ref, this);
                if (level) {
                    return [
                        sub.compileToFragments(o, level),
                        [
                            this.makeCode(ref.value)
                        ]
                    ];
                } else {
                    return [
                        sub,
                        ref
                    ];
                }
            } else {
                ref = level ? this.compileToFragments(o, level) : this;
                return [
                    ref,
                    ref
                ];
            }
        };
        Base.prototype.cacheToCodeFragments = function(cacheValues) {
            return [
                fragmentsToText(cacheValues[0]),
                fragmentsToText(cacheValues[1])
            ];
        };
        Base.prototype.makeReturn = function(res) {
            var me;
            me = this.unwrapAll();
            if (res) {
                return new Call(new Literal(res + ".push"), [
                    me
                ]);
            } else {
                return new Return(me);
            }
        };
        Base.prototype.contains = function(pred) {
            var node;
            node = void 0;
            this.traverseChildren(false, function(n) {
                if (pred(n)) {
                    node = n;
                    return false;
                }
            });
            return node;
        };
        Base.prototype.lastNonComment = function(list) {
            var i;
            i = list.length;
            while(i--){
                if (!(list[i] instanceof Comment)) {
                    return list[i];
                }
            }
            return null;
        };
        Base.prototype.toString = function(idt, name) {
            var tree;
            if (idt == null) {
                idt = "";
            }
            if (name == null) {
                name = this.constructor.name;
            }
            tree = "\n" + idt + name;
            if (this.soak) {
                tree += "?";
            }
            this.eachChild(function(node) {
                return tree += node.toString(idt + TAB);
            });
            return tree;
        };
        Base.prototype.eachChild = function(func) {
            var attr, child, j, k, len1, len2, ref3, ref4;
            if (!this.children) {
                return this;
            }
            ref3 = this.children;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                attr = ref3[j];
                if (this[attr]) {
                    ref4 = flatten([
                        this[attr]
                    ]);
                    for(k = 0, len2 = ref4.length; k < len2; k++){
                        child = ref4[k];
                        if (func(child) === false) {
                            return this;
                        }
                    }
                }
            }
            return this;
        };
        Base.prototype.traverseChildren = function(crossScope, func) {
            return this.eachChild(function(child) {
                var recur;
                recur = func(child);
                if (recur !== false) {
                    return child.traverseChildren(crossScope, func);
                }
            });
        };
        Base.prototype.invert = function() {
            return new Op("!", this);
        };
        Base.prototype.unwrapAll = function() {
            var node;
            node = this;
            while(node !== (node = node.unwrap())){
                continue;
            }
            return node;
        };
        Base.prototype.children = [];
        Base.prototype.isStatement = NO;
        Base.prototype.jumps = NO;
        Base.prototype.isComplex = YES;
        Base.prototype.isChainable = NO;
        Base.prototype.isAssignable = NO;
        Base.prototype.isNumber = NO;
        Base.prototype.unwrap = THIS;
        Base.prototype.unfoldSoak = NO;
        Base.prototype.assigns = NO;
        Base.prototype.updateLocationDataIfMissing = function(locationData) {
            if (this.locationData) {
                return this;
            }
            this.locationData = locationData;
            return this.eachChild(function(child) {
                return child.updateLocationDataIfMissing(locationData);
            });
        };
        Base.prototype.error = function(message) {
            return throwSyntaxError(message, this.locationData);
        };
        Base.prototype.makeCode = function(code) {
            return new CodeFragment(this, code);
        };
        Base.prototype.wrapInBraces = function(fragments) {
            return [].concat(this.makeCode("("), fragments, this.makeCode(")"));
        };
        Base.prototype.joinFragmentArrays = function(fragmentsList, joinStr) {
            var answer, fragments, i, j, len1;
            answer = [];
            for(i = j = 0, len1 = fragmentsList.length; j < len1; i = ++j){
                fragments = fragmentsList[i];
                if (i) {
                    answer.push(this.makeCode(joinStr));
                }
                answer = answer.concat(fragments);
            }
            return answer;
        };
        return Base;
    }();
    exports.Block = Block = function(superClass1) {
        extend1(Block, superClass1);
        function Block(nodes) {
            this.expressions = compact(flatten(nodes || []));
        }
        Block.prototype.children = [
            "expressions"
        ];
        Block.prototype.push = function(node) {
            this.expressions.push(node);
            return this;
        };
        Block.prototype.pop = function() {
            return this.expressions.pop();
        };
        Block.prototype.unshift = function(node) {
            this.expressions.unshift(node);
            return this;
        };
        Block.prototype.unwrap = function() {
            if (this.expressions.length === 1) {
                return this.expressions[0];
            } else {
                return this;
            }
        };
        Block.prototype.isEmpty = function() {
            return !this.expressions.length;
        };
        Block.prototype.isStatement = function(o) {
            var exp, j, len1, ref3;
            ref3 = this.expressions;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                exp = ref3[j];
                if (exp.isStatement(o)) {
                    return true;
                }
            }
            return false;
        };
        Block.prototype.jumps = function(o) {
            var exp, j, jumpNode, len1, ref3;
            ref3 = this.expressions;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                exp = ref3[j];
                if (jumpNode = exp.jumps(o)) {
                    return jumpNode;
                }
            }
        };
        Block.prototype.makeReturn = function(res) {
            var expr, len;
            len = this.expressions.length;
            while(len--){
                expr = this.expressions[len];
                if (!(expr instanceof Comment)) {
                    this.expressions[len] = expr.makeReturn(res);
                    if (expr instanceof Return && !expr.expression) {
                        this.expressions.splice(len, 1);
                    }
                    break;
                }
            }
            return this;
        };
        Block.prototype.compileToFragments = function(o, level) {
            if (o == null) {
                o = {};
            }
            if (o.scope) {
                return Block.__super__.compileToFragments.call(this, o, level);
            } else {
                return this.compileRoot(o);
            }
        };
        Block.prototype.compileNode = function(o) {
            var answer, compiledNodes, fragments, index, j, len1, node, ref3, top;
            this.tab = o.indent;
            top = o.level === LEVEL_TOP;
            compiledNodes = [];
            ref3 = this.expressions;
            for(index = j = 0, len1 = ref3.length; j < len1; index = ++j){
                node = ref3[index];
                node = node.unwrapAll();
                node = node.unfoldSoak(o) || node;
                if (node instanceof Block) {
                    compiledNodes.push(node.compileNode(o));
                } else if (top) {
                    node.front = true;
                    fragments = node.compileToFragments(o);
                    if (!node.isStatement(o)) {
                        fragments.unshift(this.makeCode("" + this.tab));
                        fragments.push(this.makeCode(";"));
                    }
                    compiledNodes.push(fragments);
                } else {
                    compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
                }
            }
            if (top) {
                if (this.spaced) {
                    return [].concat(this.joinFragmentArrays(compiledNodes, "\n\n"), this.makeCode("\n"));
                } else {
                    return this.joinFragmentArrays(compiledNodes, "\n");
                }
            }
            if (compiledNodes.length) {
                answer = this.joinFragmentArrays(compiledNodes, ", ");
            } else {
                answer = [
                    this.makeCode("void 0")
                ];
            }
            if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {
                return this.wrapInBraces(answer);
            } else {
                return answer;
            }
        };
        Block.prototype.compileRoot = function(o) {
            var exp, fragments, i, j, len1, name, prelude, preludeExps, ref3, ref4, rest;
            o.indent = o.bare ? "" : TAB;
            o.level = LEVEL_TOP;
            this.spaced = true;
            o.scope = new Scope(null, this, null, (ref3 = o.referencedVars) != null ? ref3 : []);
            ref4 = o.locals || [];
            for(j = 0, len1 = ref4.length; j < len1; j++){
                name = ref4[j];
                o.scope.parameter(name);
            }
            prelude = [];
            if (!o.bare) {
                preludeExps = (function() {
                    var k, len2, ref5, results;
                    ref5 = this.expressions;
                    results = [];
                    for(i = k = 0, len2 = ref5.length; k < len2; i = ++k){
                        exp = ref5[i];
                        if (!(exp.unwrap() instanceof Comment)) {
                            break;
                        }
                        results.push(exp);
                    }
                    return results;
                }).call(this);
                rest = this.expressions.slice(preludeExps.length);
                this.expressions = preludeExps;
                if (preludeExps.length) {
                    prelude = this.compileNode(merge(o, {
                        indent: ""
                    }));
                    prelude.push(this.makeCode("\n"));
                }
                this.expressions = rest;
            }
            fragments = this.compileWithDeclarations(o);
            if (o.bare) {
                return fragments;
            }
            return [].concat(prelude, this.makeCode("(function() {\n"), fragments, this.makeCode("\n}).call(this);\n"));
        };
        Block.prototype.compileWithDeclarations = function(o) {
            var assigns, declars, exp, fragments, i, j, len1, post, ref3, ref4, ref5, rest, scope, spaced;
            fragments = [];
            post = [];
            ref3 = this.expressions;
            for(i = j = 0, len1 = ref3.length; j < len1; i = ++j){
                exp = ref3[i];
                exp = exp.unwrap();
                if (!(exp instanceof Comment || exp instanceof Literal)) {
                    break;
                }
            }
            o = merge(o, {
                level: LEVEL_TOP
            });
            if (i) {
                rest = this.expressions.splice(i, 9e9);
                ref4 = [
                    this.spaced,
                    false
                ], spaced = ref4[0], this.spaced = ref4[1];
                ref5 = [
                    this.compileNode(o),
                    spaced
                ], fragments = ref5[0], this.spaced = ref5[1];
                this.expressions = rest;
            }
            post = this.compileNode(o);
            scope = o.scope;
            if (scope.expressions === this) {
                declars = o.scope.hasDeclarations();
                assigns = scope.hasAssignments;
                if (declars || assigns) {
                    if (i) {
                        fragments.push(this.makeCode("\n"));
                    }
                    fragments.push(this.makeCode(this.tab + "var "));
                    if (declars) {
                        fragments.push(this.makeCode(scope.declaredVariables().join(", ")));
                    }
                    if (assigns) {
                        if (declars) {
                            fragments.push(this.makeCode(",\n" + (this.tab + TAB)));
                        }
                        fragments.push(this.makeCode(scope.assignedVariables().join(",\n" + (this.tab + TAB))));
                    }
                    fragments.push(this.makeCode(";\n" + (this.spaced ? "\n" : "")));
                } else if (fragments.length && post.length) {
                    fragments.push(this.makeCode("\n"));
                }
            }
            return fragments.concat(post);
        };
        Block.wrap = function(nodes) {
            if (nodes.length === 1 && nodes[0] instanceof Block) {
                return nodes[0];
            }
            return new Block(nodes);
        };
        return Block;
    }(Base);
    exports.Literal = Literal = function(superClass1) {
        extend1(Literal, superClass1);
        function Literal(value1) {
            this.value = value1;
        }
        Literal.prototype.isComplex = NO;
        Literal.prototype.assigns = function(name) {
            return name === this.value;
        };
        Literal.prototype.compileNode = function(o) {
            return [
                this.makeCode(this.value)
            ];
        };
        Literal.prototype.toString = function() {
            return " " + (this.isStatement() ? Literal.__super__.toString.apply(this, arguments) : this.constructor.name) + ": " + this.value;
        };
        return Literal;
    }(Base);
    exports.NumberLiteral = NumberLiteral = function(superClass1) {
        extend1(NumberLiteral, superClass1);
        function NumberLiteral() {
            return NumberLiteral.__super__.constructor.apply(this, arguments);
        }
        return NumberLiteral;
    }(Literal);
    exports.InfinityLiteral = InfinityLiteral = function(superClass1) {
        extend1(InfinityLiteral, superClass1);
        function InfinityLiteral() {
            return InfinityLiteral.__super__.constructor.apply(this, arguments);
        }
        InfinityLiteral.prototype.compileNode = function() {
            return [
                this.makeCode("2e308")
            ];
        };
        return InfinityLiteral;
    }(NumberLiteral);
    exports.NaNLiteral = NaNLiteral = function(superClass1) {
        extend1(NaNLiteral, superClass1);
        function NaNLiteral() {
            NaNLiteral.__super__.constructor.call(this, "NaN");
        }
        NaNLiteral.prototype.compileNode = function(o) {
            var code;
            code = [
                this.makeCode("0/0")
            ];
            if (o.level >= LEVEL_OP) {
                return this.wrapInBraces(code);
            } else {
                return code;
            }
        };
        return NaNLiteral;
    }(NumberLiteral);
    exports.StringLiteral = StringLiteral = function(superClass1) {
        extend1(StringLiteral, superClass1);
        function StringLiteral() {
            return StringLiteral.__super__.constructor.apply(this, arguments);
        }
        return StringLiteral;
    }(Literal);
    exports.RegexLiteral = RegexLiteral = function(superClass1) {
        extend1(RegexLiteral, superClass1);
        function RegexLiteral() {
            return RegexLiteral.__super__.constructor.apply(this, arguments);
        }
        return RegexLiteral;
    }(Literal);
    exports.PassthroughLiteral = PassthroughLiteral = function(superClass1) {
        extend1(PassthroughLiteral, superClass1);
        function PassthroughLiteral() {
            return PassthroughLiteral.__super__.constructor.apply(this, arguments);
        }
        return PassthroughLiteral;
    }(Literal);
    exports.IdentifierLiteral = IdentifierLiteral = function(superClass1) {
        extend1(IdentifierLiteral, superClass1);
        function IdentifierLiteral() {
            return IdentifierLiteral.__super__.constructor.apply(this, arguments);
        }
        IdentifierLiteral.prototype.isAssignable = YES;
        return IdentifierLiteral;
    }(Literal);
    exports.PropertyName = PropertyName = function(superClass1) {
        extend1(PropertyName, superClass1);
        function PropertyName() {
            return PropertyName.__super__.constructor.apply(this, arguments);
        }
        PropertyName.prototype.isAssignable = YES;
        return PropertyName;
    }(Literal);
    exports.StatementLiteral = StatementLiteral = function(superClass1) {
        extend1(StatementLiteral, superClass1);
        function StatementLiteral() {
            return StatementLiteral.__super__.constructor.apply(this, arguments);
        }
        StatementLiteral.prototype.isStatement = YES;
        StatementLiteral.prototype.makeReturn = THIS;
        StatementLiteral.prototype.jumps = function(o) {
            if (this.value === "break" && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
                return this;
            }
            if (this.value === "continue" && !(o != null ? o.loop : void 0)) {
                return this;
            }
        };
        StatementLiteral.prototype.compileNode = function(o) {
            return [
                this.makeCode("" + this.tab + this.value + ";")
            ];
        };
        return StatementLiteral;
    }(Literal);
    exports.ThisLiteral = ThisLiteral = function(superClass1) {
        extend1(ThisLiteral, superClass1);
        function ThisLiteral() {
            ThisLiteral.__super__.constructor.call(this, "this");
        }
        ThisLiteral.prototype.compileNode = function(o) {
            var code, ref3;
            code = ((ref3 = o.scope.method) != null ? ref3.bound : void 0) ? o.scope.method.context : this.value;
            return [
                this.makeCode(code)
            ];
        };
        return ThisLiteral;
    }(Literal);
    exports.UndefinedLiteral = UndefinedLiteral = function(superClass1) {
        extend1(UndefinedLiteral, superClass1);
        function UndefinedLiteral() {
            UndefinedLiteral.__super__.constructor.call(this, "undefined");
        }
        UndefinedLiteral.prototype.compileNode = function(o) {
            return [
                this.makeCode(o.level >= LEVEL_ACCESS ? "(void 0)" : "void 0")
            ];
        };
        return UndefinedLiteral;
    }(Literal);
    exports.NullLiteral = NullLiteral = function(superClass1) {
        extend1(NullLiteral, superClass1);
        function NullLiteral() {
            NullLiteral.__super__.constructor.call(this, "null");
        }
        return NullLiteral;
    }(Literal);
    exports.BooleanLiteral = BooleanLiteral = function(superClass1) {
        extend1(BooleanLiteral, superClass1);
        function BooleanLiteral() {
            return BooleanLiteral.__super__.constructor.apply(this, arguments);
        }
        return BooleanLiteral;
    }(Literal);
    exports.Return = Return = function(superClass1) {
        extend1(Return, superClass1);
        function Return(expression) {
            this.expression = expression;
        }
        Return.prototype.children = [
            "expression"
        ];
        Return.prototype.isStatement = YES;
        Return.prototype.makeReturn = THIS;
        Return.prototype.jumps = THIS;
        Return.prototype.compileToFragments = function(o, level) {
            var expr, ref3;
            expr = (ref3 = this.expression) != null ? ref3.makeReturn() : void 0;
            if (expr && !(expr instanceof Return)) {
                return expr.compileToFragments(o, level);
            } else {
                return Return.__super__.compileToFragments.call(this, o, level);
            }
        };
        Return.prototype.compileNode = function(o) {
            var answer;
            answer = [];
            answer.push(this.makeCode(this.tab + ("return" + (this.expression ? " " : ""))));
            if (this.expression) {
                answer = answer.concat(this.expression.compileToFragments(o, LEVEL_PAREN));
            }
            answer.push(this.makeCode(";"));
            return answer;
        };
        return Return;
    }(Base);
    exports.YieldReturn = YieldReturn = function(superClass1) {
        extend1(YieldReturn, superClass1);
        function YieldReturn() {
            return YieldReturn.__super__.constructor.apply(this, arguments);
        }
        YieldReturn.prototype.compileNode = function(o) {
            if (o.scope.parent == null) {
                this.error("yield can only occur inside functions");
            }
            return YieldReturn.__super__.compileNode.apply(this, arguments);
        };
        return YieldReturn;
    }(Return);
    exports.Value = Value = function(superClass1) {
        extend1(Value, superClass1);
        function Value(base, props, tag) {
            if (!props && base instanceof Value) {
                return base;
            }
            this.base = base;
            this.properties = props || [];
            if (tag) {
                this[tag] = true;
            }
            return this;
        }
        Value.prototype.children = [
            "base",
            "properties"
        ];
        Value.prototype.add = function(props) {
            this.properties = this.properties.concat(props);
            return this;
        };
        Value.prototype.hasProperties = function() {
            return !!this.properties.length;
        };
        Value.prototype.bareLiteral = function(type) {
            return !this.properties.length && this.base instanceof type;
        };
        Value.prototype.isArray = function() {
            return this.bareLiteral(Arr);
        };
        Value.prototype.isRange = function() {
            return this.bareLiteral(Range);
        };
        Value.prototype.isComplex = function() {
            return this.hasProperties() || this.base.isComplex();
        };
        Value.prototype.isAssignable = function() {
            return this.hasProperties() || this.base.isAssignable();
        };
        Value.prototype.isNumber = function() {
            return this.bareLiteral(NumberLiteral);
        };
        Value.prototype.isString = function() {
            return this.bareLiteral(StringLiteral);
        };
        Value.prototype.isRegex = function() {
            return this.bareLiteral(RegexLiteral);
        };
        Value.prototype.isUndefined = function() {
            return this.bareLiteral(UndefinedLiteral);
        };
        Value.prototype.isNull = function() {
            return this.bareLiteral(NullLiteral);
        };
        Value.prototype.isBoolean = function() {
            return this.bareLiteral(BooleanLiteral);
        };
        Value.prototype.isAtomic = function() {
            var j, len1, node, ref3;
            ref3 = this.properties.concat(this.base);
            for(j = 0, len1 = ref3.length; j < len1; j++){
                node = ref3[j];
                if (node.soak || node instanceof Call) {
                    return false;
                }
            }
            return true;
        };
        Value.prototype.isNotCallable = function() {
            return this.isNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject() || this.isUndefined() || this.isNull() || this.isBoolean();
        };
        Value.prototype.isStatement = function(o) {
            return !this.properties.length && this.base.isStatement(o);
        };
        Value.prototype.assigns = function(name) {
            return !this.properties.length && this.base.assigns(name);
        };
        Value.prototype.jumps = function(o) {
            return !this.properties.length && this.base.jumps(o);
        };
        Value.prototype.isObject = function(onlyGenerated) {
            if (this.properties.length) {
                return false;
            }
            return this.base instanceof Obj && (!onlyGenerated || this.base.generated);
        };
        Value.prototype.isSplice = function() {
            var lastProp, ref3;
            ref3 = this.properties, lastProp = ref3[ref3.length - 1];
            return lastProp instanceof Slice;
        };
        Value.prototype.looksStatic = function(className) {
            var ref3;
            return this.base.value === className && this.properties.length === 1 && ((ref3 = this.properties[0].name) != null ? ref3.value : void 0) !== "prototype";
        };
        Value.prototype.unwrap = function() {
            if (this.properties.length) {
                return this;
            } else {
                return this.base;
            }
        };
        Value.prototype.cacheReference = function(o) {
            var base, bref, name, nref, ref3;
            ref3 = this.properties, name = ref3[ref3.length - 1];
            if (this.properties.length < 2 && !this.base.isComplex() && !(name != null ? name.isComplex() : void 0)) {
                return [
                    this,
                    this
                ];
            }
            base = new Value(this.base, this.properties.slice(0, -1));
            if (base.isComplex()) {
                bref = new IdentifierLiteral(o.scope.freeVariable("base"));
                base = new Value(new Parens(new Assign(bref, base)));
            }
            if (!name) {
                return [
                    base,
                    bref
                ];
            }
            if (name.isComplex()) {
                nref = new IdentifierLiteral(o.scope.freeVariable("name"));
                name = new Index(new Assign(nref, name.index));
                nref = new Index(nref);
            }
            return [
                base.add(name),
                new Value(bref || base.base, [
                    nref || name
                ])
            ];
        };
        Value.prototype.compileNode = function(o) {
            var fragments, j, len1, prop, props;
            this.base.front = this.front;
            props = this.properties;
            fragments = this.base.compileToFragments(o, props.length ? LEVEL_ACCESS : null);
            if (props.length && SIMPLENUM.test(fragmentsToText(fragments))) {
                fragments.push(this.makeCode("."));
            }
            for(j = 0, len1 = props.length; j < len1; j++){
                prop = props[j];
                fragments.push.apply(fragments, prop.compileToFragments(o));
            }
            return fragments;
        };
        Value.prototype.unfoldSoak = function(o) {
            return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (function(_this) {
                return function() {
                    var fst, i, ifn, j, len1, prop, ref, ref3, ref4, snd;
                    if (ifn = _this.base.unfoldSoak(o)) {
                        (ref3 = ifn.body.properties).push.apply(ref3, _this.properties);
                        return ifn;
                    }
                    ref4 = _this.properties;
                    for(i = j = 0, len1 = ref4.length; j < len1; i = ++j){
                        prop = ref4[i];
                        if (!prop.soak) {
                            continue;
                        }
                        prop.soak = false;
                        fst = new Value(_this.base, _this.properties.slice(0, i));
                        snd = new Value(_this.base, _this.properties.slice(i));
                        if (fst.isComplex()) {
                            ref = new IdentifierLiteral(o.scope.freeVariable("ref"));
                            fst = new Parens(new Assign(ref, fst));
                            snd.base = ref;
                        }
                        return new If(new Existence(fst), snd, {
                            soak: true
                        });
                    }
                    return false;
                };
            })(this)();
        };
        return Value;
    }(Base);
    exports.Comment = Comment = function(superClass1) {
        extend1(Comment, superClass1);
        function Comment(comment1) {
            this.comment = comment1;
        }
        Comment.prototype.isStatement = YES;
        Comment.prototype.makeReturn = THIS;
        Comment.prototype.compileNode = function(o, level) {
            var code, comment;
            comment = this.comment.replace(/^(\s*)#(?=\s)/gm, "$1 *");
            code = "/*" + multident(comment, this.tab) + (indexOf.call(comment, "\n") >= 0 ? "\n" + this.tab : "") + " */";
            if ((level || o.level) === LEVEL_TOP) {
                code = o.indent + code;
            }
            return [
                this.makeCode("\n"),
                this.makeCode(code)
            ];
        };
        return Comment;
    }(Base);
    exports.Call = Call = function(superClass1) {
        extend1(Call, superClass1);
        function Call(variable1, args1, soak1) {
            this.variable = variable1;
            this.args = args1 != null ? args1 : [];
            this.soak = soak1;
            this.isNew = false;
            if (this.variable instanceof Value && this.variable.isNotCallable()) {
                this.variable.error("literal is not a function");
            }
        }
        Call.prototype.children = [
            "variable",
            "args"
        ];
        Call.prototype.updateLocationDataIfMissing = function(locationData) {
            var base, ref3;
            if (this.locationData && this.needsUpdatedStartLocation) {
                this.locationData.first_line = locationData.first_line;
                this.locationData.first_column = locationData.first_column;
                base = ((ref3 = this.variable) != null ? ref3.base : void 0) || this.variable;
                if (base.needsUpdatedStartLocation) {
                    this.variable.locationData.first_line = locationData.first_line;
                    this.variable.locationData.first_column = locationData.first_column;
                    base.updateLocationDataIfMissing(locationData);
                }
                delete this.needsUpdatedStartLocation;
            }
            return Call.__super__.updateLocationDataIfMissing.apply(this, arguments);
        };
        Call.prototype.newInstance = function() {
            var base, ref3;
            base = ((ref3 = this.variable) != null ? ref3.base : void 0) || this.variable;
            if (base instanceof Call && !base.isNew) {
                base.newInstance();
            } else {
                this.isNew = true;
            }
            this.needsUpdatedStartLocation = true;
            return this;
        };
        Call.prototype.unfoldSoak = function(o) {
            var call, ifn, j, left, len1, list, ref3, ref4, rite;
            if (this.soak) {
                if (this instanceof SuperCall) {
                    left = new Literal(this.superReference(o));
                    rite = new Value(left);
                } else {
                    if (ifn = unfoldSoak(o, this, "variable")) {
                        return ifn;
                    }
                    ref3 = new Value(this.variable).cacheReference(o), left = ref3[0], rite = ref3[1];
                }
                rite = new Call(rite, this.args);
                rite.isNew = this.isNew;
                left = new Literal("typeof " + left.compile(o) + ' === "function"');
                return new If(left, new Value(rite), {
                    soak: true
                });
            }
            call = this;
            list = [];
            while(true){
                if (call.variable instanceof Call) {
                    list.push(call);
                    call = call.variable;
                    continue;
                }
                if (!(call.variable instanceof Value)) {
                    break;
                }
                list.push(call);
                if (!((call = call.variable.base) instanceof Call)) {
                    break;
                }
            }
            ref4 = list.reverse();
            for(j = 0, len1 = ref4.length; j < len1; j++){
                call = ref4[j];
                if (ifn) {
                    if (call.variable instanceof Call) {
                        call.variable = ifn;
                    } else {
                        call.variable.base = ifn;
                    }
                }
                ifn = unfoldSoak(o, call, "variable");
            }
            return ifn;
        };
        Call.prototype.compileNode = function(o) {
            var arg, argIndex, compiledArgs, compiledArray, fragments, j, len1, preface, ref3, ref4;
            if ((ref3 = this.variable) != null) {
                ref3.front = this.front;
            }
            compiledArray = Splat.compileSplattedArray(o, this.args, true);
            if (compiledArray.length) {
                return this.compileSplat(o, compiledArray);
            }
            compiledArgs = [];
            ref4 = this.args;
            for(argIndex = j = 0, len1 = ref4.length; j < len1; argIndex = ++j){
                arg = ref4[argIndex];
                if (argIndex) {
                    compiledArgs.push(this.makeCode(", "));
                }
                compiledArgs.push.apply(compiledArgs, arg.compileToFragments(o, LEVEL_LIST));
            }
            fragments = [];
            if (this instanceof SuperCall) {
                preface = this.superReference(o) + (".call(" + this.superThis(o));
                if (compiledArgs.length) {
                    preface += ", ";
                }
                fragments.push(this.makeCode(preface));
            } else {
                if (this.isNew) {
                    fragments.push(this.makeCode("new "));
                }
                fragments.push.apply(fragments, this.variable.compileToFragments(o, LEVEL_ACCESS));
                fragments.push(this.makeCode("("));
            }
            fragments.push.apply(fragments, compiledArgs);
            fragments.push(this.makeCode(")"));
            return fragments;
        };
        Call.prototype.compileSplat = function(o, splatArgs) {
            var answer, base, fun, idt, name, ref;
            if (this instanceof SuperCall) {
                return [].concat(this.makeCode(this.superReference(o) + ".apply(" + this.superThis(o) + ", "), splatArgs, this.makeCode(")"));
            }
            if (this.isNew) {
                idt = this.tab + TAB;
                return [].concat(this.makeCode("(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args);\n" + idt + "return Object(result) === result ? result : child;\n" + this.tab + "})("), this.variable.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), splatArgs, this.makeCode(", function(){})"));
            }
            answer = [];
            base = new Value(this.variable);
            if ((name = base.properties.pop()) && base.isComplex()) {
                ref = o.scope.freeVariable("ref");
                answer = answer.concat(this.makeCode("(" + ref + " = "), base.compileToFragments(o, LEVEL_LIST), this.makeCode(")"), name.compileToFragments(o));
            } else {
                fun = base.compileToFragments(o, LEVEL_ACCESS);
                if (SIMPLENUM.test(fragmentsToText(fun))) {
                    fun = this.wrapInBraces(fun);
                }
                if (name) {
                    ref = fragmentsToText(fun);
                    fun.push.apply(fun, name.compileToFragments(o));
                } else {
                    ref = "null";
                }
                answer = answer.concat(fun);
            }
            return answer = answer.concat(this.makeCode(".apply(" + ref + ", "), splatArgs, this.makeCode(")"));
        };
        return Call;
    }(Base);
    exports.SuperCall = SuperCall = function(superClass1) {
        extend1(SuperCall, superClass1);
        function SuperCall(args) {
            SuperCall.__super__.constructor.call(this, null, args != null ? args : [
                new Splat(new IdentifierLiteral("arguments"))
            ]);
            this.isBare = args != null;
        }
        SuperCall.prototype.superReference = function(o) {
            var accesses, base, bref, klass, method, name, nref, variable;
            method = o.scope.namedMethod();
            if (method != null ? method.klass : void 0) {
                klass = method.klass, name = method.name, variable = method.variable;
                if (klass.isComplex()) {
                    bref = new IdentifierLiteral(o.scope.parent.freeVariable("base"));
                    base = new Value(new Parens(new Assign(bref, klass)));
                    variable.base = base;
                    variable.properties.splice(0, klass.properties.length);
                }
                if (name.isComplex() || name instanceof Index && name.index.isAssignable()) {
                    nref = new IdentifierLiteral(o.scope.parent.freeVariable("name"));
                    name = new Index(new Assign(nref, name.index));
                    variable.properties.pop();
                    variable.properties.push(name);
                }
                accesses = [
                    new Access(new PropertyName("__super__"))
                ];
                if (method["static"]) {
                    accesses.push(new Access(new PropertyName("constructor")));
                }
                accesses.push(nref != null ? new Index(nref) : name);
                return new Value(bref != null ? bref : klass, accesses).compile(o);
            } else if (method != null ? method.ctor : void 0) {
                return method.name + ".__super__.constructor";
            } else {
                return this.error("cannot call super outside of an instance method.");
            }
        };
        SuperCall.prototype.superThis = function(o) {
            var method;
            method = o.scope.method;
            return method && !method.klass && method.context || "this";
        };
        return SuperCall;
    }(Call);
    exports.RegexWithInterpolations = RegexWithInterpolations = function(superClass1) {
        extend1(RegexWithInterpolations, superClass1);
        function RegexWithInterpolations(args) {
            if (args == null) {
                args = [];
            }
            RegexWithInterpolations.__super__.constructor.call(this, new Value(new IdentifierLiteral("RegExp")), args, false);
        }
        return RegexWithInterpolations;
    }(Call);
    exports.TaggedTemplateCall = TaggedTemplateCall = function(superClass1) {
        extend1(TaggedTemplateCall, superClass1);
        function TaggedTemplateCall(variable, arg, soak) {
            if (arg instanceof StringLiteral) {
                arg = new StringWithInterpolations(Block.wrap([
                    new Value(arg)
                ]));
            }
            TaggedTemplateCall.__super__.constructor.call(this, variable, [
                arg
            ], soak);
        }
        TaggedTemplateCall.prototype.compileNode = function(o) {
            o.inTaggedTemplateCall = true;
            return this.variable.compileToFragments(o, LEVEL_ACCESS).concat(this.args[0].compileToFragments(o, LEVEL_LIST));
        };
        return TaggedTemplateCall;
    }(Call);
    exports.Extends = Extends = function(superClass1) {
        extend1(Extends, superClass1);
        function Extends(child1, parent1) {
            this.child = child1;
            this.parent = parent1;
        }
        Extends.prototype.children = [
            "child",
            "parent"
        ];
        Extends.prototype.compileToFragments = function(o) {
            return new Call(new Value(new Literal(utility("extend", o))), [
                this.child,
                this.parent
            ]).compileToFragments(o);
        };
        return Extends;
    }(Base);
    exports.Access = Access = function(superClass1) {
        extend1(Access, superClass1);
        function Access(name1, tag) {
            this.name = name1;
            this.soak = tag === "soak";
        }
        Access.prototype.children = [
            "name"
        ];
        Access.prototype.compileToFragments = function(o) {
            var name, node, ref3;
            name = this.name.compileToFragments(o);
            node = this.name.unwrap();
            if (node instanceof PropertyName) {
                if (ref3 = node.value, indexOf.call(JS_FORBIDDEN, ref3) >= 0) {
                    return [
                        this.makeCode('["')
                    ].concat(slice.call(name), [
                        this.makeCode('"]')
                    ]);
                } else {
                    return [
                        this.makeCode(".")
                    ].concat(slice.call(name));
                }
            } else {
                return [
                    this.makeCode("[")
                ].concat(slice.call(name), [
                    this.makeCode("]")
                ]);
            }
        };
        Access.prototype.isComplex = NO;
        return Access;
    }(Base);
    exports.Index = Index = function(superClass1) {
        extend1(Index, superClass1);
        function Index(index1) {
            this.index = index1;
        }
        Index.prototype.children = [
            "index"
        ];
        Index.prototype.compileToFragments = function(o) {
            return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
        };
        Index.prototype.isComplex = function() {
            return this.index.isComplex();
        };
        return Index;
    }(Base);
    exports.Range = Range = function(superClass1) {
        extend1(Range, superClass1);
        Range.prototype.children = [
            "from",
            "to"
        ];
        function Range(from1, to1, tag) {
            this.from = from1;
            this.to = to1;
            this.exclusive = tag === "exclusive";
            this.equals = this.exclusive ? "" : "=";
        }
        Range.prototype.compileVariables = function(o) {
            var isComplex, ref3, ref4, ref5, step;
            o = merge(o, {
                top: true
            });
            isComplex = del(o, "isComplex");
            ref3 = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST, isComplex)), this.fromC = ref3[0], this.fromVar = ref3[1];
            ref4 = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST, isComplex)), this.toC = ref4[0], this.toVar = ref4[1];
            if (step = del(o, "step")) {
                ref5 = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST, isComplex)), this.step = ref5[0], this.stepVar = ref5[1];
            }
            this.fromNum = this.from.isNumber() ? Number(this.fromVar) : null;
            this.toNum = this.to.isNumber() ? Number(this.toVar) : null;
            return this.stepNum = (step != null ? step.isNumber() : void 0) ? Number(this.stepVar) : null;
        };
        Range.prototype.compileNode = function(o) {
            var cond, condPart, from, gt, idx, idxName, known, lt, namedIndex, ref3, ref4, stepPart, to, varPart;
            if (!this.fromVar) {
                this.compileVariables(o);
            }
            if (!o.index) {
                return this.compileArray(o);
            }
            known = this.fromNum != null && this.toNum != null;
            idx = del(o, "index");
            idxName = del(o, "name");
            namedIndex = idxName && idxName !== idx;
            varPart = idx + " = " + this.fromC;
            if (this.toC !== this.toVar) {
                varPart += ", " + this.toC;
            }
            if (this.step !== this.stepVar) {
                varPart += ", " + this.step;
            }
            ref3 = [
                idx + " <" + this.equals,
                idx + " >" + this.equals
            ], lt = ref3[0], gt = ref3[1];
            condPart = this.stepNum != null ? this.stepNum > 0 ? lt + " " + this.toVar : gt + " " + this.toVar : known ? (ref4 = [
                this.fromNum,
                this.toNum
            ], from = ref4[0], to = ref4[1], ref4, from <= to ? lt + " " + to : gt + " " + to) : (cond = this.stepVar ? this.stepVar + " > 0" : this.fromVar + " <= " + this.toVar, cond + " ? " + lt + " " + this.toVar + " : " + gt + " " + this.toVar);
            stepPart = this.stepVar ? idx + " += " + this.stepVar : known ? namedIndex ? from <= to ? "++" + idx : "--" + idx : from <= to ? idx + "++" : idx + "--" : namedIndex ? cond + " ? ++" + idx + " : --" + idx : cond + " ? " + idx + "++ : " + idx + "--";
            if (namedIndex) {
                varPart = idxName + " = " + varPart;
            }
            if (namedIndex) {
                stepPart = idxName + " = " + stepPart;
            }
            return [
                this.makeCode(varPart + "; " + condPart + "; " + stepPart)
            ];
        };
        Range.prototype.compileArray = function(o) {
            var args, body, cond, hasArgs, i, idt, j, known, post, pre, range, ref3, ref4, result, results, vars;
            known = this.fromNum != null && this.toNum != null;
            if (known && Math.abs(this.fromNum - this.toNum) <= 20) {
                range = (function() {
                    results = [];
                    for(var j = ref3 = this.fromNum, ref4 = this.toNum; ref3 <= ref4 ? j <= ref4 : j >= ref4; ref3 <= ref4 ? j++ : j--){
                        results.push(j);
                    }
                    return results;
                }).apply(this);
                if (this.exclusive) {
                    range.pop();
                }
                return [
                    this.makeCode("[" + range.join(", ") + "]")
                ];
            }
            idt = this.tab + TAB;
            i = o.scope.freeVariable("i", {
                single: true
            });
            result = o.scope.freeVariable("results");
            pre = "\n" + idt + result + " = [];";
            if (known) {
                o.index = i;
                body = fragmentsToText(this.compileNode(o));
            } else {
                vars = i + " = " + this.fromC + (this.toC !== this.toVar ? ", " + this.toC : "");
                cond = this.fromVar + " <= " + this.toVar;
                body = "var " + vars + "; " + cond + " ? " + i + " <" + this.equals + " " + this.toVar + " : " + i + " >" + this.equals + " " + this.toVar + "; " + cond + " ? " + i + "++ : " + i + "--";
            }
            post = "{ " + result + ".push(" + i + "); }\n" + idt + "return " + result + ";\n" + o.indent;
            hasArgs = function(node) {
                return node != null ? node.contains(isLiteralArguments) : void 0;
            };
            if (hasArgs(this.from) || hasArgs(this.to)) {
                args = ", arguments";
            }
            return [
                this.makeCode("(function() {" + pre + "\n" + idt + "for (" + body + ")" + post + "}).apply(this" + (args != null ? args : "") + ")")
            ];
        };
        return Range;
    }(Base);
    exports.Slice = Slice = function(superClass1) {
        extend1(Slice, superClass1);
        Slice.prototype.children = [
            "range"
        ];
        function Slice(range1) {
            this.range = range1;
            Slice.__super__.constructor.call(this);
        }
        Slice.prototype.compileNode = function(o) {
            var compiled, compiledText, from, fromCompiled, ref3, to, toStr;
            ref3 = this.range, to = ref3.to, from = ref3.from;
            fromCompiled = from && from.compileToFragments(o, LEVEL_PAREN) || [
                this.makeCode("0")
            ];
            if (to) {
                compiled = to.compileToFragments(o, LEVEL_PAREN);
                compiledText = fragmentsToText(compiled);
                if (!(!this.range.exclusive && +compiledText === -1)) {
                    toStr = ", " + (this.range.exclusive ? compiledText : to.isNumber() ? "" + (+compiledText + 1) : (compiled = to.compileToFragments(o, LEVEL_ACCESS), "+" + fragmentsToText(compiled) + " + 1 || 9e9"));
                }
            }
            return [
                this.makeCode(".slice(" + fragmentsToText(fromCompiled) + (toStr || "") + ")")
            ];
        };
        return Slice;
    }(Base);
    exports.Obj = Obj = function(superClass1) {
        extend1(Obj, superClass1);
        function Obj(props, generated) {
            this.generated = generated != null ? generated : false;
            this.objects = this.properties = props || [];
        }
        Obj.prototype.children = [
            "properties"
        ];
        Obj.prototype.compileNode = function(o) {
            var answer, dynamicIndex, hasDynamic, i, idt, indent, j, join, k, key, l, lastNoncom, len1, len2, len3, node, oref, prop, props, ref3, value;
            props = this.properties;
            if (this.generated) {
                for(j = 0, len1 = props.length; j < len1; j++){
                    node = props[j];
                    if (node instanceof Value) {
                        node.error("cannot have an implicit value in an implicit object");
                    }
                }
            }
            for(dynamicIndex = k = 0, len2 = props.length; k < len2; dynamicIndex = ++k){
                prop = props[dynamicIndex];
                if ((prop.variable || prop).base instanceof Parens) {
                    break;
                }
            }
            hasDynamic = dynamicIndex < props.length;
            idt = o.indent += TAB;
            lastNoncom = this.lastNonComment(this.properties);
            answer = [];
            if (hasDynamic) {
                oref = o.scope.freeVariable("obj");
                answer.push(this.makeCode("(\n" + idt + oref + " = "));
            }
            answer.push(this.makeCode("{" + (props.length === 0 || dynamicIndex === 0 ? "}" : "\n")));
            for(i = l = 0, len3 = props.length; l < len3; i = ++l){
                prop = props[i];
                if (i === dynamicIndex) {
                    if (i !== 0) {
                        answer.push(this.makeCode("\n" + idt + "}"));
                    }
                    answer.push(this.makeCode(",\n"));
                }
                join = i === props.length - 1 || i === dynamicIndex - 1 ? "" : prop === lastNoncom || prop instanceof Comment ? "\n" : ",\n";
                indent = prop instanceof Comment ? "" : idt;
                if (hasDynamic && i < dynamicIndex) {
                    indent += TAB;
                }
                if (prop instanceof Assign) {
                    if (prop.context !== "object") {
                        prop.operatorToken.error("unexpected " + prop.operatorToken.value);
                    }
                    if (prop.variable instanceof Value && prop.variable.hasProperties()) {
                        prop.variable.error("invalid object key");
                    }
                }
                if (prop instanceof Value && prop["this"]) {
                    prop = new Assign(prop.properties[0].name, prop, "object");
                }
                if (!(prop instanceof Comment)) {
                    if (i < dynamicIndex) {
                        if (!(prop instanceof Assign)) {
                            prop = new Assign(prop, prop, "object");
                        }
                    } else {
                        if (prop instanceof Assign) {
                            key = prop.variable;
                            value = prop.value;
                        } else {
                            ref3 = prop.base.cache(o), key = ref3[0], value = ref3[1];
                            if (key instanceof IdentifierLiteral) {
                                key = new PropertyName(key.value);
                            }
                        }
                        prop = new Assign(new Value(new IdentifierLiteral(oref), [
                            new Access(key)
                        ]), value);
                    }
                }
                if (indent) {
                    answer.push(this.makeCode(indent));
                }
                answer.push.apply(answer, prop.compileToFragments(o, LEVEL_TOP));
                if (join) {
                    answer.push(this.makeCode(join));
                }
            }
            if (hasDynamic) {
                answer.push(this.makeCode(",\n" + idt + oref + "\n" + this.tab + ")"));
            } else {
                if (props.length !== 0) {
                    answer.push(this.makeCode("\n" + this.tab + "}"));
                }
            }
            if (this.front && !hasDynamic) {
                return this.wrapInBraces(answer);
            } else {
                return answer;
            }
        };
        Obj.prototype.assigns = function(name) {
            var j, len1, prop, ref3;
            ref3 = this.properties;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                prop = ref3[j];
                if (prop.assigns(name)) {
                    return true;
                }
            }
            return false;
        };
        return Obj;
    }(Base);
    exports.Arr = Arr = function(superClass1) {
        extend1(Arr, superClass1);
        function Arr(objs) {
            this.objects = objs || [];
        }
        Arr.prototype.children = [
            "objects"
        ];
        Arr.prototype.compileNode = function(o) {
            var answer, compiledObjs, fragments, index, j, len1, obj;
            if (!this.objects.length) {
                return [
                    this.makeCode("[]")
                ];
            }
            o.indent += TAB;
            answer = Splat.compileSplattedArray(o, this.objects);
            if (answer.length) {
                return answer;
            }
            answer = [];
            compiledObjs = (function() {
                var j, len1, ref3, results;
                ref3 = this.objects;
                results = [];
                for(j = 0, len1 = ref3.length; j < len1; j++){
                    obj = ref3[j];
                    results.push(obj.compileToFragments(o, LEVEL_LIST));
                }
                return results;
            }).call(this);
            for(index = j = 0, len1 = compiledObjs.length; j < len1; index = ++j){
                fragments = compiledObjs[index];
                if (index) {
                    answer.push(this.makeCode(", "));
                }
                answer.push.apply(answer, fragments);
            }
            if (fragmentsToText(answer).indexOf("\n") >= 0) {
                answer.unshift(this.makeCode("[\n" + o.indent));
                answer.push(this.makeCode("\n" + this.tab + "]"));
            } else {
                answer.unshift(this.makeCode("["));
                answer.push(this.makeCode("]"));
            }
            return answer;
        };
        Arr.prototype.assigns = function(name) {
            var j, len1, obj, ref3;
            ref3 = this.objects;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                obj = ref3[j];
                if (obj.assigns(name)) {
                    return true;
                }
            }
            return false;
        };
        return Arr;
    }(Base);
    exports.Class = Class = function(superClass1) {
        extend1(Class, superClass1);
        function Class(variable1, parent1, body1) {
            this.variable = variable1;
            this.parent = parent1;
            this.body = body1 != null ? body1 : new Block;
            this.boundFuncs = [];
            this.body.classBody = true;
        }
        Class.prototype.children = [
            "variable",
            "parent",
            "body"
        ];
        Class.prototype.defaultClassVariableName = "_Class";
        Class.prototype.determineName = function() {
            var message, name, node, ref3, tail;
            if (!this.variable) {
                return this.defaultClassVariableName;
            }
            ref3 = this.variable.properties, tail = ref3[ref3.length - 1];
            node = tail ? tail instanceof Access && tail.name : this.variable.base;
            if (!(node instanceof IdentifierLiteral || node instanceof PropertyName)) {
                return this.defaultClassVariableName;
            }
            name = node.value;
            if (!tail) {
                message = isUnassignable(name);
                if (message) {
                    this.variable.error(message);
                }
            }
            if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
                return "_" + name;
            } else {
                return name;
            }
        };
        Class.prototype.setContext = function(name) {
            return this.body.traverseChildren(false, function(node) {
                if (node.classBody) {
                    return false;
                }
                if (node instanceof ThisLiteral) {
                    return node.value = name;
                } else if (node instanceof Code) {
                    if (node.bound) {
                        return node.context = name;
                    }
                }
            });
        };
        Class.prototype.addBoundFunctions = function(o) {
            var bvar, j, len1, lhs, ref3;
            ref3 = this.boundFuncs;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                bvar = ref3[j];
                lhs = new Value(new ThisLiteral, [
                    new Access(bvar)
                ]).compile(o);
                this.ctor.body.unshift(new Literal(lhs + " = " + utility("bind", o) + "(" + lhs + ", this)"));
            }
        };
        Class.prototype.addProperties = function(node, name, o) {
            var acc, assign, base, exprs, func, props;
            props = node.base.properties.slice(0);
            exprs = (function() {
                var results;
                results = [];
                while(assign = props.shift()){
                    if (assign instanceof Assign) {
                        base = assign.variable.base;
                        delete assign.context;
                        func = assign.value;
                        if (base.value === "constructor") {
                            if (this.ctor) {
                                assign.error("cannot define more than one constructor in a class");
                            }
                            if (func.bound) {
                                assign.error("cannot define a constructor as a bound function");
                            }
                            if (func instanceof Code) {
                                assign = this.ctor = func;
                            } else {
                                this.externalCtor = o.classScope.freeVariable("ctor");
                                assign = new Assign(new IdentifierLiteral(this.externalCtor), func);
                            }
                        } else {
                            if (assign.variable["this"]) {
                                func["static"] = true;
                            } else {
                                acc = base.isComplex() ? new Index(base) : new Access(base);
                                assign.variable = new Value(new IdentifierLiteral(name), [
                                    new Access(new PropertyName("prototype")),
                                    acc
                                ]);
                                if (func instanceof Code && func.bound) {
                                    this.boundFuncs.push(base);
                                    func.bound = false;
                                }
                            }
                        }
                    }
                    results.push(assign);
                }
                return results;
            }).call(this);
            return compact(exprs);
        };
        Class.prototype.walkBody = function(name, o) {
            return this.traverseChildren(false, function(_this) {
                return function(child) {
                    var cont, exps, i, j, len1, node, ref3;
                    cont = true;
                    if (child instanceof Class) {
                        return false;
                    }
                    if (child instanceof Block) {
                        ref3 = exps = child.expressions;
                        for(i = j = 0, len1 = ref3.length; j < len1; i = ++j){
                            node = ref3[i];
                            if (node instanceof Assign && node.variable.looksStatic(name)) {
                                node.value["static"] = true;
                            } else if (node instanceof Value && node.isObject(true)) {
                                cont = false;
                                exps[i] = _this.addProperties(node, name, o);
                            }
                        }
                        child.expressions = exps = flatten(exps);
                    }
                    return cont && !(child instanceof Class);
                };
            }(this));
        };
        Class.prototype.hoistDirectivePrologue = function() {
            var expressions, index, node;
            index = 0;
            expressions = this.body.expressions;
            while((node = expressions[index]) && node instanceof Comment || node instanceof Value && node.isString()){
                ++index;
            }
            return this.directives = expressions.splice(0, index);
        };
        Class.prototype.ensureConstructor = function(name) {
            if (!this.ctor) {
                this.ctor = new Code;
                if (this.externalCtor) {
                    this.ctor.body.push(new Literal(this.externalCtor + ".apply(this, arguments)"));
                } else if (this.parent) {
                    this.ctor.body.push(new Literal(name + ".__super__.constructor.apply(this, arguments)"));
                }
                this.ctor.body.makeReturn();
                this.body.expressions.unshift(this.ctor);
            }
            this.ctor.ctor = this.ctor.name = name;
            this.ctor.klass = null;
            return this.ctor.noReturn = true;
        };
        Class.prototype.compileNode = function(o) {
            var args, argumentsNode, func, jumpNode, klass, lname, name, ref3, superClass;
            if (jumpNode = this.body.jumps()) {
                jumpNode.error("Class bodies cannot contain pure statements");
            }
            if (argumentsNode = this.body.contains(isLiteralArguments)) {
                argumentsNode.error("Class bodies shouldn't reference arguments");
            }
            name = this.determineName();
            lname = new IdentifierLiteral(name);
            func = new Code([], Block.wrap([
                this.body
            ]));
            args = [];
            o.classScope = func.makeScope(o.scope);
            this.hoistDirectivePrologue();
            this.setContext(name);
            this.walkBody(name, o);
            this.ensureConstructor(name);
            this.addBoundFunctions(o);
            this.body.spaced = true;
            this.body.expressions.push(lname);
            if (this.parent) {
                superClass = new IdentifierLiteral(o.classScope.freeVariable("superClass", {
                    reserve: false
                }));
                this.body.expressions.unshift(new Extends(lname, superClass));
                func.params.push(new Param(superClass));
                args.push(this.parent);
            }
            (ref3 = this.body.expressions).unshift.apply(ref3, this.directives);
            klass = new Parens(new Call(func, args));
            if (this.variable) {
                klass = new Assign(this.variable, klass, null, {
                    moduleDeclaration: this.moduleDeclaration
                });
            }
            return klass.compileToFragments(o);
        };
        return Class;
    }(Base);
    exports.ModuleDeclaration = ModuleDeclaration = function(superClass1) {
        extend1(ModuleDeclaration, superClass1);
        function ModuleDeclaration(clause, source1) {
            this.clause = clause;
            this.source = source1;
            this.checkSource();
        }
        ModuleDeclaration.prototype.children = [
            "clause",
            "source"
        ];
        ModuleDeclaration.prototype.isStatement = YES;
        ModuleDeclaration.prototype.jumps = THIS;
        ModuleDeclaration.prototype.makeReturn = THIS;
        ModuleDeclaration.prototype.checkSource = function() {
            if (this.source != null && this.source instanceof StringWithInterpolations) {
                return this.source.error("the name of the module to be imported from must be an uninterpolated string");
            }
        };
        ModuleDeclaration.prototype.checkScope = function(o, moduleDeclarationType) {
            if (o.indent.length !== 0) {
                return this.error(moduleDeclarationType + " statements must be at top-level scope");
            }
        };
        return ModuleDeclaration;
    }(Base);
    exports.ImportDeclaration = ImportDeclaration = function(superClass1) {
        extend1(ImportDeclaration, superClass1);
        function ImportDeclaration() {
            return ImportDeclaration.__super__.constructor.apply(this, arguments);
        }
        ImportDeclaration.prototype.compileNode = function(o) {
            var code, ref3;
            this.checkScope(o, "import");
            o.importedSymbols = [];
            code = [];
            code.push(this.makeCode(this.tab + "import "));
            if (this.clause != null) {
                code.push.apply(code, this.clause.compileNode(o));
            }
            if (((ref3 = this.source) != null ? ref3.value : void 0) != null) {
                if (this.clause !== null) {
                    code.push(this.makeCode(" from "));
                }
                code.push(this.makeCode(this.source.value));
            }
            code.push(this.makeCode(";"));
            return code;
        };
        return ImportDeclaration;
    }(ModuleDeclaration);
    exports.ImportClause = ImportClause = function(superClass1) {
        extend1(ImportClause, superClass1);
        function ImportClause(defaultBinding, namedImports) {
            this.defaultBinding = defaultBinding;
            this.namedImports = namedImports;
        }
        ImportClause.prototype.children = [
            "defaultBinding",
            "namedImports"
        ];
        ImportClause.prototype.compileNode = function(o) {
            var code;
            code = [];
            if (this.defaultBinding != null) {
                code.push.apply(code, this.defaultBinding.compileNode(o));
                if (this.namedImports != null) {
                    code.push(this.makeCode(", "));
                }
            }
            if (this.namedImports != null) {
                code.push.apply(code, this.namedImports.compileNode(o));
            }
            return code;
        };
        return ImportClause;
    }(Base);
    exports.ExportDeclaration = ExportDeclaration = function(superClass1) {
        extend1(ExportDeclaration, superClass1);
        function ExportDeclaration() {
            return ExportDeclaration.__super__.constructor.apply(this, arguments);
        }
        ExportDeclaration.prototype.compileNode = function(o) {
            var code, ref3;
            this.checkScope(o, "export");
            code = [];
            code.push(this.makeCode(this.tab + "export "));
            if (this instanceof ExportDefaultDeclaration) {
                code.push(this.makeCode("default "));
            }
            if (!(this instanceof ExportDefaultDeclaration) && (this.clause instanceof Assign || this.clause instanceof Class)) {
                if (this.clause instanceof Class && !this.clause.variable) {
                    this.clause.error("anonymous classes cannot be exported");
                }
                code.push(this.makeCode("var "));
                this.clause.moduleDeclaration = "export";
            }
            if (this.clause.body != null && this.clause.body instanceof Block) {
                code = code.concat(this.clause.compileToFragments(o, LEVEL_TOP));
            } else {
                code = code.concat(this.clause.compileNode(o));
            }
            if (((ref3 = this.source) != null ? ref3.value : void 0) != null) {
                code.push(this.makeCode(" from " + this.source.value));
            }
            code.push(this.makeCode(";"));
            return code;
        };
        return ExportDeclaration;
    }(ModuleDeclaration);
    exports.ExportNamedDeclaration = ExportNamedDeclaration = function(superClass1) {
        extend1(ExportNamedDeclaration, superClass1);
        function ExportNamedDeclaration() {
            return ExportNamedDeclaration.__super__.constructor.apply(this, arguments);
        }
        return ExportNamedDeclaration;
    }(ExportDeclaration);
    exports.ExportDefaultDeclaration = ExportDefaultDeclaration = function(superClass1) {
        extend1(ExportDefaultDeclaration, superClass1);
        function ExportDefaultDeclaration() {
            return ExportDefaultDeclaration.__super__.constructor.apply(this, arguments);
        }
        return ExportDefaultDeclaration;
    }(ExportDeclaration);
    exports.ExportAllDeclaration = ExportAllDeclaration = function(superClass1) {
        extend1(ExportAllDeclaration, superClass1);
        function ExportAllDeclaration() {
            return ExportAllDeclaration.__super__.constructor.apply(this, arguments);
        }
        return ExportAllDeclaration;
    }(ExportDeclaration);
    exports.ModuleSpecifierList = ModuleSpecifierList = function(superClass1) {
        extend1(ModuleSpecifierList, superClass1);
        function ModuleSpecifierList(specifiers) {
            this.specifiers = specifiers;
        }
        ModuleSpecifierList.prototype.children = [
            "specifiers"
        ];
        ModuleSpecifierList.prototype.compileNode = function(o) {
            var code, compiledList, fragments, index, j, len1, specifier;
            code = [];
            o.indent += TAB;
            compiledList = (function() {
                var j, len1, ref3, results;
                ref3 = this.specifiers;
                results = [];
                for(j = 0, len1 = ref3.length; j < len1; j++){
                    specifier = ref3[j];
                    results.push(specifier.compileToFragments(o, LEVEL_LIST));
                }
                return results;
            }).call(this);
            if (this.specifiers.length !== 0) {
                code.push(this.makeCode("{\n" + o.indent));
                for(index = j = 0, len1 = compiledList.length; j < len1; index = ++j){
                    fragments = compiledList[index];
                    if (index) {
                        code.push(this.makeCode(",\n" + o.indent));
                    }
                    code.push.apply(code, fragments);
                }
                code.push(this.makeCode("\n}"));
            } else {
                code.push(this.makeCode("{}"));
            }
            return code;
        };
        return ModuleSpecifierList;
    }(Base);
    exports.ImportSpecifierList = ImportSpecifierList = function(superClass1) {
        extend1(ImportSpecifierList, superClass1);
        function ImportSpecifierList() {
            return ImportSpecifierList.__super__.constructor.apply(this, arguments);
        }
        return ImportSpecifierList;
    }(ModuleSpecifierList);
    exports.ExportSpecifierList = ExportSpecifierList = function(superClass1) {
        extend1(ExportSpecifierList, superClass1);
        function ExportSpecifierList() {
            return ExportSpecifierList.__super__.constructor.apply(this, arguments);
        }
        return ExportSpecifierList;
    }(ModuleSpecifierList);
    exports.ModuleSpecifier = ModuleSpecifier = function(superClass1) {
        extend1(ModuleSpecifier, superClass1);
        function ModuleSpecifier(original, alias, moduleDeclarationType1) {
            this.original = original;
            this.alias = alias;
            this.moduleDeclarationType = moduleDeclarationType1;
            this.identifier = this.alias != null ? this.alias.value : this.original.value;
        }
        ModuleSpecifier.prototype.children = [
            "original",
            "alias"
        ];
        ModuleSpecifier.prototype.compileNode = function(o) {
            var code;
            o.scope.find(this.identifier, this.moduleDeclarationType);
            code = [];
            code.push(this.makeCode(this.original.value));
            if (this.alias != null) {
                code.push(this.makeCode(" as " + this.alias.value));
            }
            return code;
        };
        return ModuleSpecifier;
    }(Base);
    exports.ImportSpecifier = ImportSpecifier = function(superClass1) {
        extend1(ImportSpecifier, superClass1);
        function ImportSpecifier(imported, local) {
            ImportSpecifier.__super__.constructor.call(this, imported, local, "import");
        }
        ImportSpecifier.prototype.compileNode = function(o) {
            var ref3;
            if ((ref3 = this.identifier, indexOf.call(o.importedSymbols, ref3) >= 0) || o.scope.check(this.identifier)) {
                this.error("'" + this.identifier + "' has already been declared");
            } else {
                o.importedSymbols.push(this.identifier);
            }
            return ImportSpecifier.__super__.compileNode.call(this, o);
        };
        return ImportSpecifier;
    }(ModuleSpecifier);
    exports.ImportDefaultSpecifier = ImportDefaultSpecifier = function(superClass1) {
        extend1(ImportDefaultSpecifier, superClass1);
        function ImportDefaultSpecifier() {
            return ImportDefaultSpecifier.__super__.constructor.apply(this, arguments);
        }
        return ImportDefaultSpecifier;
    }(ImportSpecifier);
    exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier = function(superClass1) {
        extend1(ImportNamespaceSpecifier, superClass1);
        function ImportNamespaceSpecifier() {
            return ImportNamespaceSpecifier.__super__.constructor.apply(this, arguments);
        }
        return ImportNamespaceSpecifier;
    }(ImportSpecifier);
    exports.ExportSpecifier = ExportSpecifier = function(superClass1) {
        extend1(ExportSpecifier, superClass1);
        function ExportSpecifier(local, exported) {
            ExportSpecifier.__super__.constructor.call(this, local, exported, "export");
        }
        return ExportSpecifier;
    }(ModuleSpecifier);
    exports.Assign = Assign = function(superClass1) {
        extend1(Assign, superClass1);
        function Assign(variable1, value1, context, options) {
            this.variable = variable1;
            this.value = value1;
            this.context = context;
            if (options == null) {
                options = {};
            }
            this.param = options.param, this.subpattern = options.subpattern, this.operatorToken = options.operatorToken, this.moduleDeclaration = options.moduleDeclaration;
        }
        Assign.prototype.children = [
            "variable",
            "value"
        ];
        Assign.prototype.isStatement = function(o) {
            return (o != null ? o.level : void 0) === LEVEL_TOP && this.context != null && (this.moduleDeclaration || indexOf.call(this.context, "?") >= 0);
        };
        Assign.prototype.checkAssignability = function(o, varBase) {
            if (Object.prototype.hasOwnProperty.call(o.scope.positions, varBase.value) && o.scope.variables[o.scope.positions[varBase.value]].type === "import") {
                return varBase.error("'" + varBase.value + "' is read-only");
            }
        };
        Assign.prototype.assigns = function(name) {
            return this[this.context === "object" ? "value" : "variable"].assigns(name);
        };
        Assign.prototype.unfoldSoak = function(o) {
            return unfoldSoak(o, this, "variable");
        };
        Assign.prototype.compileNode = function(o) {
            var answer, compiledName, isValue, j, name, properties, prototype, ref3, ref4, ref5, ref6, ref7, ref8, val, varBase;
            if (isValue = this.variable instanceof Value) {
                if (this.variable.isArray() || this.variable.isObject()) {
                    return this.compilePatternMatch(o);
                }
                if (this.variable.isSplice()) {
                    return this.compileSplice(o);
                }
                if ((ref3 = this.context) === "||=" || ref3 === "&&=" || ref3 === "?=") {
                    return this.compileConditional(o);
                }
                if ((ref4 = this.context) === "**=" || ref4 === "//=" || ref4 === "%%=") {
                    return this.compileSpecialMath(o);
                }
            }
            if (this.value instanceof Code) {
                if (this.value["static"]) {
                    this.value.klass = this.variable.base;
                    this.value.name = this.variable.properties[0];
                    this.value.variable = this.variable;
                } else if (((ref5 = this.variable.properties) != null ? ref5.length : void 0) >= 2) {
                    ref6 = this.variable.properties, properties = 3 <= ref6.length ? slice.call(ref6, 0, j = ref6.length - 2) : (j = 0, []), prototype = ref6[j++], name = ref6[j++];
                    if (((ref7 = prototype.name) != null ? ref7.value : void 0) === "prototype") {
                        this.value.klass = new Value(this.variable.base, properties);
                        this.value.name = name;
                        this.value.variable = this.variable;
                    }
                }
            }
            if (!this.context) {
                varBase = this.variable.unwrapAll();
                if (!varBase.isAssignable()) {
                    this.variable.error("'" + this.variable.compile(o) + "' can't be assigned");
                }
                if (!(typeof varBase.hasProperties === "function" ? varBase.hasProperties() : void 0)) {
                    if (this.moduleDeclaration) {
                        this.checkAssignability(o, varBase);
                        o.scope.add(varBase.value, this.moduleDeclaration);
                    } else if (this.param) {
                        o.scope.add(varBase.value, "var");
                    } else {
                        this.checkAssignability(o, varBase);
                        o.scope.find(varBase.value);
                    }
                }
            }
            val = this.value.compileToFragments(o, LEVEL_LIST);
            if (isValue && this.variable.base instanceof Obj) {
                this.variable.front = true;
            }
            compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
            if (this.context === "object") {
                if (ref8 = fragmentsToText(compiledName), indexOf.call(JS_FORBIDDEN, ref8) >= 0) {
                    compiledName.unshift(this.makeCode('"'));
                    compiledName.push(this.makeCode('"'));
                }
                return compiledName.concat(this.makeCode(": "), val);
            }
            answer = compiledName.concat(this.makeCode(" " + (this.context || "=") + " "), val);
            if (o.level <= LEVEL_LIST) {
                return answer;
            } else {
                return this.wrapInBraces(answer);
            }
        };
        Assign.prototype.compilePatternMatch = function(o) {
            var acc, assigns, code, defaultValue, expandedIdx, fragments, i, idx, isObject, ivar, j, len1, message, name, obj, objects, olen, ref, ref3, ref4, ref5, ref6, rest, top, val, value, vvar, vvarText;
            top = o.level === LEVEL_TOP;
            value = this.value;
            objects = this.variable.base.objects;
            if (!(olen = objects.length)) {
                code = value.compileToFragments(o);
                if (o.level >= LEVEL_OP) {
                    return this.wrapInBraces(code);
                } else {
                    return code;
                }
            }
            obj = objects[0];
            if (olen === 1 && obj instanceof Expansion) {
                obj.error("Destructuring assignment has no target");
            }
            isObject = this.variable.isObject();
            if (top && olen === 1 && !(obj instanceof Splat)) {
                defaultValue = null;
                if (obj instanceof Assign && obj.context === "object") {
                    ref3 = obj, ref4 = ref3.variable, idx = ref4.base, obj = ref3.value;
                    if (obj instanceof Assign) {
                        defaultValue = obj.value;
                        obj = obj.variable;
                    }
                } else {
                    if (obj instanceof Assign) {
                        defaultValue = obj.value;
                        obj = obj.variable;
                    }
                    idx = isObject ? obj["this"] ? obj.properties[0].name : new PropertyName(obj.unwrap().value) : new NumberLiteral(0);
                }
                acc = idx.unwrap() instanceof PropertyName;
                value = new Value(value);
                value.properties.push(new (acc ? Access : Index)(idx));
                message = isUnassignable(obj.unwrap().value);
                if (message) {
                    obj.error(message);
                }
                if (defaultValue) {
                    value = new Op("?", value, defaultValue);
                }
                return new Assign(obj, value, null, {
                    param: this.param
                }).compileToFragments(o, LEVEL_TOP);
            }
            vvar = value.compileToFragments(o, LEVEL_LIST);
            vvarText = fragmentsToText(vvar);
            assigns = [];
            expandedIdx = false;
            if (!(value.unwrap() instanceof IdentifierLiteral) || this.variable.assigns(vvarText)) {
                assigns.push([
                    this.makeCode((ref = o.scope.freeVariable("ref")) + " = ")
                ].concat(slice.call(vvar)));
                vvar = [
                    this.makeCode(ref)
                ];
                vvarText = ref;
            }
            for(i = j = 0, len1 = objects.length; j < len1; i = ++j){
                obj = objects[i];
                idx = i;
                if (!expandedIdx && obj instanceof Splat) {
                    name = obj.name.unwrap().value;
                    obj = obj.unwrap();
                    val = olen + " <= " + vvarText + ".length ? " + utility("slice", o) + ".call(" + vvarText + ", " + i;
                    if (rest = olen - i - 1) {
                        ivar = o.scope.freeVariable("i", {
                            single: true
                        });
                        val += ", " + ivar + " = " + vvarText + ".length - " + rest + ") : (" + ivar + " = " + i + ", [])";
                    } else {
                        val += ") : []";
                    }
                    val = new Literal(val);
                    expandedIdx = ivar + "++";
                } else if (!expandedIdx && obj instanceof Expansion) {
                    if (rest = olen - i - 1) {
                        if (rest === 1) {
                            expandedIdx = vvarText + ".length - 1";
                        } else {
                            ivar = o.scope.freeVariable("i", {
                                single: true
                            });
                            val = new Literal(ivar + " = " + vvarText + ".length - " + rest);
                            expandedIdx = ivar + "++";
                            assigns.push(val.compileToFragments(o, LEVEL_LIST));
                        }
                    }
                    continue;
                } else {
                    if (obj instanceof Splat || obj instanceof Expansion) {
                        obj.error("multiple splats/expansions are disallowed in an assignment");
                    }
                    defaultValue = null;
                    if (obj instanceof Assign && obj.context === "object") {
                        ref5 = obj, ref6 = ref5.variable, idx = ref6.base, obj = ref5.value;
                        if (obj instanceof Assign) {
                            defaultValue = obj.value;
                            obj = obj.variable;
                        }
                    } else {
                        if (obj instanceof Assign) {
                            defaultValue = obj.value;
                            obj = obj.variable;
                        }
                        idx = isObject ? obj["this"] ? obj.properties[0].name : new PropertyName(obj.unwrap().value) : new Literal(expandedIdx || idx);
                    }
                    name = obj.unwrap().value;
                    acc = idx.unwrap() instanceof PropertyName;
                    val = new Value(new Literal(vvarText), [
                        new (acc ? Access : Index)(idx)
                    ]);
                    if (defaultValue) {
                        val = new Op("?", val, defaultValue);
                    }
                }
                if (name != null) {
                    message = isUnassignable(name);
                    if (message) {
                        obj.error(message);
                    }
                }
                assigns.push(new Assign(obj, val, null, {
                    param: this.param,
                    subpattern: true
                }).compileToFragments(o, LEVEL_LIST));
            }
            if (!(top || this.subpattern)) {
                assigns.push(vvar);
            }
            fragments = this.joinFragmentArrays(assigns, ", ");
            if (o.level < LEVEL_LIST) {
                return fragments;
            } else {
                return this.wrapInBraces(fragments);
            }
        };
        Assign.prototype.compileConditional = function(o) {
            var fragments, left, ref3, right;
            ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
            if (!left.properties.length && left.base instanceof Literal && !(left.base instanceof ThisLiteral) && !o.scope.check(left.base.value)) {
                this.variable.error('the variable "' + left.base.value + "\" can't be assigned with " + this.context + " because it has not been declared before");
            }
            if (indexOf.call(this.context, "?") >= 0) {
                o.isExistentialEquals = true;
                return new If(new Existence(left), right, {
                    type: "if"
                }).addElse(new Assign(right, this.value, "=")).compileToFragments(o);
            } else {
                fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, "=")).compileToFragments(o);
                if (o.level <= LEVEL_LIST) {
                    return fragments;
                } else {
                    return this.wrapInBraces(fragments);
                }
            }
        };
        Assign.prototype.compileSpecialMath = function(o) {
            var left, ref3, right;
            ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
            return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
        };
        Assign.prototype.compileSplice = function(o) {
            var answer, exclusive, from, fromDecl, fromRef, name, ref3, ref4, ref5, to, valDef, valRef;
            ref3 = this.variable.properties.pop().range, from = ref3.from, to = ref3.to, exclusive = ref3.exclusive;
            name = this.variable.compile(o);
            if (from) {
                ref4 = this.cacheToCodeFragments(from.cache(o, LEVEL_OP)), fromDecl = ref4[0], fromRef = ref4[1];
            } else {
                fromDecl = fromRef = "0";
            }
            if (to) {
                if ((from != null ? from.isNumber() : void 0) && to.isNumber()) {
                    to = to.compile(o) - fromRef;
                    if (!exclusive) {
                        to += 1;
                    }
                } else {
                    to = to.compile(o, LEVEL_ACCESS) + " - " + fromRef;
                    if (!exclusive) {
                        to += " + 1";
                    }
                }
            } else {
                to = "9e9";
            }
            ref5 = this.value.cache(o, LEVEL_LIST), valDef = ref5[0], valRef = ref5[1];
            answer = [].concat(this.makeCode("[].splice.apply(" + name + ", [" + fromDecl + ", " + to + "].concat("), valDef, this.makeCode(")), "), valRef);
            if (o.level > LEVEL_TOP) {
                return this.wrapInBraces(answer);
            } else {
                return answer;
            }
        };
        return Assign;
    }(Base);
    exports.Code = Code = function(superClass1) {
        extend1(Code, superClass1);
        function Code(params, body, tag) {
            this.params = params || [];
            this.body = body || new Block;
            this.bound = tag === "boundfunc";
            this.isGenerator = !!this.body.contains(function(node) {
                return node instanceof Op && node.isYield() || node instanceof YieldReturn;
            });
        }
        Code.prototype.children = [
            "params",
            "body"
        ];
        Code.prototype.isStatement = function() {
            return !!this.ctor;
        };
        Code.prototype.jumps = NO;
        Code.prototype.makeScope = function(parentScope) {
            return new Scope(parentScope, this.body, this);
        };
        Code.prototype.compileNode = function(o) {
            var answer, boundfunc, code, exprs, i, j, k, l, len1, len2, len3, len4, len5, len6, lit, m, p, param, params, q, r, ref, ref3, ref4, ref5, ref6, ref7, ref8, splats, uniqs, val, wasEmpty, wrapper;
            if (this.bound && ((ref3 = o.scope.method) != null ? ref3.bound : void 0)) {
                this.context = o.scope.method.context;
            }
            if (this.bound && !this.context) {
                this.context = "_this";
                wrapper = new Code([
                    new Param(new IdentifierLiteral(this.context))
                ], new Block([
                    this
                ]));
                boundfunc = new Call(wrapper, [
                    new ThisLiteral
                ]);
                boundfunc.updateLocationDataIfMissing(this.locationData);
                return boundfunc.compileNode(o);
            }
            o.scope = del(o, "classScope") || this.makeScope(o.scope);
            o.scope.shared = del(o, "sharedScope");
            o.indent += TAB;
            delete o.bare;
            delete o.isExistentialEquals;
            params = [];
            exprs = [];
            ref4 = this.params;
            for(j = 0, len1 = ref4.length; j < len1; j++){
                param = ref4[j];
                if (!(param instanceof Expansion)) {
                    o.scope.parameter(param.asReference(o));
                }
            }
            ref5 = this.params;
            for(k = 0, len2 = ref5.length; k < len2; k++){
                param = ref5[k];
                if (!(param.splat || param instanceof Expansion)) {
                    continue;
                }
                ref6 = this.params;
                for(l = 0, len3 = ref6.length; l < len3; l++){
                    p = ref6[l];
                    if (!(p instanceof Expansion) && p.name.value) {
                        o.scope.add(p.name.value, "var", true);
                    }
                }
                splats = new Assign(new Value(new Arr((function() {
                    var len4, m, ref7, results;
                    ref7 = this.params;
                    results = [];
                    for(m = 0, len4 = ref7.length; m < len4; m++){
                        p = ref7[m];
                        results.push(p.asReference(o));
                    }
                    return results;
                }).call(this))), new Value(new IdentifierLiteral("arguments")));
                break;
            }
            ref7 = this.params;
            for(m = 0, len4 = ref7.length; m < len4; m++){
                param = ref7[m];
                if (param.isComplex()) {
                    val = ref = param.asReference(o);
                    if (param.value) {
                        val = new Op("?", ref, param.value);
                    }
                    exprs.push(new Assign(new Value(param.name), val, "=", {
                        param: true
                    }));
                } else {
                    ref = param;
                    if (param.value) {
                        lit = new Literal(ref.name.value + " == null");
                        val = new Assign(new Value(param.name), param.value, "=");
                        exprs.push(new If(lit, val));
                    }
                }
                if (!splats) {
                    params.push(ref);
                }
            }
            wasEmpty = this.body.isEmpty();
            if (splats) {
                exprs.unshift(splats);
            }
            if (exprs.length) {
                (ref8 = this.body.expressions).unshift.apply(ref8, exprs);
            }
            for(i = q = 0, len5 = params.length; q < len5; i = ++q){
                p = params[i];
                params[i] = p.compileToFragments(o);
                o.scope.parameter(fragmentsToText(params[i]));
            }
            uniqs = [];
            this.eachParamName(function(name, node) {
                if (indexOf.call(uniqs, name) >= 0) {
                    node.error("multiple parameters named " + name);
                }
                return uniqs.push(name);
            });
            if (!(wasEmpty || this.noReturn)) {
                this.body.makeReturn();
            }
            code = "function";
            if (this.isGenerator) {
                code += "*";
            }
            if (this.ctor) {
                code += " " + this.name;
            }
            code += "(";
            answer = [
                this.makeCode(code)
            ];
            for(i = r = 0, len6 = params.length; r < len6; i = ++r){
                p = params[i];
                if (i) {
                    answer.push(this.makeCode(", "));
                }
                answer.push.apply(answer, p);
            }
            answer.push(this.makeCode(") {"));
            if (!this.body.isEmpty()) {
                answer = answer.concat(this.makeCode("\n"), this.body.compileWithDeclarations(o), this.makeCode("\n" + this.tab));
            }
            answer.push(this.makeCode("}"));
            if (this.ctor) {
                return [
                    this.makeCode(this.tab)
                ].concat(slice.call(answer));
            }
            if (this.front || o.level >= LEVEL_ACCESS) {
                return this.wrapInBraces(answer);
            } else {
                return answer;
            }
        };
        Code.prototype.eachParamName = function(iterator) {
            var j, len1, param, ref3, results;
            ref3 = this.params;
            results = [];
            for(j = 0, len1 = ref3.length; j < len1; j++){
                param = ref3[j];
                results.push(param.eachName(iterator));
            }
            return results;
        };
        Code.prototype.traverseChildren = function(crossScope, func) {
            if (crossScope) {
                return Code.__super__.traverseChildren.call(this, crossScope, func);
            }
        };
        return Code;
    }(Base);
    exports.Param = Param = function(superClass1) {
        extend1(Param, superClass1);
        function Param(name1, value1, splat) {
            var message, token;
            this.name = name1;
            this.value = value1;
            this.splat = splat;
            message = isUnassignable(this.name.unwrapAll().value);
            if (message) {
                this.name.error(message);
            }
            if (this.name instanceof Obj && this.name.generated) {
                token = this.name.objects[0].operatorToken;
                token.error("unexpected " + token.value);
            }
        }
        Param.prototype.children = [
            "name",
            "value"
        ];
        Param.prototype.compileToFragments = function(o) {
            return this.name.compileToFragments(o, LEVEL_LIST);
        };
        Param.prototype.asReference = function(o) {
            var name, node;
            if (this.reference) {
                return this.reference;
            }
            node = this.name;
            if (node["this"]) {
                name = node.properties[0].name.value;
                if (indexOf.call(JS_FORBIDDEN, name) >= 0) {
                    name = "_" + name;
                }
                node = new IdentifierLiteral(o.scope.freeVariable(name));
            } else if (node.isComplex()) {
                node = new IdentifierLiteral(o.scope.freeVariable("arg"));
            }
            node = new Value(node);
            if (this.splat) {
                node = new Splat(node);
            }
            node.updateLocationDataIfMissing(this.locationData);
            return this.reference = node;
        };
        Param.prototype.isComplex = function() {
            return this.name.isComplex();
        };
        Param.prototype.eachName = function(iterator, name) {
            var atParam, j, len1, node, obj, ref3, ref4;
            if (name == null) {
                name = this.name;
            }
            atParam = function(obj) {
                return iterator("@" + obj.properties[0].name.value, obj);
            };
            if (name instanceof Literal) {
                return iterator(name.value, name);
            }
            if (name instanceof Value) {
                return atParam(name);
            }
            ref4 = (ref3 = name.objects) != null ? ref3 : [];
            for(j = 0, len1 = ref4.length; j < len1; j++){
                obj = ref4[j];
                if (obj instanceof Assign && obj.context == null) {
                    obj = obj.variable;
                }
                if (obj instanceof Assign) {
                    if (obj.value instanceof Assign) {
                        obj = obj.value;
                    }
                    this.eachName(iterator, obj.value.unwrap());
                } else if (obj instanceof Splat) {
                    node = obj.name.unwrap();
                    iterator(node.value, node);
                } else if (obj instanceof Value) {
                    if (obj.isArray() || obj.isObject()) {
                        this.eachName(iterator, obj.base);
                    } else if (obj["this"]) {
                        atParam(obj);
                    } else {
                        iterator(obj.base.value, obj.base);
                    }
                } else if (!(obj instanceof Expansion)) {
                    obj.error("illegal parameter " + obj.compile());
                }
            }
        };
        return Param;
    }(Base);
    exports.Splat = Splat = function(superClass1) {
        extend1(Splat, superClass1);
        Splat.prototype.children = [
            "name"
        ];
        Splat.prototype.isAssignable = YES;
        function Splat(name) {
            this.name = name.compile ? name : new Literal(name);
        }
        Splat.prototype.assigns = function(name) {
            return this.name.assigns(name);
        };
        Splat.prototype.compileToFragments = function(o) {
            return this.name.compileToFragments(o);
        };
        Splat.prototype.unwrap = function() {
            return this.name;
        };
        Splat.compileSplattedArray = function(o, list, apply) {
            var args, base, compiledNode, concatPart, fragments, i, index, j, last, len1, node;
            index = -1;
            while((node = list[++index]) && !(node instanceof Splat)){
                continue;
            }
            if (index >= list.length) {
                return [];
            }
            if (list.length === 1) {
                node = list[0];
                fragments = node.compileToFragments(o, LEVEL_LIST);
                if (apply) {
                    return fragments;
                }
                return [].concat(node.makeCode(utility("slice", o) + ".call("), fragments, node.makeCode(")"));
            }
            args = list.slice(index);
            for(i = j = 0, len1 = args.length; j < len1; i = ++j){
                node = args[i];
                compiledNode = node.compileToFragments(o, LEVEL_LIST);
                args[i] = node instanceof Splat ? [].concat(node.makeCode(utility("slice", o) + ".call("), compiledNode, node.makeCode(")")) : [].concat(node.makeCode("["), compiledNode, node.makeCode("]"));
            }
            if (index === 0) {
                node = list[0];
                concatPart = node.joinFragmentArrays(args.slice(1), ", ");
                return args[0].concat(node.makeCode(".concat("), concatPart, node.makeCode(")"));
            }
            base = function() {
                var k, len2, ref3, results;
                ref3 = list.slice(0, index);
                results = [];
                for(k = 0, len2 = ref3.length; k < len2; k++){
                    node = ref3[k];
                    results.push(node.compileToFragments(o, LEVEL_LIST));
                }
                return results;
            }();
            base = list[0].joinFragmentArrays(base, ", ");
            concatPart = list[index].joinFragmentArrays(args, ", ");
            last = list[list.length - 1];
            return [].concat(list[0].makeCode("["), base, list[index].makeCode("].concat("), concatPart, last.makeCode(")"));
        };
        return Splat;
    }(Base);
    exports.Expansion = Expansion = function(superClass1) {
        extend1(Expansion, superClass1);
        function Expansion() {
            return Expansion.__super__.constructor.apply(this, arguments);
        }
        Expansion.prototype.isComplex = NO;
        Expansion.prototype.compileNode = function(o) {
            return this.error("Expansion must be used inside a destructuring assignment or parameter list");
        };
        Expansion.prototype.asReference = function(o) {
            return this;
        };
        Expansion.prototype.eachName = function(iterator) {};
        return Expansion;
    }(Base);
    exports.While = While = function(superClass1) {
        extend1(While, superClass1);
        function While(condition, options) {
            this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;
            this.guard = options != null ? options.guard : void 0;
        }
        While.prototype.children = [
            "condition",
            "guard",
            "body"
        ];
        While.prototype.isStatement = YES;
        While.prototype.makeReturn = function(res) {
            if (res) {
                return While.__super__.makeReturn.apply(this, arguments);
            } else {
                this.returns = !this.jumps({
                    loop: true
                });
                return this;
            }
        };
        While.prototype.addBody = function(body1) {
            this.body = body1;
            return this;
        };
        While.prototype.jumps = function() {
            var expressions, j, jumpNode, len1, node;
            expressions = this.body.expressions;
            if (!expressions.length) {
                return false;
            }
            for(j = 0, len1 = expressions.length; j < len1; j++){
                node = expressions[j];
                if (jumpNode = node.jumps({
                    loop: true
                })) {
                    return jumpNode;
                }
            }
            return false;
        };
        While.prototype.compileNode = function(o) {
            var answer, body, rvar, set;
            o.indent += TAB;
            set = "";
            body = this.body;
            if (body.isEmpty()) {
                body = this.makeCode("");
            } else {
                if (this.returns) {
                    body.makeReturn(rvar = o.scope.freeVariable("results"));
                    set = "" + this.tab + rvar + " = [];\n";
                }
                if (this.guard) {
                    if (body.expressions.length > 1) {
                        body.expressions.unshift(new If(new Parens(this.guard).invert(), new StatementLiteral("continue")));
                    } else {
                        if (this.guard) {
                            body = Block.wrap([
                                new If(this.guard, body)
                            ]);
                        }
                    }
                }
                body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab));
            }
            answer = [].concat(this.makeCode(set + this.tab + "while ("), this.condition.compileToFragments(o, LEVEL_PAREN), this.makeCode(") {"), body, this.makeCode("}"));
            if (this.returns) {
                answer.push(this.makeCode("\n" + this.tab + "return " + rvar + ";"));
            }
            return answer;
        };
        return While;
    }(Base);
    exports.Op = Op = function(superClass1) {
        var CONVERSIONS, INVERSIONS;
        extend1(Op, superClass1);
        function Op(op, first, second, flip) {
            if (op === "in") {
                return new In(first, second);
            }
            if (op === "do") {
                return this.generateDo(first);
            }
            if (op === "new") {
                if (first instanceof Call && !first["do"] && !first.isNew) {
                    return first.newInstance();
                }
                if (first instanceof Code && first.bound || first["do"]) {
                    first = new Parens(first);
                }
            }
            this.operator = CONVERSIONS[op] || op;
            this.first = first;
            this.second = second;
            this.flip = !!flip;
            return this;
        }
        CONVERSIONS = {
            "==": "===",
            "!=": "!==",
            "of": "in",
            "yieldfrom": "yield*"
        };
        INVERSIONS = {
            "!==": "===",
            "===": "!=="
        };
        Op.prototype.children = [
            "first",
            "second"
        ];
        Op.prototype.isNumber = function() {
            var ref3;
            return this.isUnary() && ((ref3 = this.operator) === "+" || ref3 === "-") && this.first instanceof Value && this.first.isNumber();
        };
        Op.prototype.isYield = function() {
            var ref3;
            return (ref3 = this.operator) === "yield" || ref3 === "yield*";
        };
        Op.prototype.isUnary = function() {
            return !this.second;
        };
        Op.prototype.isComplex = function() {
            return !this.isNumber();
        };
        Op.prototype.isChainable = function() {
            var ref3;
            return (ref3 = this.operator) === "<" || ref3 === ">" || ref3 === ">=" || ref3 === "<=" || ref3 === "===" || ref3 === "!==";
        };
        Op.prototype.invert = function() {
            var allInvertable, curr, fst, op, ref3;
            if (this.isChainable() && this.first.isChainable()) {
                allInvertable = true;
                curr = this;
                while(curr && curr.operator){
                    allInvertable && (allInvertable = curr.operator in INVERSIONS);
                    curr = curr.first;
                }
                if (!allInvertable) {
                    return new Parens(this).invert();
                }
                curr = this;
                while(curr && curr.operator){
                    curr.invert = !curr.invert;
                    curr.operator = INVERSIONS[curr.operator];
                    curr = curr.first;
                }
                return this;
            } else if (op = INVERSIONS[this.operator]) {
                this.operator = op;
                if (this.first.unwrap() instanceof Op) {
                    this.first.invert();
                }
                return this;
            } else if (this.second) {
                return new Parens(this).invert();
            } else if (this.operator === "!" && (fst = this.first.unwrap()) instanceof Op && ((ref3 = fst.operator) === "!" || ref3 === "in" || ref3 === "instanceof")) {
                return fst;
            } else {
                return new Op("!", this);
            }
        };
        Op.prototype.unfoldSoak = function(o) {
            var ref3;
            return ((ref3 = this.operator) === "++" || ref3 === "--" || ref3 === "delete") && unfoldSoak(o, this, "first");
        };
        Op.prototype.generateDo = function(exp) {
            var call, func, j, len1, param, passedParams, ref, ref3;
            passedParams = [];
            func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
            ref3 = func.params || [];
            for(j = 0, len1 = ref3.length; j < len1; j++){
                param = ref3[j];
                if (param.value) {
                    passedParams.push(param.value);
                    delete param.value;
                } else {
                    passedParams.push(param);
                }
            }
            call = new Call(exp, passedParams);
            call["do"] = true;
            return call;
        };
        Op.prototype.compileNode = function(o) {
            var answer, isChain, lhs, message, ref3, rhs;
            isChain = this.isChainable() && this.first.isChainable();
            if (!isChain) {
                this.first.front = this.front;
            }
            if (this.operator === "delete" && o.scope.check(this.first.unwrapAll().value)) {
                this.error("delete operand may not be argument or var");
            }
            if ((ref3 = this.operator) === "--" || ref3 === "++") {
                message = isUnassignable(this.first.unwrapAll().value);
                if (message) {
                    this.first.error(message);
                }
            }
            if (this.isYield()) {
                return this.compileYield(o);
            }
            if (this.isUnary()) {
                return this.compileUnary(o);
            }
            if (isChain) {
                return this.compileChain(o);
            }
            switch(this.operator){
                case "?":
                    return this.compileExistence(o);
                case "**":
                    return this.compilePower(o);
                case "//":
                    return this.compileFloorDivision(o);
                case "%%":
                    return this.compileModulo(o);
                default:
                    lhs = this.first.compileToFragments(o, LEVEL_OP);
                    rhs = this.second.compileToFragments(o, LEVEL_OP);
                    answer = [].concat(lhs, this.makeCode(" " + this.operator + " "), rhs);
                    if (o.level <= LEVEL_OP) {
                        return answer;
                    } else {
                        return this.wrapInBraces(answer);
                    }
            }
        };
        Op.prototype.compileChain = function(o) {
            var fragments, fst, ref3, shared;
            ref3 = this.first.second.cache(o), this.first.second = ref3[0], shared = ref3[1];
            fst = this.first.compileToFragments(o, LEVEL_OP);
            fragments = fst.concat(this.makeCode(" " + (this.invert ? "&&" : "||") + " "), shared.compileToFragments(o), this.makeCode(" " + this.operator + " "), this.second.compileToFragments(o, LEVEL_OP));
            return this.wrapInBraces(fragments);
        };
        Op.prototype.compileExistence = function(o) {
            var fst, ref;
            if (this.first.isComplex()) {
                ref = new IdentifierLiteral(o.scope.freeVariable("ref"));
                fst = new Parens(new Assign(ref, this.first));
            } else {
                fst = this.first;
                ref = fst;
            }
            return new If(new Existence(fst), ref, {
                type: "if"
            }).addElse(this.second).compileToFragments(o);
        };
        Op.prototype.compileUnary = function(o) {
            var op, parts, plusMinus;
            parts = [];
            op = this.operator;
            parts.push([
                this.makeCode(op)
            ]);
            if (op === "!" && this.first instanceof Existence) {
                this.first.negated = !this.first.negated;
                return this.first.compileToFragments(o);
            }
            if (o.level >= LEVEL_ACCESS) {
                return new Parens(this).compileToFragments(o);
            }
            plusMinus = op === "+" || op === "-";
            if (op === "new" || op === "typeof" || op === "delete" || plusMinus && this.first instanceof Op && this.first.operator === op) {
                parts.push([
                    this.makeCode(" ")
                ]);
            }
            if (plusMinus && this.first instanceof Op || op === "new" && this.first.isStatement(o)) {
                this.first = new Parens(this.first);
            }
            parts.push(this.first.compileToFragments(o, LEVEL_OP));
            if (this.flip) {
                parts.reverse();
            }
            return this.joinFragmentArrays(parts, "");
        };
        Op.prototype.compileYield = function(o) {
            var op, parts, ref3;
            parts = [];
            op = this.operator;
            if (o.scope.parent == null) {
                this.error("yield can only occur inside functions");
            }
            if (indexOf.call(Object.keys(this.first), "expression") >= 0 && !(this.first instanceof Throw)) {
                if (this.first.expression != null) {
                    parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
                }
            } else {
                if (o.level >= LEVEL_PAREN) {
                    parts.push([
                        this.makeCode("(")
                    ]);
                }
                parts.push([
                    this.makeCode(op)
                ]);
                if (((ref3 = this.first.base) != null ? ref3.value : void 0) !== "") {
                    parts.push([
                        this.makeCode(" ")
                    ]);
                }
                parts.push(this.first.compileToFragments(o, LEVEL_OP));
                if (o.level >= LEVEL_PAREN) {
                    parts.push([
                        this.makeCode(")")
                    ]);
                }
            }
            return this.joinFragmentArrays(parts, "");
        };
        Op.prototype.compilePower = function(o) {
            var pow;
            pow = new Value(new IdentifierLiteral("Math"), [
                new Access(new PropertyName("pow"))
            ]);
            return new Call(pow, [
                this.first,
                this.second
            ]).compileToFragments(o);
        };
        Op.prototype.compileFloorDivision = function(o) {
            var div, floor, second;
            floor = new Value(new IdentifierLiteral("Math"), [
                new Access(new PropertyName("floor"))
            ]);
            second = this.second.isComplex() ? new Parens(this.second) : this.second;
            div = new Op("/", this.first, second);
            return new Call(floor, [
                div
            ]).compileToFragments(o);
        };
        Op.prototype.compileModulo = function(o) {
            var mod;
            mod = new Value(new Literal(utility("modulo", o)));
            return new Call(mod, [
                this.first,
                this.second
            ]).compileToFragments(o);
        };
        Op.prototype.toString = function(idt) {
            return Op.__super__.toString.call(this, idt, this.constructor.name + " " + this.operator);
        };
        return Op;
    }(Base);
    exports.In = In = function(superClass1) {
        extend1(In, superClass1);
        function In(object, array) {
            this.object = object;
            this.array = array;
        }
        In.prototype.children = [
            "object",
            "array"
        ];
        In.prototype.invert = NEGATE;
        In.prototype.compileNode = function(o) {
            var hasSplat, j, len1, obj, ref3;
            if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {
                ref3 = this.array.base.objects;
                for(j = 0, len1 = ref3.length; j < len1; j++){
                    obj = ref3[j];
                    if (!(obj instanceof Splat)) {
                        continue;
                    }
                    hasSplat = true;
                    break;
                }
                if (!hasSplat) {
                    return this.compileOrTest(o);
                }
            }
            return this.compileLoopTest(o);
        };
        In.prototype.compileOrTest = function(o) {
            var cmp, cnj, i, item, j, len1, ref, ref3, ref4, ref5, sub, tests;
            ref3 = this.object.cache(o, LEVEL_OP), sub = ref3[0], ref = ref3[1];
            ref4 = this.negated ? [
                " !== ",
                " && "
            ] : [
                " === ",
                " || "
            ], cmp = ref4[0], cnj = ref4[1];
            tests = [];
            ref5 = this.array.base.objects;
            for(i = j = 0, len1 = ref5.length; j < len1; i = ++j){
                item = ref5[i];
                if (i) {
                    tests.push(this.makeCode(cnj));
                }
                tests = tests.concat(i ? ref : sub, this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
            }
            if (o.level < LEVEL_OP) {
                return tests;
            } else {
                return this.wrapInBraces(tests);
            }
        };
        In.prototype.compileLoopTest = function(o) {
            var fragments, ref, ref3, sub;
            ref3 = this.object.cache(o, LEVEL_LIST), sub = ref3[0], ref = ref3[1];
            fragments = [].concat(this.makeCode(utility("indexOf", o) + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? "< 0" : ">= 0")));
            if (fragmentsToText(sub) === fragmentsToText(ref)) {
                return fragments;
            }
            fragments = sub.concat(this.makeCode(", "), fragments);
            if (o.level < LEVEL_LIST) {
                return fragments;
            } else {
                return this.wrapInBraces(fragments);
            }
        };
        In.prototype.toString = function(idt) {
            return In.__super__.toString.call(this, idt, this.constructor.name + (this.negated ? "!" : ""));
        };
        return In;
    }(Base);
    exports.Try = Try = function(superClass1) {
        extend1(Try, superClass1);
        function Try(attempt, errorVariable, recovery, ensure) {
            this.attempt = attempt;
            this.errorVariable = errorVariable;
            this.recovery = recovery;
            this.ensure = ensure;
        }
        Try.prototype.children = [
            "attempt",
            "recovery",
            "ensure"
        ];
        Try.prototype.isStatement = YES;
        Try.prototype.jumps = function(o) {
            var ref3;
            return this.attempt.jumps(o) || ((ref3 = this.recovery) != null ? ref3.jumps(o) : void 0);
        };
        Try.prototype.makeReturn = function(res) {
            if (this.attempt) {
                this.attempt = this.attempt.makeReturn(res);
            }
            if (this.recovery) {
                this.recovery = this.recovery.makeReturn(res);
            }
            return this;
        };
        Try.prototype.compileNode = function(o) {
            var catchPart, ensurePart, generatedErrorVariableName, message, placeholder, tryPart;
            o.indent += TAB;
            tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
            catchPart = this.recovery ? (generatedErrorVariableName = o.scope.freeVariable("error", {
                reserve: false
            }), placeholder = new IdentifierLiteral(generatedErrorVariableName), this.errorVariable ? (message = isUnassignable(this.errorVariable.unwrapAll().value), message ? this.errorVariable.error(message) : void 0, this.recovery.unshift(new Assign(this.errorVariable, placeholder))) : void 0, [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") {\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}"))) : !(this.ensure || this.recovery) ? (generatedErrorVariableName = o.scope.freeVariable("error", {
                reserve: false
            }), [
                this.makeCode(" catch (" + generatedErrorVariableName + ") {}")
            ]) : [];
            ensurePart = this.ensure ? [].concat(this.makeCode(" finally {\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}")) : [];
            return [].concat(this.makeCode(this.tab + "try {\n"), tryPart, this.makeCode("\n" + this.tab + "}"), catchPart, ensurePart);
        };
        return Try;
    }(Base);
    exports.Throw = Throw = function(superClass1) {
        extend1(Throw, superClass1);
        function Throw(expression) {
            this.expression = expression;
        }
        Throw.prototype.children = [
            "expression"
        ];
        Throw.prototype.isStatement = YES;
        Throw.prototype.jumps = NO;
        Throw.prototype.makeReturn = THIS;
        Throw.prototype.compileNode = function(o) {
            return [].concat(this.makeCode(this.tab + "throw "), this.expression.compileToFragments(o), this.makeCode(";"));
        };
        return Throw;
    }(Base);
    exports.Existence = Existence = function(superClass1) {
        extend1(Existence, superClass1);
        function Existence(expression) {
            this.expression = expression;
        }
        Existence.prototype.children = [
            "expression"
        ];
        Existence.prototype.invert = NEGATE;
        Existence.prototype.compileNode = function(o) {
            var cmp, cnj, code, ref3;
            this.expression.front = this.front;
            code = this.expression.compile(o, LEVEL_OP);
            if (this.expression.unwrap() instanceof IdentifierLiteral && !o.scope.check(code)) {
                ref3 = this.negated ? [
                    "===",
                    "||"
                ] : [
                    "!==",
                    "&&"
                ], cmp = ref3[0], cnj = ref3[1];
                code = "typeof " + code + " " + cmp + ' "undefined" ' + cnj + " " + code + " " + cmp + " null";
            } else {
                code = code + " " + (this.negated ? "==" : "!=") + " null";
            }
            return [
                this.makeCode(o.level <= LEVEL_COND ? code : "(" + code + ")")
            ];
        };
        return Existence;
    }(Base);
    exports.Parens = Parens = function(superClass1) {
        extend1(Parens, superClass1);
        function Parens(body1) {
            this.body = body1;
        }
        Parens.prototype.children = [
            "body"
        ];
        Parens.prototype.unwrap = function() {
            return this.body;
        };
        Parens.prototype.isComplex = function() {
            return this.body.isComplex();
        };
        Parens.prototype.compileNode = function(o) {
            var bare, expr, fragments;
            expr = this.body.unwrap();
            if (expr instanceof Value && expr.isAtomic()) {
                expr.front = this.front;
                return expr.compileToFragments(o);
            }
            fragments = expr.compileToFragments(o, LEVEL_PAREN);
            bare = o.level < LEVEL_OP && (expr instanceof Op || expr instanceof Call || expr instanceof For && expr.returns) && (o.level < LEVEL_COND || fragments.length <= 3);
            if (bare) {
                return fragments;
            } else {
                return this.wrapInBraces(fragments);
            }
        };
        return Parens;
    }(Base);
    exports.StringWithInterpolations = StringWithInterpolations = function(superClass1) {
        extend1(StringWithInterpolations, superClass1);
        function StringWithInterpolations() {
            return StringWithInterpolations.__super__.constructor.apply(this, arguments);
        }
        StringWithInterpolations.prototype.compileNode = function(o) {
            var element, elements, expr, fragments, j, len1, value;
            if (!o.inTaggedTemplateCall) {
                return StringWithInterpolations.__super__.compileNode.apply(this, arguments);
            }
            expr = this.body.unwrap();
            elements = [];
            expr.traverseChildren(false, function(node) {
                if (node instanceof StringLiteral) {
                    elements.push(node);
                    return true;
                } else if (node instanceof Parens) {
                    elements.push(node);
                    return false;
                }
                return true;
            });
            fragments = [];
            fragments.push(this.makeCode("`"));
            for(j = 0, len1 = elements.length; j < len1; j++){
                element = elements[j];
                if (element instanceof StringLiteral) {
                    value = element.value.slice(1, -1);
                    value = value.replace(/(\\*)(`|\$\{)/g, function(match, backslashes, toBeEscaped) {
                        if (backslashes.length % 2 === 0) {
                            return backslashes + "\\" + toBeEscaped;
                        } else {
                            return match;
                        }
                    });
                    fragments.push(this.makeCode(value));
                } else {
                    fragments.push(this.makeCode("${"));
                    fragments.push.apply(fragments, element.compileToFragments(o, LEVEL_PAREN));
                    fragments.push(this.makeCode("}"));
                }
            }
            fragments.push(this.makeCode("`"));
            return fragments;
        };
        return StringWithInterpolations;
    }(Parens);
    exports.For = For = function(superClass1) {
        extend1(For, superClass1);
        function For(body, source) {
            var ref3;
            this.source = source.source, this.guard = source.guard, this.step = source.step, this.name = source.name, this.index = source.index;
            this.body = Block.wrap([
                body
            ]);
            this.own = !!source.own;
            this.object = !!source.object;
            this.from = !!source.from;
            if (this.from && this.index) {
                this.index.error("cannot use index with for-from");
            }
            if (this.own && !this.object) {
                source.ownTag.error("cannot use own with for-" + (this.from ? "from" : "in"));
            }
            if (this.object) {
                ref3 = [
                    this.index,
                    this.name
                ], this.name = ref3[0], this.index = ref3[1];
            }
            if (this.index instanceof Value && !this.index.isAssignable()) {
                this.index.error("index cannot be a pattern matching expression");
            }
            this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length && !this.from;
            this.pattern = this.name instanceof Value;
            if (this.range && this.index) {
                this.index.error("indexes do not apply to range loops");
            }
            if (this.range && this.pattern) {
                this.name.error("cannot pattern match over range loops");
            }
            this.returns = false;
        }
        For.prototype.children = [
            "body",
            "source",
            "guard",
            "step"
        ];
        For.prototype.compileNode = function(o) {
            var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, defPartFragments, down, forPartFragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, last, lvar, name, namePart, ref, ref3, ref4, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart;
            body = Block.wrap([
                this.body
            ]);
            ref3 = body.expressions, last = ref3[ref3.length - 1];
            if ((last != null ? last.jumps() : void 0) instanceof Return) {
                this.returns = false;
            }
            source = this.range ? this.source.base : this.source;
            scope = o.scope;
            if (!this.pattern) {
                name = this.name && this.name.compile(o, LEVEL_LIST);
            }
            index = this.index && this.index.compile(o, LEVEL_LIST);
            if (name && !this.pattern) {
                scope.find(name);
            }
            if (index && !(this.index instanceof Value)) {
                scope.find(index);
            }
            if (this.returns) {
                rvar = scope.freeVariable("results");
            }
            if (this.from) {
                if (this.pattern) {
                    ivar = scope.freeVariable("x", {
                        single: true
                    });
                }
            } else {
                ivar = this.object && index || scope.freeVariable("i", {
                    single: true
                });
            }
            kvar = (this.range || this.from) && name || index || ivar;
            kvarAssign = kvar !== ivar ? kvar + " = " : "";
            if (this.step && !this.range) {
                ref4 = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST, isComplexOrAssignable)), step = ref4[0], stepVar = ref4[1];
                if (this.step.isNumber()) {
                    stepNum = Number(stepVar);
                }
            }
            if (this.pattern) {
                name = ivar;
            }
            varPart = "";
            guardPart = "";
            defPart = "";
            idt1 = this.tab + TAB;
            if (this.range) {
                forPartFragments = source.compileToFragments(merge(o, {
                    index: ivar,
                    name: name,
                    step: this.step,
                    isComplex: isComplexOrAssignable
                }));
            } else {
                svar = this.source.compile(o, LEVEL_LIST);
                if ((name || this.own) && !(this.source.unwrap() instanceof IdentifierLiteral)) {
                    defPart += "" + this.tab + (ref = scope.freeVariable("ref")) + " = " + svar + ";\n";
                    svar = ref;
                }
                if (name && !this.pattern && !this.from) {
                    namePart = name + " = " + svar + "[" + kvar + "]";
                }
                if (!this.object && !this.from) {
                    if (step !== stepVar) {
                        defPart += "" + this.tab + step + ";\n";
                    }
                    down = stepNum < 0;
                    if (!(this.step && stepNum != null && down)) {
                        lvar = scope.freeVariable("len");
                    }
                    declare = "" + kvarAssign + ivar + " = 0, " + lvar + " = " + svar + ".length";
                    declareDown = "" + kvarAssign + ivar + " = " + svar + ".length - 1";
                    compare = ivar + " < " + lvar;
                    compareDown = ivar + " >= 0";
                    if (this.step) {
                        if (stepNum != null) {
                            if (down) {
                                compare = compareDown;
                                declare = declareDown;
                            }
                        } else {
                            compare = stepVar + " > 0 ? " + compare + " : " + compareDown;
                            declare = "(" + stepVar + " > 0 ? (" + declare + ") : " + declareDown + ")";
                        }
                        increment = ivar + " += " + stepVar;
                    } else {
                        increment = "" + (kvar !== ivar ? "++" + ivar : ivar + "++");
                    }
                    forPartFragments = [
                        this.makeCode(declare + "; " + compare + "; " + kvarAssign + increment)
                    ];
                }
            }
            if (this.returns) {
                resultPart = "" + this.tab + rvar + " = [];\n";
                returnResult = "\n" + this.tab + "return " + rvar + ";";
                body.makeReturn(rvar);
            }
            if (this.guard) {
                if (body.expressions.length > 1) {
                    body.expressions.unshift(new If(new Parens(this.guard).invert(), new StatementLiteral("continue")));
                } else {
                    if (this.guard) {
                        body = Block.wrap([
                            new If(this.guard, body)
                        ]);
                    }
                }
            }
            if (this.pattern) {
                body.expressions.unshift(new Assign(this.name, this.from ? new IdentifierLiteral(kvar) : new Literal(svar + "[" + kvar + "]")));
            }
            defPartFragments = [].concat(this.makeCode(defPart), this.pluckDirectCall(o, body));
            if (namePart) {
                varPart = "\n" + idt1 + namePart + ";";
            }
            if (this.object) {
                forPartFragments = [
                    this.makeCode(kvar + " in " + svar)
                ];
                if (this.own) {
                    guardPart = "\n" + idt1 + "if (!" + utility("hasProp", o) + ".call(" + svar + ", " + kvar + ")) continue;";
                }
            } else if (this.from) {
                forPartFragments = [
                    this.makeCode(kvar + " of " + svar)
                ];
            }
            bodyFragments = body.compileToFragments(merge(o, {
                indent: idt1
            }), LEVEL_TOP);
            if (bodyFragments && bodyFragments.length > 0) {
                bodyFragments = [].concat(this.makeCode("\n"), bodyFragments, this.makeCode("\n"));
            }
            return [].concat(defPartFragments, this.makeCode("" + (resultPart || "") + this.tab + "for ("), forPartFragments, this.makeCode(") {" + guardPart + varPart), bodyFragments, this.makeCode(this.tab + "}" + (returnResult || "")));
        };
        For.prototype.pluckDirectCall = function(o, body) {
            var base, defs, expr, fn, idx, j, len1, ref, ref3, ref4, ref5, ref6, ref7, ref8, ref9, val;
            defs = [];
            ref3 = body.expressions;
            for(idx = j = 0, len1 = ref3.length; j < len1; idx = ++j){
                expr = ref3[idx];
                expr = expr.unwrapAll();
                if (!(expr instanceof Call)) {
                    continue;
                }
                val = (ref4 = expr.variable) != null ? ref4.unwrapAll() : void 0;
                if (!(val instanceof Code || val instanceof Value && ((ref5 = val.base) != null ? ref5.unwrapAll() : void 0) instanceof Code && val.properties.length === 1 && ((ref6 = (ref7 = val.properties[0].name) != null ? ref7.value : void 0) === "call" || ref6 === "apply"))) {
                    continue;
                }
                fn = ((ref8 = val.base) != null ? ref8.unwrapAll() : void 0) || val;
                ref = new IdentifierLiteral(o.scope.freeVariable("fn"));
                base = new Value(ref);
                if (val.base) {
                    ref9 = [
                        base,
                        val
                    ], val.base = ref9[0], base = ref9[1];
                }
                body.expressions[idx] = new Call(base, expr.args);
                defs = defs.concat(this.makeCode(this.tab), new Assign(ref, fn).compileToFragments(o, LEVEL_TOP), this.makeCode(";\n"));
            }
            return defs;
        };
        return For;
    }(While);
    exports.Switch = Switch = function(superClass1) {
        extend1(Switch, superClass1);
        function Switch(subject, cases, otherwise) {
            this.subject = subject;
            this.cases = cases;
            this.otherwise = otherwise;
        }
        Switch.prototype.children = [
            "subject",
            "cases",
            "otherwise"
        ];
        Switch.prototype.isStatement = YES;
        Switch.prototype.jumps = function(o) {
            var block, conds, j, jumpNode, len1, ref3, ref4, ref5;
            if (o == null) {
                o = {
                    block: true
                };
            }
            ref3 = this.cases;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                ref4 = ref3[j], conds = ref4[0], block = ref4[1];
                if (jumpNode = block.jumps(o)) {
                    return jumpNode;
                }
            }
            return (ref5 = this.otherwise) != null ? ref5.jumps(o) : void 0;
        };
        Switch.prototype.makeReturn = function(res) {
            var j, len1, pair, ref3, ref4;
            ref3 = this.cases;
            for(j = 0, len1 = ref3.length; j < len1; j++){
                pair = ref3[j];
                pair[1].makeReturn(res);
            }
            if (res) {
                this.otherwise || (this.otherwise = new Block([
                    new Literal("void 0")
                ]));
            }
            if ((ref4 = this.otherwise) != null) {
                ref4.makeReturn(res);
            }
            return this;
        };
        Switch.prototype.compileNode = function(o) {
            var block, body, cond, conditions, expr, fragments, i, idt1, idt2, j, k, len1, len2, ref3, ref4, ref5;
            idt1 = o.indent + TAB;
            idt2 = o.indent = idt1 + TAB;
            fragments = [].concat(this.makeCode(this.tab + "switch ("), this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false"), this.makeCode(") {\n"));
            ref3 = this.cases;
            for(i = j = 0, len1 = ref3.length; j < len1; i = ++j){
                ref4 = ref3[i], conditions = ref4[0], block = ref4[1];
                ref5 = flatten([
                    conditions
                ]);
                for(k = 0, len2 = ref5.length; k < len2; k++){
                    cond = ref5[k];
                    if (!this.subject) {
                        cond = cond.invert();
                    }
                    fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
                }
                if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {
                    fragments = fragments.concat(body, this.makeCode("\n"));
                }
                if (i === this.cases.length - 1 && !this.otherwise) {
                    break;
                }
                expr = this.lastNonComment(block.expressions);
                if (expr instanceof Return || expr instanceof Literal && expr.jumps() && expr.value !== "debugger") {
                    continue;
                }
                fragments.push(cond.makeCode(idt2 + "break;\n"));
            }
            if (this.otherwise && this.otherwise.expressions.length) {
                fragments.push.apply(fragments, [
                    this.makeCode(idt1 + "default:\n")
                ].concat(slice.call(this.otherwise.compileToFragments(o, LEVEL_TOP)), [
                    this.makeCode("\n")
                ]));
            }
            fragments.push(this.makeCode(this.tab + "}"));
            return fragments;
        };
        return Switch;
    }(Base);
    exports.If = If = function(superClass1) {
        extend1(If, superClass1);
        function If(condition, body1, options) {
            this.body = body1;
            if (options == null) {
                options = {};
            }
            this.condition = options.type === "unless" ? condition.invert() : condition;
            this.elseBody = null;
            this.isChain = false;
            this.soak = options.soak;
        }
        If.prototype.children = [
            "condition",
            "body",
            "elseBody"
        ];
        If.prototype.bodyNode = function() {
            var ref3;
            return (ref3 = this.body) != null ? ref3.unwrap() : void 0;
        };
        If.prototype.elseBodyNode = function() {
            var ref3;
            return (ref3 = this.elseBody) != null ? ref3.unwrap() : void 0;
        };
        If.prototype.addElse = function(elseBody) {
            if (this.isChain) {
                this.elseBodyNode().addElse(elseBody);
            } else {
                this.isChain = elseBody instanceof If;
                this.elseBody = this.ensureBlock(elseBody);
                this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
            }
            return this;
        };
        If.prototype.isStatement = function(o) {
            var ref3;
            return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((ref3 = this.elseBodyNode()) != null ? ref3.isStatement(o) : void 0);
        };
        If.prototype.jumps = function(o) {
            var ref3;
            return this.body.jumps(o) || ((ref3 = this.elseBody) != null ? ref3.jumps(o) : void 0);
        };
        If.prototype.compileNode = function(o) {
            if (this.isStatement(o)) {
                return this.compileStatement(o);
            } else {
                return this.compileExpression(o);
            }
        };
        If.prototype.makeReturn = function(res) {
            if (res) {
                this.elseBody || (this.elseBody = new Block([
                    new Literal("void 0")
                ]));
            }
            this.body && (this.body = new Block([
                this.body.makeReturn(res)
            ]));
            this.elseBody && (this.elseBody = new Block([
                this.elseBody.makeReturn(res)
            ]));
            return this;
        };
        If.prototype.ensureBlock = function(node) {
            if (node instanceof Block) {
                return node;
            } else {
                return new Block([
                    node
                ]);
            }
        };
        If.prototype.compileStatement = function(o) {
            var answer, body, child, cond, exeq, ifPart, indent;
            child = del(o, "chainChild");
            exeq = del(o, "isExistentialEquals");
            if (exeq) {
                return new If(this.condition.invert(), this.elseBodyNode(), {
                    type: "if"
                }).compileToFragments(o);
            }
            indent = o.indent + TAB;
            cond = this.condition.compileToFragments(o, LEVEL_PAREN);
            body = this.ensureBlock(this.body).compileToFragments(merge(o, {
                indent: indent
            }));
            ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") {\n"), body, this.makeCode("\n" + this.tab + "}"));
            if (!child) {
                ifPart.unshift(this.makeCode(this.tab));
            }
            if (!this.elseBody) {
                return ifPart;
            }
            answer = ifPart.concat(this.makeCode(" else "));
            if (this.isChain) {
                o.chainChild = true;
                answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
            } else {
                answer = answer.concat(this.makeCode("{\n"), this.elseBody.compileToFragments(merge(o, {
                    indent: indent
                }), LEVEL_TOP), this.makeCode("\n" + this.tab + "}"));
            }
            return answer;
        };
        If.prototype.compileExpression = function(o) {
            var alt, body, cond, fragments;
            cond = this.condition.compileToFragments(o, LEVEL_COND);
            body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
            alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [
                this.makeCode("void 0")
            ];
            fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
            if (o.level >= LEVEL_COND) {
                return this.wrapInBraces(fragments);
            } else {
                return fragments;
            }
        };
        If.prototype.unfoldSoak = function() {
            return this.soak && this;
        };
        return If;
    }(Base);
    UTILITIES = {
        extend: function(o) {
            return "function(child, parent) { for (var key in parent) { if (" + utility("hasProp", o) + ".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }";
        },
        bind: function() {
            return "function(fn, me){ return function(){ return fn.apply(me, arguments); }; }";
        },
        indexOf: function() {
            return "[].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }";
        },
        modulo: function() {
            return "function(a, b) { return (+a % (b = +b) + b) % b; }";
        },
        hasProp: function() {
            return "{}.hasOwnProperty";
        },
        slice: function() {
            return "[].slice";
        }
    };
    LEVEL_TOP = 1;
    LEVEL_PAREN = 2;
    LEVEL_LIST = 3;
    LEVEL_COND = 4;
    LEVEL_OP = 5;
    LEVEL_ACCESS = 6;
    TAB = "  ";
    SIMPLENUM = /^[+-]?\d+$/;
    utility = function(name, o) {
        var ref, root;
        root = o.scope.root;
        if (name in root.utilities) {
            return root.utilities[name];
        } else {
            ref = root.freeVariable(name);
            root.assign(ref, UTILITIES[name](o));
            return root.utilities[name] = ref;
        }
    };
    multident = function(code, tab) {
        code = code.replace(/\n/g, "$&" + tab);
        return code.replace(/\s+$/, "");
    };
    isLiteralArguments = function(node) {
        return node instanceof IdentifierLiteral && node.value === "arguments";
    };
    isLiteralThis = function(node) {
        return node instanceof ThisLiteral || node instanceof Code && node.bound || node instanceof SuperCall;
    };
    isComplexOrAssignable = function(node) {
        return node.isComplex() || (typeof node.isAssignable === "function" ? node.isAssignable() : void 0);
    };
    unfoldSoak = function(o, parent, name) {
        var ifn;
        if (!(ifn = parent[name].unfoldSoak(o))) {
            return;
        }
        parent[name] = ifn.body;
        ifn.body = new Value(parent);
        return ifn;
    };
}).call(this);


/***/ }),

/***/ 52631:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/* parser generated by jison 0.4.17 */ /*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/ var parser = function() {
    var o = function(k, v, o, l) {
        for(o = o || {}, l = k.length; l--; o[k[l]] = v);
        return o;
    }, $V0 = [
        1,
        22
    ], $V1 = [
        1,
        25
    ], $V2 = [
        1,
        83
    ], $V3 = [
        1,
        79
    ], $V4 = [
        1,
        84
    ], $V5 = [
        1,
        85
    ], $V6 = [
        1,
        81
    ], $V7 = [
        1,
        82
    ], $V8 = [
        1,
        56
    ], $V9 = [
        1,
        58
    ], $Va = [
        1,
        59
    ], $Vb = [
        1,
        60
    ], $Vc = [
        1,
        61
    ], $Vd = [
        1,
        62
    ], $Ve = [
        1,
        49
    ], $Vf = [
        1,
        50
    ], $Vg = [
        1,
        32
    ], $Vh = [
        1,
        68
    ], $Vi = [
        1,
        69
    ], $Vj = [
        1,
        78
    ], $Vk = [
        1,
        47
    ], $Vl = [
        1,
        51
    ], $Vm = [
        1,
        52
    ], $Vn = [
        1,
        67
    ], $Vo = [
        1,
        65
    ], $Vp = [
        1,
        66
    ], $Vq = [
        1,
        64
    ], $Vr = [
        1,
        42
    ], $Vs = [
        1,
        48
    ], $Vt = [
        1,
        63
    ], $Vu = [
        1,
        73
    ], $Vv = [
        1,
        74
    ], $Vw = [
        1,
        75
    ], $Vx = [
        1,
        76
    ], $Vy = [
        1,
        46
    ], $Vz = [
        1,
        72
    ], $VA = [
        1,
        34
    ], $VB = [
        1,
        35
    ], $VC = [
        1,
        36
    ], $VD = [
        1,
        37
    ], $VE = [
        1,
        38
    ], $VF = [
        1,
        39
    ], $VG = [
        1,
        86
    ], $VH = [
        1,
        6,
        32,
        42,
        131
    ], $VI = [
        1,
        101
    ], $VJ = [
        1,
        89
    ], $VK = [
        1,
        88
    ], $VL = [
        1,
        87
    ], $VM = [
        1,
        90
    ], $VN = [
        1,
        91
    ], $VO = [
        1,
        92
    ], $VP = [
        1,
        93
    ], $VQ = [
        1,
        94
    ], $VR = [
        1,
        95
    ], $VS = [
        1,
        96
    ], $VT = [
        1,
        97
    ], $VU = [
        1,
        98
    ], $VV = [
        1,
        99
    ], $VW = [
        1,
        100
    ], $VX = [
        1,
        104
    ], $VY = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $VZ = [
        2,
        167
    ], $V_ = [
        1,
        110
    ], $V$ = [
        1,
        111
    ], $V01 = [
        1,
        112
    ], $V11 = [
        1,
        113
    ], $V21 = [
        1,
        115
    ], $V31 = [
        1,
        116
    ], $V41 = [
        1,
        109
    ], $V51 = [
        1,
        6,
        32,
        42,
        131,
        133,
        135,
        139,
        156
    ], $V61 = [
        2,
        27
    ], $V71 = [
        1,
        123
    ], $V81 = [
        1,
        121
    ], $V91 = [
        1,
        6,
        31,
        32,
        40,
        41,
        42,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Va1 = [
        2,
        95
    ], $Vb1 = [
        1,
        6,
        31,
        32,
        42,
        46,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Vc1 = [
        2,
        74
    ], $Vd1 = [
        1,
        128
    ], $Ve1 = [
        1,
        133
    ], $Vf1 = [
        1,
        134
    ], $Vg1 = [
        1,
        136
    ], $Vh1 = [
        1,
        6,
        31,
        32,
        40,
        41,
        42,
        55,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Vi1 = [
        2,
        92
    ], $Vj1 = [
        1,
        6,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Vk1 = [
        2,
        64
    ], $Vl1 = [
        1,
        161
    ], $Vm1 = [
        1,
        167
    ], $Vn1 = [
        1,
        179
    ], $Vo1 = [
        1,
        181
    ], $Vp1 = [
        1,
        176
    ], $Vq1 = [
        1,
        183
    ], $Vr1 = [
        1,
        185
    ], $Vs1 = [
        1,
        6,
        31,
        32,
        40,
        41,
        42,
        55,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        96,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175
    ], $Vt1 = [
        2,
        111
    ], $Vu1 = [
        1,
        6,
        31,
        32,
        40,
        41,
        42,
        58,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Vv1 = [
        1,
        6,
        31,
        32,
        40,
        41,
        42,
        46,
        58,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Vw1 = [
        40,
        41,
        114
    ], $Vx1 = [
        1,
        242
    ], $Vy1 = [
        1,
        241
    ], $Vz1 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156
    ], $VA1 = [
        2,
        72
    ], $VB1 = [
        1,
        251
    ], $VC1 = [
        6,
        31,
        32,
        66,
        71
    ], $VD1 = [
        6,
        31,
        32,
        55,
        66,
        71,
        74
    ], $VE1 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        164,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $VF1 = [
        40,
        41,
        82,
        83,
        84,
        85,
        87,
        90,
        113,
        114
    ], $VG1 = [
        1,
        270
    ], $VH1 = [
        2,
        62
    ], $VI1 = [
        1,
        281
    ], $VJ1 = [
        1,
        283
    ], $VK1 = [
        1,
        288
    ], $VL1 = [
        1,
        290
    ], $VM1 = [
        2,
        188
    ], $VN1 = [
        1,
        6,
        31,
        32,
        40,
        41,
        42,
        55,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        146,
        147,
        148,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $VO1 = [
        1,
        299
    ], $VP1 = [
        6,
        31,
        32,
        71,
        115,
        120
    ], $VQ1 = [
        1,
        6,
        31,
        32,
        40,
        41,
        42,
        55,
        58,
        66,
        71,
        74,
        82,
        83,
        84,
        85,
        87,
        89,
        90,
        94,
        96,
        113,
        114,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        146,
        147,
        148,
        156,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175
    ], $VR1 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        140,
        156
    ], $VS1 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        134,
        140,
        156
    ], $VT1 = [
        146,
        147,
        148
    ], $VU1 = [
        71,
        146,
        147,
        148
    ], $VV1 = [
        6,
        31,
        94
    ], $VW1 = [
        1,
        313
    ], $VX1 = [
        6,
        31,
        32,
        71,
        94
    ], $VY1 = [
        6,
        31,
        32,
        58,
        71,
        94
    ], $VZ1 = [
        6,
        31,
        32,
        55,
        58,
        71,
        94
    ], $V_1 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $V$1 = [
        12,
        28,
        34,
        38,
        40,
        41,
        44,
        45,
        48,
        49,
        50,
        51,
        52,
        53,
        61,
        63,
        64,
        68,
        69,
        89,
        92,
        95,
        97,
        105,
        112,
        117,
        118,
        119,
        125,
        129,
        130,
        133,
        135,
        137,
        139,
        149,
        155,
        157,
        158,
        159,
        160,
        161,
        162
    ], $V02 = [
        2,
        177
    ], $V12 = [
        6,
        31,
        32
    ], $V22 = [
        2,
        73
    ], $V32 = [
        1,
        325
    ], $V42 = [
        1,
        326
    ], $V52 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        127,
        128,
        131,
        133,
        134,
        135,
        139,
        140,
        151,
        153,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $V62 = [
        32,
        151,
        153
    ], $V72 = [
        1,
        6,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        134,
        140,
        156
    ], $V82 = [
        1,
        353
    ], $V92 = [
        1,
        359
    ], $Va2 = [
        1,
        6,
        32,
        42,
        131,
        156
    ], $Vb2 = [
        2,
        87
    ], $Vc2 = [
        1,
        370
    ], $Vd2 = [
        1,
        371
    ], $Ve2 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        133,
        134,
        135,
        139,
        140,
        151,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Vf2 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        131,
        133,
        135,
        139,
        140,
        156
    ], $Vg2 = [
        1,
        384
    ], $Vh2 = [
        1,
        385
    ], $Vi2 = [
        6,
        31,
        32,
        94
    ], $Vj2 = [
        6,
        31,
        32,
        71
    ], $Vk2 = [
        1,
        6,
        31,
        32,
        42,
        66,
        71,
        74,
        89,
        94,
        115,
        120,
        122,
        127,
        131,
        133,
        134,
        135,
        139,
        140,
        156,
        159,
        160,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174
    ], $Vl2 = [
        31,
        71
    ], $Vm2 = [
        1,
        411
    ], $Vn2 = [
        1,
        412
    ], $Vo2 = [
        1,
        418
    ], $Vp2 = [
        1,
        419
    ];
    var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
            "error": 2,
            "Root": 3,
            "Body": 4,
            "Line": 5,
            "TERMINATOR": 6,
            "Expression": 7,
            "Statement": 8,
            "YieldReturn": 9,
            "Return": 10,
            "Comment": 11,
            "STATEMENT": 12,
            "Import": 13,
            "Export": 14,
            "Value": 15,
            "Invocation": 16,
            "Code": 17,
            "Operation": 18,
            "Assign": 19,
            "If": 20,
            "Try": 21,
            "While": 22,
            "For": 23,
            "Switch": 24,
            "Class": 25,
            "Throw": 26,
            "Yield": 27,
            "YIELD": 28,
            "FROM": 29,
            "Block": 30,
            "INDENT": 31,
            "OUTDENT": 32,
            "Identifier": 33,
            "IDENTIFIER": 34,
            "Property": 35,
            "PROPERTY": 36,
            "AlphaNumeric": 37,
            "NUMBER": 38,
            "String": 39,
            "STRING": 40,
            "STRING_START": 41,
            "STRING_END": 42,
            "Regex": 43,
            "REGEX": 44,
            "REGEX_START": 45,
            "REGEX_END": 46,
            "Literal": 47,
            "JS": 48,
            "UNDEFINED": 49,
            "NULL": 50,
            "BOOL": 51,
            "INFINITY": 52,
            "NAN": 53,
            "Assignable": 54,
            "=": 55,
            "AssignObj": 56,
            "ObjAssignable": 57,
            ":": 58,
            "SimpleObjAssignable": 59,
            "ThisProperty": 60,
            "RETURN": 61,
            "Object": 62,
            "HERECOMMENT": 63,
            "PARAM_START": 64,
            "ParamList": 65,
            "PARAM_END": 66,
            "FuncGlyph": 67,
            "->": 68,
            "=>": 69,
            "OptComma": 70,
            ",": 71,
            "Param": 72,
            "ParamVar": 73,
            "...": 74,
            "Array": 75,
            "Splat": 76,
            "SimpleAssignable": 77,
            "Accessor": 78,
            "Parenthetical": 79,
            "Range": 80,
            "This": 81,
            ".": 82,
            "?.": 83,
            "::": 84,
            "?::": 85,
            "Index": 86,
            "INDEX_START": 87,
            "IndexValue": 88,
            "INDEX_END": 89,
            "INDEX_SOAK": 90,
            "Slice": 91,
            "{": 92,
            "AssignList": 93,
            "}": 94,
            "CLASS": 95,
            "EXTENDS": 96,
            "IMPORT": 97,
            "ImportDefaultSpecifier": 98,
            "ImportNamespaceSpecifier": 99,
            "ImportSpecifierList": 100,
            "ImportSpecifier": 101,
            "AS": 102,
            "DEFAULT": 103,
            "IMPORT_ALL": 104,
            "EXPORT": 105,
            "ExportSpecifierList": 106,
            "EXPORT_ALL": 107,
            "ExportSpecifier": 108,
            "OptFuncExist": 109,
            "Arguments": 110,
            "Super": 111,
            "SUPER": 112,
            "FUNC_EXIST": 113,
            "CALL_START": 114,
            "CALL_END": 115,
            "ArgList": 116,
            "THIS": 117,
            "@": 118,
            "[": 119,
            "]": 120,
            "RangeDots": 121,
            "..": 122,
            "Arg": 123,
            "SimpleArgs": 124,
            "TRY": 125,
            "Catch": 126,
            "FINALLY": 127,
            "CATCH": 128,
            "THROW": 129,
            "(": 130,
            ")": 131,
            "WhileSource": 132,
            "WHILE": 133,
            "WHEN": 134,
            "UNTIL": 135,
            "Loop": 136,
            "LOOP": 137,
            "ForBody": 138,
            "FOR": 139,
            "BY": 140,
            "ForStart": 141,
            "ForSource": 142,
            "ForVariables": 143,
            "OWN": 144,
            "ForValue": 145,
            "FORIN": 146,
            "FOROF": 147,
            "FORFROM": 148,
            "SWITCH": 149,
            "Whens": 150,
            "ELSE": 151,
            "When": 152,
            "LEADING_WHEN": 153,
            "IfBlock": 154,
            "IF": 155,
            "POST_IF": 156,
            "UNARY": 157,
            "UNARY_MATH": 158,
            "-": 159,
            "+": 160,
            "--": 161,
            "++": 162,
            "?": 163,
            "MATH": 164,
            "**": 165,
            "SHIFT": 166,
            "COMPARE": 167,
            "&": 168,
            "^": 169,
            "|": 170,
            "&&": 171,
            "||": 172,
            "BIN?": 173,
            "RELATION": 174,
            "COMPOUND_ASSIGN": 175,
            "$accept": 0,
            "$end": 1
        },
        terminals_: {
            2: "error",
            6: "TERMINATOR",
            12: "STATEMENT",
            28: "YIELD",
            29: "FROM",
            31: "INDENT",
            32: "OUTDENT",
            34: "IDENTIFIER",
            36: "PROPERTY",
            38: "NUMBER",
            40: "STRING",
            41: "STRING_START",
            42: "STRING_END",
            44: "REGEX",
            45: "REGEX_START",
            46: "REGEX_END",
            48: "JS",
            49: "UNDEFINED",
            50: "NULL",
            51: "BOOL",
            52: "INFINITY",
            53: "NAN",
            55: "=",
            58: ":",
            61: "RETURN",
            63: "HERECOMMENT",
            64: "PARAM_START",
            66: "PARAM_END",
            68: "->",
            69: "=>",
            71: ",",
            74: "...",
            82: ".",
            83: "?.",
            84: "::",
            85: "?::",
            87: "INDEX_START",
            89: "INDEX_END",
            90: "INDEX_SOAK",
            92: "{",
            94: "}",
            95: "CLASS",
            96: "EXTENDS",
            97: "IMPORT",
            102: "AS",
            103: "DEFAULT",
            104: "IMPORT_ALL",
            105: "EXPORT",
            107: "EXPORT_ALL",
            112: "SUPER",
            113: "FUNC_EXIST",
            114: "CALL_START",
            115: "CALL_END",
            117: "THIS",
            118: "@",
            119: "[",
            120: "]",
            122: "..",
            125: "TRY",
            127: "FINALLY",
            128: "CATCH",
            129: "THROW",
            130: "(",
            131: ")",
            133: "WHILE",
            134: "WHEN",
            135: "UNTIL",
            137: "LOOP",
            139: "FOR",
            140: "BY",
            144: "OWN",
            146: "FORIN",
            147: "FOROF",
            148: "FORFROM",
            149: "SWITCH",
            151: "ELSE",
            153: "LEADING_WHEN",
            155: "IF",
            156: "POST_IF",
            157: "UNARY",
            158: "UNARY_MATH",
            159: "-",
            160: "+",
            161: "--",
            162: "++",
            163: "?",
            164: "MATH",
            165: "**",
            166: "SHIFT",
            167: "COMPARE",
            168: "&",
            169: "^",
            170: "|",
            171: "&&",
            172: "||",
            173: "BIN?",
            174: "RELATION",
            175: "COMPOUND_ASSIGN"
        },
        productions_: [
            0,
            [
                3,
                0
            ],
            [
                3,
                1
            ],
            [
                4,
                1
            ],
            [
                4,
                3
            ],
            [
                4,
                2
            ],
            [
                5,
                1
            ],
            [
                5,
                1
            ],
            [
                5,
                1
            ],
            [
                8,
                1
            ],
            [
                8,
                1
            ],
            [
                8,
                1
            ],
            [
                8,
                1
            ],
            [
                8,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                7,
                1
            ],
            [
                27,
                1
            ],
            [
                27,
                2
            ],
            [
                27,
                3
            ],
            [
                30,
                2
            ],
            [
                30,
                3
            ],
            [
                33,
                1
            ],
            [
                35,
                1
            ],
            [
                37,
                1
            ],
            [
                37,
                1
            ],
            [
                39,
                1
            ],
            [
                39,
                3
            ],
            [
                43,
                1
            ],
            [
                43,
                3
            ],
            [
                47,
                1
            ],
            [
                47,
                1
            ],
            [
                47,
                1
            ],
            [
                47,
                1
            ],
            [
                47,
                1
            ],
            [
                47,
                1
            ],
            [
                47,
                1
            ],
            [
                47,
                1
            ],
            [
                19,
                3
            ],
            [
                19,
                4
            ],
            [
                19,
                5
            ],
            [
                56,
                1
            ],
            [
                56,
                3
            ],
            [
                56,
                5
            ],
            [
                56,
                3
            ],
            [
                56,
                5
            ],
            [
                56,
                1
            ],
            [
                59,
                1
            ],
            [
                59,
                1
            ],
            [
                59,
                1
            ],
            [
                57,
                1
            ],
            [
                57,
                1
            ],
            [
                10,
                2
            ],
            [
                10,
                4
            ],
            [
                10,
                1
            ],
            [
                9,
                3
            ],
            [
                9,
                2
            ],
            [
                11,
                1
            ],
            [
                17,
                5
            ],
            [
                17,
                2
            ],
            [
                67,
                1
            ],
            [
                67,
                1
            ],
            [
                70,
                0
            ],
            [
                70,
                1
            ],
            [
                65,
                0
            ],
            [
                65,
                1
            ],
            [
                65,
                3
            ],
            [
                65,
                4
            ],
            [
                65,
                6
            ],
            [
                72,
                1
            ],
            [
                72,
                2
            ],
            [
                72,
                3
            ],
            [
                72,
                1
            ],
            [
                73,
                1
            ],
            [
                73,
                1
            ],
            [
                73,
                1
            ],
            [
                73,
                1
            ],
            [
                76,
                2
            ],
            [
                77,
                1
            ],
            [
                77,
                2
            ],
            [
                77,
                2
            ],
            [
                77,
                1
            ],
            [
                54,
                1
            ],
            [
                54,
                1
            ],
            [
                54,
                1
            ],
            [
                15,
                1
            ],
            [
                15,
                1
            ],
            [
                15,
                1
            ],
            [
                15,
                1
            ],
            [
                15,
                1
            ],
            [
                78,
                2
            ],
            [
                78,
                2
            ],
            [
                78,
                2
            ],
            [
                78,
                2
            ],
            [
                78,
                1
            ],
            [
                78,
                1
            ],
            [
                86,
                3
            ],
            [
                86,
                2
            ],
            [
                88,
                1
            ],
            [
                88,
                1
            ],
            [
                62,
                4
            ],
            [
                93,
                0
            ],
            [
                93,
                1
            ],
            [
                93,
                3
            ],
            [
                93,
                4
            ],
            [
                93,
                6
            ],
            [
                25,
                1
            ],
            [
                25,
                2
            ],
            [
                25,
                3
            ],
            [
                25,
                4
            ],
            [
                25,
                2
            ],
            [
                25,
                3
            ],
            [
                25,
                4
            ],
            [
                25,
                5
            ],
            [
                13,
                2
            ],
            [
                13,
                4
            ],
            [
                13,
                4
            ],
            [
                13,
                5
            ],
            [
                13,
                7
            ],
            [
                13,
                6
            ],
            [
                13,
                9
            ],
            [
                100,
                1
            ],
            [
                100,
                3
            ],
            [
                100,
                4
            ],
            [
                100,
                4
            ],
            [
                100,
                6
            ],
            [
                101,
                1
            ],
            [
                101,
                3
            ],
            [
                101,
                1
            ],
            [
                101,
                3
            ],
            [
                98,
                1
            ],
            [
                99,
                3
            ],
            [
                14,
                3
            ],
            [
                14,
                5
            ],
            [
                14,
                2
            ],
            [
                14,
                4
            ],
            [
                14,
                5
            ],
            [
                14,
                6
            ],
            [
                14,
                3
            ],
            [
                14,
                4
            ],
            [
                14,
                7
            ],
            [
                106,
                1
            ],
            [
                106,
                3
            ],
            [
                106,
                4
            ],
            [
                106,
                4
            ],
            [
                106,
                6
            ],
            [
                108,
                1
            ],
            [
                108,
                3
            ],
            [
                108,
                3
            ],
            [
                108,
                1
            ],
            [
                108,
                3
            ],
            [
                16,
                3
            ],
            [
                16,
                3
            ],
            [
                16,
                3
            ],
            [
                16,
                1
            ],
            [
                111,
                1
            ],
            [
                111,
                2
            ],
            [
                109,
                0
            ],
            [
                109,
                1
            ],
            [
                110,
                2
            ],
            [
                110,
                4
            ],
            [
                81,
                1
            ],
            [
                81,
                1
            ],
            [
                60,
                2
            ],
            [
                75,
                2
            ],
            [
                75,
                4
            ],
            [
                121,
                1
            ],
            [
                121,
                1
            ],
            [
                80,
                5
            ],
            [
                91,
                3
            ],
            [
                91,
                2
            ],
            [
                91,
                2
            ],
            [
                91,
                1
            ],
            [
                116,
                1
            ],
            [
                116,
                3
            ],
            [
                116,
                4
            ],
            [
                116,
                4
            ],
            [
                116,
                6
            ],
            [
                123,
                1
            ],
            [
                123,
                1
            ],
            [
                123,
                1
            ],
            [
                124,
                1
            ],
            [
                124,
                3
            ],
            [
                21,
                2
            ],
            [
                21,
                3
            ],
            [
                21,
                4
            ],
            [
                21,
                5
            ],
            [
                126,
                3
            ],
            [
                126,
                3
            ],
            [
                126,
                2
            ],
            [
                26,
                2
            ],
            [
                79,
                3
            ],
            [
                79,
                5
            ],
            [
                132,
                2
            ],
            [
                132,
                4
            ],
            [
                132,
                2
            ],
            [
                132,
                4
            ],
            [
                22,
                2
            ],
            [
                22,
                2
            ],
            [
                22,
                2
            ],
            [
                22,
                1
            ],
            [
                136,
                2
            ],
            [
                136,
                2
            ],
            [
                23,
                2
            ],
            [
                23,
                2
            ],
            [
                23,
                2
            ],
            [
                138,
                2
            ],
            [
                138,
                4
            ],
            [
                138,
                2
            ],
            [
                141,
                2
            ],
            [
                141,
                3
            ],
            [
                145,
                1
            ],
            [
                145,
                1
            ],
            [
                145,
                1
            ],
            [
                145,
                1
            ],
            [
                143,
                1
            ],
            [
                143,
                3
            ],
            [
                142,
                2
            ],
            [
                142,
                2
            ],
            [
                142,
                4
            ],
            [
                142,
                4
            ],
            [
                142,
                4
            ],
            [
                142,
                6
            ],
            [
                142,
                6
            ],
            [
                142,
                2
            ],
            [
                142,
                4
            ],
            [
                24,
                5
            ],
            [
                24,
                7
            ],
            [
                24,
                4
            ],
            [
                24,
                6
            ],
            [
                150,
                1
            ],
            [
                150,
                2
            ],
            [
                152,
                3
            ],
            [
                152,
                4
            ],
            [
                154,
                3
            ],
            [
                154,
                5
            ],
            [
                20,
                1
            ],
            [
                20,
                3
            ],
            [
                20,
                3
            ],
            [
                20,
                3
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                2
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                3
            ],
            [
                18,
                5
            ],
            [
                18,
                4
            ],
            [
                18,
                3
            ]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */ , $$ /* vstack */ , _$ /* lstack */ ) {
            /* this == yyval */ var $0 = $$.length - 1;
            switch(yystate){
                case 1:
                    return this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Block);
                    break;
                case 2:
                    return this.$ = $$[$0];
                    break;
                case 3:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(yy.Block.wrap([
                        $$[$0]
                    ]));
                    break;
                case 4:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])($$[$0 - 2].push($$[$0]));
                    break;
                case 5:
                    this.$ = $$[$0 - 1];
                    break;
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 35:
                case 40:
                case 42:
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 72:
                case 73:
                case 83:
                case 84:
                case 85:
                case 86:
                case 91:
                case 92:
                case 95:
                case 99:
                case 105:
                case 164:
                case 188:
                case 189:
                case 191:
                case 221:
                case 222:
                case 240:
                case 246:
                    this.$ = $$[$0];
                    break;
                case 11:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.StatementLiteral($$[$0]));
                    break;
                case 27:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Op($$[$0], new yy.Value(new yy.Literal(""))));
                    break;
                case 28:
                case 250:
                case 251:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Op($$[$0 - 1], $$[$0]));
                    break;
                case 29:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Op($$[$0 - 2].concat($$[$0 - 1]), $$[$0]));
                    break;
                case 30:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Block);
                    break;
                case 31:
                case 106:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])($$[$0 - 1]);
                    break;
                case 32:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.IdentifierLiteral($$[$0]));
                    break;
                case 33:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.PropertyName($$[$0]));
                    break;
                case 34:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.NumberLiteral($$[$0]));
                    break;
                case 36:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.StringLiteral($$[$0]));
                    break;
                case 37:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.StringWithInterpolations($$[$0 - 1]));
                    break;
                case 38:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.RegexLiteral($$[$0]));
                    break;
                case 39:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.RegexWithInterpolations($$[$0 - 1].args));
                    break;
                case 41:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.PassthroughLiteral($$[$0]));
                    break;
                case 43:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.UndefinedLiteral);
                    break;
                case 44:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.NullLiteral);
                    break;
                case 45:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.BooleanLiteral($$[$0]));
                    break;
                case 46:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.InfinityLiteral($$[$0]));
                    break;
                case 47:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.NaNLiteral);
                    break;
                case 48:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Assign($$[$0 - 2], $$[$0]));
                    break;
                case 49:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Assign($$[$0 - 3], $$[$0]));
                    break;
                case 50:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Assign($$[$0 - 4], $$[$0 - 1]));
                    break;
                case 51:
                case 88:
                case 93:
                case 94:
                case 96:
                case 97:
                case 98:
                case 223:
                case 224:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
                    break;
                case 52:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0 - 2])(new yy.Value($$[$0 - 2])), $$[$0], "object", {
                        operatorToken: yy.addLocationDataFn(_$[$0 - 1])(new yy.Literal($$[$0 - 1]))
                    }));
                    break;
                case 53:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0 - 4])(new yy.Value($$[$0 - 4])), $$[$0 - 1], "object", {
                        operatorToken: yy.addLocationDataFn(_$[$0 - 3])(new yy.Literal($$[$0 - 3]))
                    }));
                    break;
                case 54:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0 - 2])(new yy.Value($$[$0 - 2])), $$[$0], null, {
                        operatorToken: yy.addLocationDataFn(_$[$0 - 1])(new yy.Literal($$[$0 - 1]))
                    }));
                    break;
                case 55:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0 - 4])(new yy.Value($$[$0 - 4])), $$[$0 - 1], null, {
                        operatorToken: yy.addLocationDataFn(_$[$0 - 3])(new yy.Literal($$[$0 - 3]))
                    }));
                    break;
                case 62:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Return($$[$0]));
                    break;
                case 63:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Return(new yy.Value($$[$0 - 1])));
                    break;
                case 64:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Return);
                    break;
                case 65:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.YieldReturn($$[$0]));
                    break;
                case 66:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.YieldReturn);
                    break;
                case 67:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Comment($$[$0]));
                    break;
                case 68:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Code($$[$0 - 3], $$[$0], $$[$0 - 1]));
                    break;
                case 69:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Code([], $$[$0], $$[$0 - 1]));
                    break;
                case 70:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])("func");
                    break;
                case 71:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])("boundfunc");
                    break;
                case 74:
                case 111:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([]);
                    break;
                case 75:
                case 112:
                case 131:
                case 151:
                case 183:
                case 225:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([
                        $$[$0]
                    ]);
                    break;
                case 76:
                case 113:
                case 132:
                case 152:
                case 184:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])($$[$0 - 2].concat($$[$0]));
                    break;
                case 77:
                case 114:
                case 133:
                case 153:
                case 185:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])($$[$0 - 3].concat($$[$0]));
                    break;
                case 78:
                case 115:
                case 135:
                case 155:
                case 187:
                    this.$ = yy.addLocationDataFn(_$[$0 - 5], _$[$0])($$[$0 - 5].concat($$[$0 - 2]));
                    break;
                case 79:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Param($$[$0]));
                    break;
                case 80:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Param($$[$0 - 1], null, true));
                    break;
                case 81:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Param($$[$0 - 2], $$[$0]));
                    break;
                case 82:
                case 190:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Expansion);
                    break;
                case 87:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Splat($$[$0 - 1]));
                    break;
                case 89:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])($$[$0 - 1].add($$[$0]));
                    break;
                case 90:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Value($$[$0 - 1], [].concat($$[$0])));
                    break;
                case 100:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Access($$[$0]));
                    break;
                case 101:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Access($$[$0], "soak"));
                    break;
                case 102:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])([
                        yy.addLocationDataFn(_$[$0 - 1])(new yy.Access(new yy.PropertyName("prototype"))),
                        yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))
                    ]);
                    break;
                case 103:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])([
                        yy.addLocationDataFn(_$[$0 - 1])(new yy.Access(new yy.PropertyName("prototype"), "soak")),
                        yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))
                    ]);
                    break;
                case 104:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Access(new yy.PropertyName("prototype")));
                    break;
                case 107:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(yy.extend($$[$0], {
                        soak: true
                    }));
                    break;
                case 108:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Index($$[$0]));
                    break;
                case 109:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Slice($$[$0]));
                    break;
                case 110:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Obj($$[$0 - 2], $$[$0 - 3].generated));
                    break;
                case 116:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Class);
                    break;
                case 117:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Class(null, null, $$[$0]));
                    break;
                case 118:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Class(null, $$[$0]));
                    break;
                case 119:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Class(null, $$[$0 - 1], $$[$0]));
                    break;
                case 120:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Class($$[$0]));
                    break;
                case 121:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Class($$[$0 - 1], null, $$[$0]));
                    break;
                case 122:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Class($$[$0 - 2], $$[$0]));
                    break;
                case 123:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Class($$[$0 - 3], $$[$0 - 1], $$[$0]));
                    break;
                case 124:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.ImportDeclaration(null, $$[$0]));
                    break;
                case 125:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 2], null), $$[$0]));
                    break;
                case 126:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause(null, $$[$0 - 2]), $$[$0]));
                    break;
                case 127:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause(null, new yy.ImportSpecifierList([])), $$[$0]));
                    break;
                case 128:
                    this.$ = yy.addLocationDataFn(_$[$0 - 6], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause(null, new yy.ImportSpecifierList($$[$0 - 4])), $$[$0]));
                    break;
                case 129:
                    this.$ = yy.addLocationDataFn(_$[$0 - 5], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 4], $$[$0 - 2]), $$[$0]));
                    break;
                case 130:
                    this.$ = yy.addLocationDataFn(_$[$0 - 8], _$[$0])(new yy.ImportDeclaration(new yy.ImportClause($$[$0 - 7], new yy.ImportSpecifierList($$[$0 - 4])), $$[$0]));
                    break;
                case 134:
                case 154:
                case 170:
                case 186:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])($$[$0 - 2]);
                    break;
                case 136:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.ImportSpecifier($$[$0]));
                    break;
                case 137:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ImportSpecifier($$[$0 - 2], $$[$0]));
                    break;
                case 138:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.ImportSpecifier(new yy.Literal($$[$0])));
                    break;
                case 139:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ImportSpecifier(new yy.Literal($$[$0 - 2]), $$[$0]));
                    break;
                case 140:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.ImportDefaultSpecifier($$[$0]));
                    break;
                case 141:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ImportNamespaceSpecifier(new yy.Literal($$[$0 - 2]), $$[$0]));
                    break;
                case 142:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList([])));
                    break;
                case 143:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($$[$0 - 2])));
                    break;
                case 144:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.ExportNamedDeclaration($$[$0]));
                    break;
                case 145:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.ExportNamedDeclaration(new yy.Assign($$[$0 - 2], $$[$0], null, {
                        moduleDeclaration: "export"
                    })));
                    break;
                case 146:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.ExportNamedDeclaration(new yy.Assign($$[$0 - 3], $$[$0], null, {
                        moduleDeclaration: "export"
                    })));
                    break;
                case 147:
                    this.$ = yy.addLocationDataFn(_$[$0 - 5], _$[$0])(new yy.ExportNamedDeclaration(new yy.Assign($$[$0 - 4], $$[$0 - 1], null, {
                        moduleDeclaration: "export"
                    })));
                    break;
                case 148:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ExportDefaultDeclaration($$[$0]));
                    break;
                case 149:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.ExportAllDeclaration(new yy.Literal($$[$0 - 2]), $$[$0]));
                    break;
                case 150:
                    this.$ = yy.addLocationDataFn(_$[$0 - 6], _$[$0])(new yy.ExportNamedDeclaration(new yy.ExportSpecifierList($$[$0 - 4]), $$[$0]));
                    break;
                case 156:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.ExportSpecifier($$[$0]));
                    break;
                case 157:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ExportSpecifier($$[$0 - 2], $$[$0]));
                    break;
                case 158:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ExportSpecifier($$[$0 - 2], new yy.Literal($$[$0])));
                    break;
                case 159:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.ExportSpecifier(new yy.Literal($$[$0])));
                    break;
                case 160:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.ExportSpecifier(new yy.Literal($$[$0 - 2]), $$[$0]));
                    break;
                case 161:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.TaggedTemplateCall($$[$0 - 2], $$[$0], $$[$0 - 1]));
                    break;
                case 162:
                case 163:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Call($$[$0 - 2], $$[$0], $$[$0 - 1]));
                    break;
                case 165:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.SuperCall);
                    break;
                case 166:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.SuperCall($$[$0]));
                    break;
                case 167:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(false);
                    break;
                case 168:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(true);
                    break;
                case 169:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])([]);
                    break;
                case 171:
                case 172:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value(new yy.ThisLiteral));
                    break;
                case 173:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Value(yy.addLocationDataFn(_$[$0 - 1])(new yy.ThisLiteral), [
                        yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))
                    ], "this"));
                    break;
                case 174:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Arr([]));
                    break;
                case 175:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Arr($$[$0 - 2]));
                    break;
                case 176:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])("inclusive");
                    break;
                case 177:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])("exclusive");
                    break;
                case 178:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Range($$[$0 - 3], $$[$0 - 1], $$[$0 - 2]));
                    break;
                case 179:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Range($$[$0 - 2], $$[$0], $$[$0 - 1]));
                    break;
                case 180:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Range($$[$0 - 1], null, $$[$0]));
                    break;
                case 181:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Range(null, $$[$0], $$[$0 - 1]));
                    break;
                case 182:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Range(null, null, $$[$0]));
                    break;
                case 192:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])([].concat($$[$0 - 2], $$[$0]));
                    break;
                case 193:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Try($$[$0]));
                    break;
                case 194:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Try($$[$0 - 1], $$[$0][0], $$[$0][1]));
                    break;
                case 195:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Try($$[$0 - 2], null, null, $$[$0]));
                    break;
                case 196:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Try($$[$0 - 3], $$[$0 - 2][0], $$[$0 - 2][1], $$[$0]));
                    break;
                case 197:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])([
                        $$[$0 - 1],
                        $$[$0]
                    ]);
                    break;
                case 198:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])([
                        yy.addLocationDataFn(_$[$0 - 1])(new yy.Value($$[$0 - 1])),
                        $$[$0]
                    ]);
                    break;
                case 199:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])([
                        null,
                        $$[$0]
                    ]);
                    break;
                case 200:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Throw($$[$0]));
                    break;
                case 201:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Parens($$[$0 - 1]));
                    break;
                case 202:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Parens($$[$0 - 2]));
                    break;
                case 203:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.While($$[$0]));
                    break;
                case 204:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.While($$[$0 - 2], {
                        guard: $$[$0]
                    }));
                    break;
                case 205:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.While($$[$0], {
                        invert: true
                    }));
                    break;
                case 206:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.While($$[$0 - 2], {
                        invert: true,
                        guard: $$[$0]
                    }));
                    break;
                case 207:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])($$[$0 - 1].addBody($$[$0]));
                    break;
                case 208:
                case 209:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])($$[$0].addBody(yy.addLocationDataFn(_$[$0 - 1])(yy.Block.wrap([
                        $$[$0 - 1]
                    ]))));
                    break;
                case 210:
                    this.$ = yy.addLocationDataFn(_$[$0], _$[$0])($$[$0]);
                    break;
                case 211:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0 - 1])(new yy.BooleanLiteral("true"))).addBody($$[$0]));
                    break;
                case 212:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0 - 1])(new yy.BooleanLiteral("true"))).addBody(yy.addLocationDataFn(_$[$0])(yy.Block.wrap([
                        $$[$0]
                    ]))));
                    break;
                case 213:
                case 214:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.For($$[$0 - 1], $$[$0]));
                    break;
                case 215:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.For($$[$0], $$[$0 - 1]));
                    break;
                case 216:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])({
                        source: yy.addLocationDataFn(_$[$0])(new yy.Value($$[$0]))
                    });
                    break;
                case 217:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])({
                        source: yy.addLocationDataFn(_$[$0 - 2])(new yy.Value($$[$0 - 2])),
                        step: $$[$0]
                    });
                    break;
                case 218:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(function() {
                        $$[$0].own = $$[$0 - 1].own;
                        $$[$0].ownTag = $$[$0 - 1].ownTag;
                        $$[$0].name = $$[$0 - 1][0];
                        $$[$0].index = $$[$0 - 1][1];
                        return $$[$0];
                    }());
                    break;
                case 219:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])($$[$0]);
                    break;
                case 220:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(function() {
                        $$[$0].own = true;
                        $$[$0].ownTag = yy.addLocationDataFn(_$[$0 - 1])(new yy.Literal($$[$0 - 1]));
                        return $$[$0];
                    }());
                    break;
                case 226:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])([
                        $$[$0 - 2],
                        $$[$0]
                    ]);
                    break;
                case 227:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])({
                        source: $$[$0]
                    });
                    break;
                case 228:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])({
                        source: $$[$0],
                        object: true
                    });
                    break;
                case 229:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])({
                        source: $$[$0 - 2],
                        guard: $$[$0]
                    });
                    break;
                case 230:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])({
                        source: $$[$0 - 2],
                        guard: $$[$0],
                        object: true
                    });
                    break;
                case 231:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])({
                        source: $$[$0 - 2],
                        step: $$[$0]
                    });
                    break;
                case 232:
                    this.$ = yy.addLocationDataFn(_$[$0 - 5], _$[$0])({
                        source: $$[$0 - 4],
                        guard: $$[$0 - 2],
                        step: $$[$0]
                    });
                    break;
                case 233:
                    this.$ = yy.addLocationDataFn(_$[$0 - 5], _$[$0])({
                        source: $$[$0 - 4],
                        step: $$[$0 - 2],
                        guard: $$[$0]
                    });
                    break;
                case 234:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])({
                        source: $$[$0],
                        from: true
                    });
                    break;
                case 235:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])({
                        source: $$[$0 - 2],
                        guard: $$[$0],
                        from: true
                    });
                    break;
                case 236:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Switch($$[$0 - 3], $$[$0 - 1]));
                    break;
                case 237:
                    this.$ = yy.addLocationDataFn(_$[$0 - 6], _$[$0])(new yy.Switch($$[$0 - 5], $$[$0 - 3], $$[$0 - 1]));
                    break;
                case 238:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Switch(null, $$[$0 - 1]));
                    break;
                case 239:
                    this.$ = yy.addLocationDataFn(_$[$0 - 5], _$[$0])(new yy.Switch(null, $$[$0 - 3], $$[$0 - 1]));
                    break;
                case 241:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])($$[$0 - 1].concat($$[$0]));
                    break;
                case 242:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])([
                        [
                            $$[$0 - 1],
                            $$[$0]
                        ]
                    ]);
                    break;
                case 243:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])([
                        [
                            $$[$0 - 2],
                            $$[$0 - 1]
                        ]
                    ]);
                    break;
                case 244:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.If($$[$0 - 1], $$[$0], {
                        type: $$[$0 - 2]
                    }));
                    break;
                case 245:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])($$[$0 - 4].addElse(yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.If($$[$0 - 1], $$[$0], {
                        type: $$[$0 - 2]
                    }))));
                    break;
                case 247:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])($$[$0 - 2].addElse($$[$0]));
                    break;
                case 248:
                case 249:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.If($$[$0], yy.addLocationDataFn(_$[$0 - 2])(yy.Block.wrap([
                        $$[$0 - 2]
                    ])), {
                        type: $$[$0 - 1],
                        statement: true
                    }));
                    break;
                case 252:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Op("-", $$[$0]));
                    break;
                case 253:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Op("+", $$[$0]));
                    break;
                case 254:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Op("--", $$[$0]));
                    break;
                case 255:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Op("++", $$[$0]));
                    break;
                case 256:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Op("--", $$[$0 - 1], null, true));
                    break;
                case 257:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Op("++", $$[$0 - 1], null, true));
                    break;
                case 258:
                    this.$ = yy.addLocationDataFn(_$[$0 - 1], _$[$0])(new yy.Existence($$[$0 - 1]));
                    break;
                case 259:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Op("+", $$[$0 - 2], $$[$0]));
                    break;
                case 260:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Op("-", $$[$0 - 2], $$[$0]));
                    break;
                case 261:
                case 262:
                case 263:
                case 264:
                case 265:
                case 266:
                case 267:
                case 268:
                case 269:
                case 270:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Op($$[$0 - 1], $$[$0 - 2], $$[$0]));
                    break;
                case 271:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(function() {
                        if ($$[$0 - 1].charAt(0) === "!") {
                            return new yy.Op($$[$0 - 1].slice(1), $$[$0 - 2], $$[$0]).invert();
                        } else {
                            return new yy.Op($$[$0 - 1], $$[$0 - 2], $$[$0]);
                        }
                    }());
                    break;
                case 272:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Assign($$[$0 - 2], $$[$0], $$[$0 - 1]));
                    break;
                case 273:
                    this.$ = yy.addLocationDataFn(_$[$0 - 4], _$[$0])(new yy.Assign($$[$0 - 4], $$[$0 - 1], $$[$0 - 3]));
                    break;
                case 274:
                    this.$ = yy.addLocationDataFn(_$[$0 - 3], _$[$0])(new yy.Assign($$[$0 - 3], $$[$0], $$[$0 - 2]));
                    break;
                case 275:
                    this.$ = yy.addLocationDataFn(_$[$0 - 2], _$[$0])(new yy.Extends($$[$0 - 2], $$[$0]));
                    break;
            }
        },
        table: [
            {
                1: [
                    2,
                    1
                ],
                3: 1,
                4: 2,
                5: 3,
                7: 4,
                8: 5,
                9: 6,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                1: [
                    3
                ]
            },
            {
                1: [
                    2,
                    2
                ],
                6: $VG
            },
            o($VH, [
                2,
                3
            ]),
            o($VH, [
                2,
                6
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VH, [
                2,
                7
            ], {
                141: 77,
                132: 105,
                138: 106,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VX
            }),
            o($VH, [
                2,
                8
            ]),
            o($VY, [
                2,
                14
            ], {
                109: 107,
                78: 108,
                86: 114,
                40: $VZ,
                41: $VZ,
                114: $VZ,
                82: $V_,
                83: $V$,
                84: $V01,
                85: $V11,
                87: $V21,
                90: $V31,
                113: $V41
            }),
            o($VY, [
                2,
                15
            ], {
                86: 114,
                109: 117,
                78: 118,
                82: $V_,
                83: $V$,
                84: $V01,
                85: $V11,
                87: $V21,
                90: $V31,
                113: $V41,
                114: $VZ
            }),
            o($VY, [
                2,
                16
            ]),
            o($VY, [
                2,
                17
            ]),
            o($VY, [
                2,
                18
            ]),
            o($VY, [
                2,
                19
            ]),
            o($VY, [
                2,
                20
            ]),
            o($VY, [
                2,
                21
            ]),
            o($VY, [
                2,
                22
            ]),
            o($VY, [
                2,
                23
            ]),
            o($VY, [
                2,
                24
            ]),
            o($VY, [
                2,
                25
            ]),
            o($VY, [
                2,
                26
            ]),
            o($V51, [
                2,
                9
            ]),
            o($V51, [
                2,
                10
            ]),
            o($V51, [
                2,
                11
            ]),
            o($V51, [
                2,
                12
            ]),
            o($V51, [
                2,
                13
            ]),
            o([
                1,
                6,
                32,
                42,
                131,
                133,
                135,
                139,
                156,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174
            ], $V61, {
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                10: 20,
                11: 21,
                13: 23,
                14: 24,
                54: 26,
                47: 27,
                79: 28,
                80: 29,
                81: 30,
                111: 31,
                67: 33,
                77: 40,
                154: 41,
                132: 43,
                136: 44,
                138: 45,
                75: 53,
                62: 54,
                37: 55,
                43: 57,
                33: 70,
                60: 71,
                141: 77,
                39: 80,
                7: 120,
                8: 122,
                12: $V0,
                28: $V71,
                29: $V81,
                34: $V2,
                38: $V3,
                40: $V4,
                41: $V5,
                44: $V6,
                45: $V7,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                61: [
                    1,
                    119
                ],
                63: $Vf,
                64: $Vg,
                68: $Vh,
                69: $Vi,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                137: $Vw,
                149: $Vy,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            }),
            o($V91, $Va1, {
                55: [
                    1,
                    124
                ]
            }),
            o($V91, [
                2,
                96
            ]),
            o($V91, [
                2,
                97
            ]),
            o($V91, [
                2,
                98
            ]),
            o($V91, [
                2,
                99
            ]),
            o($Vb1, [
                2,
                164
            ]),
            o([
                6,
                31,
                66,
                71
            ], $Vc1, {
                65: 125,
                72: 126,
                73: 127,
                33: 129,
                60: 130,
                75: 131,
                62: 132,
                34: $V2,
                74: $Vd1,
                92: $Vj,
                118: $Ve1,
                119: $Vf1
            }),
            {
                30: 135,
                31: $Vg1
            },
            {
                7: 137,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 138,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 139,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 140,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                15: 142,
                16: 143,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 144,
                60: 71,
                62: 54,
                75: 53,
                77: 141,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                130: $Vt
            },
            {
                15: 142,
                16: 143,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 144,
                60: 71,
                62: 54,
                75: 53,
                77: 145,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                130: $Vt
            },
            o($Vh1, $Vi1, {
                96: [
                    1,
                    149
                ],
                161: [
                    1,
                    146
                ],
                162: [
                    1,
                    147
                ],
                175: [
                    1,
                    148
                ]
            }),
            o($VY, [
                2,
                246
            ], {
                151: [
                    1,
                    150
                ]
            }),
            {
                30: 151,
                31: $Vg1
            },
            {
                30: 152,
                31: $Vg1
            },
            o($VY, [
                2,
                210
            ]),
            {
                30: 153,
                31: $Vg1
            },
            {
                7: 154,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: [
                    1,
                    155
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($Vj1, [
                2,
                116
            ], {
                47: 27,
                79: 28,
                80: 29,
                81: 30,
                111: 31,
                75: 53,
                62: 54,
                37: 55,
                43: 57,
                33: 70,
                60: 71,
                39: 80,
                15: 142,
                16: 143,
                54: 144,
                30: 156,
                77: 158,
                31: $Vg1,
                34: $V2,
                38: $V3,
                40: $V4,
                41: $V5,
                44: $V6,
                45: $V7,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                92: $Vj,
                96: [
                    1,
                    157
                ],
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                130: $Vt
            }),
            {
                7: 159,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($V51, $Vk1, {
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                10: 20,
                11: 21,
                13: 23,
                14: 24,
                54: 26,
                47: 27,
                79: 28,
                80: 29,
                81: 30,
                111: 31,
                67: 33,
                77: 40,
                154: 41,
                132: 43,
                136: 44,
                138: 45,
                75: 53,
                62: 54,
                37: 55,
                43: 57,
                33: 70,
                60: 71,
                141: 77,
                39: 80,
                8: 122,
                7: 160,
                12: $V0,
                28: $V71,
                31: $Vl1,
                34: $V2,
                38: $V3,
                40: $V4,
                41: $V5,
                44: $V6,
                45: $V7,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                61: $Ve,
                63: $Vf,
                64: $Vg,
                68: $Vh,
                69: $Vi,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                137: $Vw,
                149: $Vy,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                71,
                94,
                131,
                133,
                135,
                139,
                156
            ], [
                2,
                67
            ]),
            {
                33: 166,
                34: $V2,
                39: 162,
                40: $V4,
                41: $V5,
                92: [
                    1,
                    165
                ],
                98: 163,
                99: 164,
                104: $Vm1
            },
            {
                25: 169,
                33: 170,
                34: $V2,
                92: [
                    1,
                    168
                ],
                95: $Vk,
                103: [
                    1,
                    171
                ],
                107: [
                    1,
                    172
                ]
            },
            o($Vh1, [
                2,
                93
            ]),
            o($Vh1, [
                2,
                94
            ]),
            o($V91, [
                2,
                40
            ]),
            o($V91, [
                2,
                41
            ]),
            o($V91, [
                2,
                42
            ]),
            o($V91, [
                2,
                43
            ]),
            o($V91, [
                2,
                44
            ]),
            o($V91, [
                2,
                45
            ]),
            o($V91, [
                2,
                46
            ]),
            o($V91, [
                2,
                47
            ]),
            {
                4: 173,
                5: 3,
                7: 4,
                8: 5,
                9: 6,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V1,
                31: [
                    1,
                    174
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 175,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: $Vn1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                74: $Vo1,
                75: 53,
                76: 180,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                116: 177,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                120: $Vp1,
                123: 178,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($V91, [
                2,
                171
            ]),
            o($V91, [
                2,
                172
            ], {
                35: 182,
                36: $Vq1
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                46,
                66,
                71,
                74,
                82,
                83,
                84,
                85,
                87,
                89,
                90,
                94,
                113,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                159,
                160,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174
            ], [
                2,
                165
            ], {
                110: 184,
                114: $Vr1
            }),
            {
                31: [
                    2,
                    70
                ]
            },
            {
                31: [
                    2,
                    71
                ]
            },
            o($Vs1, [
                2,
                88
            ]),
            o($Vs1, [
                2,
                91
            ]),
            {
                7: 186,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 187,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 188,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 190,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                30: 189,
                31: $Vg1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                33: 195,
                34: $V2,
                60: 196,
                62: 198,
                75: 197,
                80: 191,
                92: $Vj,
                118: $Ve1,
                119: $Vq,
                143: 192,
                144: [
                    1,
                    193
                ],
                145: 194
            },
            {
                142: 199,
                146: [
                    1,
                    200
                ],
                147: [
                    1,
                    201
                ],
                148: [
                    1,
                    202
                ]
            },
            o([
                6,
                31,
                71,
                94
            ], $Vt1, {
                39: 80,
                93: 203,
                56: 204,
                57: 205,
                59: 206,
                11: 207,
                37: 208,
                33: 209,
                35: 210,
                60: 211,
                34: $V2,
                36: $Vq1,
                38: $V3,
                40: $V4,
                41: $V5,
                63: $Vf,
                118: $Ve1
            }),
            o($Vu1, [
                2,
                34
            ]),
            o($Vu1, [
                2,
                35
            ]),
            o($V91, [
                2,
                38
            ]),
            {
                15: 142,
                16: 212,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 144,
                60: 71,
                62: 54,
                75: 53,
                77: 213,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                130: $Vt
            },
            o([
                1,
                6,
                29,
                31,
                32,
                40,
                41,
                42,
                55,
                58,
                66,
                71,
                74,
                82,
                83,
                84,
                85,
                87,
                89,
                90,
                94,
                96,
                102,
                113,
                114,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                146,
                147,
                148,
                156,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175
            ], [
                2,
                32
            ]),
            o($Vv1, [
                2,
                36
            ]),
            {
                4: 214,
                5: 3,
                7: 4,
                8: 5,
                9: 6,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VH, [
                2,
                5
            ], {
                7: 4,
                8: 5,
                9: 6,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                10: 20,
                11: 21,
                13: 23,
                14: 24,
                54: 26,
                47: 27,
                79: 28,
                80: 29,
                81: 30,
                111: 31,
                67: 33,
                77: 40,
                154: 41,
                132: 43,
                136: 44,
                138: 45,
                75: 53,
                62: 54,
                37: 55,
                43: 57,
                33: 70,
                60: 71,
                141: 77,
                39: 80,
                5: 215,
                12: $V0,
                28: $V1,
                34: $V2,
                38: $V3,
                40: $V4,
                41: $V5,
                44: $V6,
                45: $V7,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                61: $Ve,
                63: $Vf,
                64: $Vg,
                68: $Vh,
                69: $Vi,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                133: $Vu,
                135: $Vv,
                137: $Vw,
                139: $Vx,
                149: $Vy,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            }),
            o($VY, [
                2,
                258
            ]),
            {
                7: 216,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 217,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 218,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 219,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 220,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 221,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 222,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 223,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 224,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 225,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 226,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 227,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 228,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 229,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VY, [
                2,
                209
            ]),
            o($VY, [
                2,
                214
            ]),
            {
                7: 230,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VY, [
                2,
                208
            ]),
            o($VY, [
                2,
                213
            ]),
            {
                39: 231,
                40: $V4,
                41: $V5,
                110: 232,
                114: $Vr1
            },
            o($Vs1, [
                2,
                89
            ]),
            o($Vw1, [
                2,
                168
            ]),
            {
                35: 233,
                36: $Vq1
            },
            {
                35: 234,
                36: $Vq1
            },
            o($Vs1, [
                2,
                104
            ], {
                35: 235,
                36: $Vq1
            }),
            {
                35: 236,
                36: $Vq1
            },
            o($Vs1, [
                2,
                105
            ]),
            {
                7: 238,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                74: $Vx1,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                88: 237,
                91: 239,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                121: 240,
                122: $Vy1,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                86: 243,
                87: $V21,
                90: $V31
            },
            {
                110: 244,
                114: $Vr1
            },
            o($Vs1, [
                2,
                90
            ]),
            o($VH, [
                2,
                66
            ], {
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                10: 20,
                11: 21,
                13: 23,
                14: 24,
                54: 26,
                47: 27,
                79: 28,
                80: 29,
                81: 30,
                111: 31,
                67: 33,
                77: 40,
                154: 41,
                132: 43,
                136: 44,
                138: 45,
                75: 53,
                62: 54,
                37: 55,
                43: 57,
                33: 70,
                60: 71,
                141: 77,
                39: 80,
                8: 122,
                7: 245,
                12: $V0,
                28: $V71,
                31: $Vl1,
                34: $V2,
                38: $V3,
                40: $V4,
                41: $V5,
                44: $V6,
                45: $V7,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                61: $Ve,
                63: $Vf,
                64: $Vg,
                68: $Vh,
                69: $Vi,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                133: $Vk1,
                135: $Vk1,
                139: $Vk1,
                156: $Vk1,
                137: $Vw,
                149: $Vy,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            }),
            o($Vz1, [
                2,
                28
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                7: 246,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                132: 105,
                133: $Vu,
                135: $Vv,
                138: 106,
                139: $Vx,
                141: 77,
                156: $VX
            },
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174
            ], $V61, {
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                10: 20,
                11: 21,
                13: 23,
                14: 24,
                54: 26,
                47: 27,
                79: 28,
                80: 29,
                81: 30,
                111: 31,
                67: 33,
                77: 40,
                154: 41,
                132: 43,
                136: 44,
                138: 45,
                75: 53,
                62: 54,
                37: 55,
                43: 57,
                33: 70,
                60: 71,
                141: 77,
                39: 80,
                7: 120,
                8: 122,
                12: $V0,
                28: $V71,
                29: $V81,
                34: $V2,
                38: $V3,
                40: $V4,
                41: $V5,
                44: $V6,
                45: $V7,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                61: $Ve,
                63: $Vf,
                64: $Vg,
                68: $Vh,
                69: $Vi,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                137: $Vw,
                149: $Vy,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            }),
            {
                6: [
                    1,
                    248
                ],
                7: 247,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: [
                    1,
                    249
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o([
                6,
                31
            ], $VA1, {
                70: 252,
                66: [
                    1,
                    250
                ],
                71: $VB1
            }),
            o($VC1, [
                2,
                75
            ]),
            o($VC1, [
                2,
                79
            ], {
                55: [
                    1,
                    254
                ],
                74: [
                    1,
                    253
                ]
            }),
            o($VC1, [
                2,
                82
            ]),
            o($VD1, [
                2,
                83
            ]),
            o($VD1, [
                2,
                84
            ]),
            o($VD1, [
                2,
                85
            ]),
            o($VD1, [
                2,
                86
            ]),
            {
                35: 182,
                36: $Vq1
            },
            {
                7: 255,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: $Vn1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                74: $Vo1,
                75: 53,
                76: 180,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                116: 177,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                120: $Vp1,
                123: 178,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VY, [
                2,
                69
            ]),
            {
                4: 257,
                5: 3,
                7: 4,
                8: 5,
                9: 6,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V1,
                32: [
                    1,
                    256
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                159,
                160,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174
            ], [
                2,
                250
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL
            }),
            o($VE1, [
                2,
                251
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL,
                165: $VN
            }),
            o($VE1, [
                2,
                252
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL,
                165: $VN
            }),
            o($VE1, [
                2,
                253
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL,
                165: $VN
            }),
            o($VY, [
                2,
                254
            ], {
                40: $Vi1,
                41: $Vi1,
                82: $Vi1,
                83: $Vi1,
                84: $Vi1,
                85: $Vi1,
                87: $Vi1,
                90: $Vi1,
                113: $Vi1,
                114: $Vi1
            }),
            o($Vw1, $VZ, {
                109: 107,
                78: 108,
                86: 114,
                82: $V_,
                83: $V$,
                84: $V01,
                85: $V11,
                87: $V21,
                90: $V31,
                113: $V41
            }),
            {
                78: 118,
                82: $V_,
                83: $V$,
                84: $V01,
                85: $V11,
                86: 114,
                87: $V21,
                90: $V31,
                109: 117,
                113: $V41,
                114: $VZ
            },
            o($VF1, $Va1),
            o($VY, [
                2,
                255
            ], {
                40: $Vi1,
                41: $Vi1,
                82: $Vi1,
                83: $Vi1,
                84: $Vi1,
                85: $Vi1,
                87: $Vi1,
                90: $Vi1,
                113: $Vi1,
                114: $Vi1
            }),
            o($VY, [
                2,
                256
            ]),
            o($VY, [
                2,
                257
            ]),
            {
                6: [
                    1,
                    260
                ],
                7: 258,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: [
                    1,
                    259
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 261,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                30: 262,
                31: $Vg1,
                155: [
                    1,
                    263
                ]
            },
            o($VY, [
                2,
                193
            ], {
                126: 264,
                127: [
                    1,
                    265
                ],
                128: [
                    1,
                    266
                ]
            }),
            o($VY, [
                2,
                207
            ]),
            o($VY, [
                2,
                215
            ]),
            {
                31: [
                    1,
                    267
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            {
                150: 268,
                152: 269,
                153: $VG1
            },
            o($VY, [
                2,
                117
            ]),
            {
                7: 271,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($Vj1, [
                2,
                120
            ], {
                30: 272,
                31: $Vg1,
                40: $Vi1,
                41: $Vi1,
                82: $Vi1,
                83: $Vi1,
                84: $Vi1,
                85: $Vi1,
                87: $Vi1,
                90: $Vi1,
                113: $Vi1,
                114: $Vi1,
                96: [
                    1,
                    273
                ]
            }),
            o($Vz1, [
                2,
                200
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($V51, $VH1, {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                62: 274,
                92: $Vj
            },
            o($V51, [
                2,
                124
            ]),
            {
                29: [
                    1,
                    275
                ],
                71: [
                    1,
                    276
                ]
            },
            {
                29: [
                    1,
                    277
                ]
            },
            {
                31: $VI1,
                33: 282,
                34: $V2,
                94: [
                    1,
                    278
                ],
                100: 279,
                101: 280,
                103: $VJ1
            },
            o([
                29,
                71
            ], [
                2,
                140
            ]),
            {
                102: [
                    1,
                    284
                ]
            },
            {
                31: $VK1,
                33: 289,
                34: $V2,
                94: [
                    1,
                    285
                ],
                103: $VL1,
                106: 286,
                108: 287
            },
            o($V51, [
                2,
                144
            ]),
            {
                55: [
                    1,
                    291
                ]
            },
            {
                7: 292,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                29: [
                    1,
                    293
                ]
            },
            {
                6: $VG,
                131: [
                    1,
                    294
                ]
            },
            {
                4: 295,
                5: 3,
                7: 4,
                8: 5,
                9: 6,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o([
                6,
                31,
                71,
                120
            ], $VM1, {
                141: 77,
                132: 102,
                138: 103,
                121: 296,
                74: [
                    1,
                    297
                ],
                122: $Vy1,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VN1, [
                2,
                174
            ]),
            o([
                6,
                31,
                120
            ], $VA1, {
                70: 298,
                71: $VO1
            }),
            o($VP1, [
                2,
                183
            ]),
            {
                7: 255,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: $Vn1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                74: $Vo1,
                75: 53,
                76: 180,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                116: 300,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                123: 178,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VP1, [
                2,
                189
            ]),
            o($VP1, [
                2,
                190
            ]),
            o($VQ1, [
                2,
                173
            ]),
            o($VQ1, [
                2,
                33
            ]),
            o($Vb1, [
                2,
                166
            ]),
            {
                7: 255,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: $Vn1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                74: $Vo1,
                75: 53,
                76: 180,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                115: [
                    1,
                    301
                ],
                116: 302,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                123: 178,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                30: 303,
                31: $Vg1,
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            o($VR1, [
                2,
                203
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                134: [
                    1,
                    304
                ],
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VR1, [
                2,
                205
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                134: [
                    1,
                    305
                ],
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VY, [
                2,
                211
            ]),
            o($VS1, [
                2,
                212
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                156,
                159,
                160,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174
            ], [
                2,
                216
            ], {
                140: [
                    1,
                    306
                ]
            }),
            o($VT1, [
                2,
                219
            ]),
            {
                33: 195,
                34: $V2,
                60: 196,
                62: 198,
                75: 197,
                92: $Vj,
                118: $Ve1,
                119: $Vf1,
                143: 307,
                145: 194
            },
            o($VT1, [
                2,
                225
            ], {
                71: [
                    1,
                    308
                ]
            }),
            o($VU1, [
                2,
                221
            ]),
            o($VU1, [
                2,
                222
            ]),
            o($VU1, [
                2,
                223
            ]),
            o($VU1, [
                2,
                224
            ]),
            o($VY, [
                2,
                218
            ]),
            {
                7: 309,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 310,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 311,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VV1, $VA1, {
                70: 312,
                71: $VW1
            }),
            o($VX1, [
                2,
                112
            ]),
            o($VX1, [
                2,
                51
            ], {
                58: [
                    1,
                    314
                ]
            }),
            o($VY1, [
                2,
                60
            ], {
                55: [
                    1,
                    315
                ]
            }),
            o($VX1, [
                2,
                56
            ]),
            o($VY1, [
                2,
                61
            ]),
            o($VZ1, [
                2,
                57
            ]),
            o($VZ1, [
                2,
                58
            ]),
            o($VZ1, [
                2,
                59
            ]),
            {
                46: [
                    1,
                    316
                ],
                78: 118,
                82: $V_,
                83: $V$,
                84: $V01,
                85: $V11,
                86: 114,
                87: $V21,
                90: $V31,
                109: 117,
                113: $V41,
                114: $VZ
            },
            o($VF1, $Vi1),
            {
                6: $VG,
                42: [
                    1,
                    317
                ]
            },
            o($VH, [
                2,
                4
            ]),
            o($V_1, [
                2,
                259
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL,
                164: $VM,
                165: $VN
            }),
            o($V_1, [
                2,
                260
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL,
                164: $VM,
                165: $VN
            }),
            o($VE1, [
                2,
                261
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL,
                165: $VN
            }),
            o($VE1, [
                2,
                262
            ], {
                141: 77,
                132: 102,
                138: 103,
                163: $VL,
                165: $VN
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174
            ], [
                2,
                263
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                167,
                168,
                169,
                170,
                171,
                172,
                173
            ], [
                2,
                264
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                168,
                169,
                170,
                171,
                172,
                173
            ], [
                2,
                265
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                169,
                170,
                171,
                172,
                173
            ], [
                2,
                266
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                170,
                171,
                172,
                173
            ], [
                2,
                267
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                171,
                172,
                173
            ], [
                2,
                268
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                172,
                173
            ], [
                2,
                269
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                173
            ], [
                2,
                270
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                174: $VW
            }),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                140,
                156,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174
            ], [
                2,
                271
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO
            }),
            o($VS1, [
                2,
                249
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VS1, [
                2,
                248
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vb1, [
                2,
                161
            ]),
            o($Vb1, [
                2,
                162
            ]),
            o($Vs1, [
                2,
                100
            ]),
            o($Vs1, [
                2,
                101
            ]),
            o($Vs1, [
                2,
                102
            ]),
            o($Vs1, [
                2,
                103
            ]),
            {
                89: [
                    1,
                    318
                ]
            },
            {
                74: $Vx1,
                89: [
                    2,
                    108
                ],
                121: 319,
                122: $Vy1,
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            {
                89: [
                    2,
                    109
                ]
            },
            {
                7: 320,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                89: [
                    2,
                    182
                ],
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($V$1, [
                2,
                176
            ]),
            o($V$1, $V02),
            o($Vs1, [
                2,
                107
            ]),
            o($Vb1, [
                2,
                163
            ]),
            o($VH, [
                2,
                65
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $VH1,
                135: $VH1,
                139: $VH1,
                156: $VH1,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vz1, [
                2,
                29
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vz1, [
                2,
                48
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                7: 321,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 322,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                67: 323,
                68: $Vh,
                69: $Vi
            },
            o($V12, $V22, {
                73: 127,
                33: 129,
                60: 130,
                75: 131,
                62: 132,
                72: 324,
                34: $V2,
                74: $Vd1,
                92: $Vj,
                118: $Ve1,
                119: $Vf1
            }),
            {
                6: $V32,
                31: $V42
            },
            o($VC1, [
                2,
                80
            ]),
            {
                7: 327,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VP1, $VM1, {
                141: 77,
                132: 102,
                138: 103,
                74: [
                    1,
                    328
                ],
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($V52, [
                2,
                30
            ]),
            {
                6: $VG,
                32: [
                    1,
                    329
                ]
            },
            o($Vz1, [
                2,
                272
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                7: 330,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 331,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($Vz1, [
                2,
                275
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VY, [
                2,
                247
            ]),
            {
                7: 332,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VY, [
                2,
                194
            ], {
                127: [
                    1,
                    333
                ]
            }),
            {
                30: 334,
                31: $Vg1
            },
            {
                30: 337,
                31: $Vg1,
                33: 335,
                34: $V2,
                62: 336,
                92: $Vj
            },
            {
                150: 338,
                152: 269,
                153: $VG1
            },
            {
                32: [
                    1,
                    339
                ],
                151: [
                    1,
                    340
                ],
                152: 341,
                153: $VG1
            },
            o($V62, [
                2,
                240
            ]),
            {
                7: 343,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                124: 342,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($V72, [
                2,
                118
            ], {
                141: 77,
                132: 102,
                138: 103,
                30: 344,
                31: $Vg1,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VY, [
                2,
                121
            ]),
            {
                7: 345,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                32: [
                    1,
                    346
                ]
            },
            {
                39: 347,
                40: $V4,
                41: $V5
            },
            {
                92: [
                    1,
                    349
                ],
                99: 348,
                104: $Vm1
            },
            {
                39: 350,
                40: $V4,
                41: $V5
            },
            {
                29: [
                    1,
                    351
                ]
            },
            o($VV1, $VA1, {
                70: 352,
                71: $V82
            }),
            o($VX1, [
                2,
                131
            ]),
            {
                31: $VI1,
                33: 282,
                34: $V2,
                100: 354,
                101: 280,
                103: $VJ1
            },
            o($VX1, [
                2,
                136
            ], {
                102: [
                    1,
                    355
                ]
            }),
            o($VX1, [
                2,
                138
            ], {
                102: [
                    1,
                    356
                ]
            }),
            {
                33: 357,
                34: $V2
            },
            o($V51, [
                2,
                142
            ]),
            o($VV1, $VA1, {
                70: 358,
                71: $V92
            }),
            o($VX1, [
                2,
                151
            ]),
            {
                31: $VK1,
                33: 289,
                34: $V2,
                103: $VL1,
                106: 360,
                108: 287
            },
            o($VX1, [
                2,
                156
            ], {
                102: [
                    1,
                    361
                ]
            }),
            o($VX1, [
                2,
                159
            ], {
                102: [
                    1,
                    362
                ]
            }),
            {
                6: [
                    1,
                    364
                ],
                7: 363,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: [
                    1,
                    365
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($Va2, [
                2,
                148
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                39: 366,
                40: $V4,
                41: $V5
            },
            o($V91, [
                2,
                201
            ]),
            {
                6: $VG,
                32: [
                    1,
                    367
                ]
            },
            {
                7: 368,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o([
                12,
                28,
                34,
                38,
                40,
                41,
                44,
                45,
                48,
                49,
                50,
                51,
                52,
                53,
                61,
                63,
                64,
                68,
                69,
                92,
                95,
                97,
                105,
                112,
                117,
                118,
                119,
                125,
                129,
                130,
                133,
                135,
                137,
                139,
                149,
                155,
                157,
                158,
                159,
                160,
                161,
                162
            ], $V02, {
                6: $Vb2,
                31: $Vb2,
                71: $Vb2,
                120: $Vb2
            }),
            {
                6: $Vc2,
                31: $Vd2,
                120: [
                    1,
                    369
                ]
            },
            o([
                6,
                31,
                32,
                115,
                120
            ], $V22, {
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                10: 20,
                11: 21,
                13: 23,
                14: 24,
                54: 26,
                47: 27,
                79: 28,
                80: 29,
                81: 30,
                111: 31,
                67: 33,
                77: 40,
                154: 41,
                132: 43,
                136: 44,
                138: 45,
                75: 53,
                62: 54,
                37: 55,
                43: 57,
                33: 70,
                60: 71,
                141: 77,
                39: 80,
                8: 122,
                76: 180,
                7: 255,
                123: 372,
                12: $V0,
                28: $V71,
                34: $V2,
                38: $V3,
                40: $V4,
                41: $V5,
                44: $V6,
                45: $V7,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                61: $Ve,
                63: $Vf,
                64: $Vg,
                68: $Vh,
                69: $Vi,
                74: $Vo1,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                133: $Vu,
                135: $Vv,
                137: $Vw,
                139: $Vx,
                149: $Vy,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            }),
            o($V12, $VA1, {
                70: 373,
                71: $VO1
            }),
            o($Vb1, [
                2,
                169
            ]),
            o([
                6,
                31,
                115
            ], $VA1, {
                70: 374,
                71: $VO1
            }),
            o($Ve2, [
                2,
                244
            ]),
            {
                7: 375,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 376,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 377,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VT1, [
                2,
                220
            ]),
            {
                33: 195,
                34: $V2,
                60: 196,
                62: 198,
                75: 197,
                92: $Vj,
                118: $Ve1,
                119: $Vf1,
                145: 378
            },
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                135,
                139,
                156
            ], [
                2,
                227
            ], {
                141: 77,
                132: 102,
                138: 103,
                134: [
                    1,
                    379
                ],
                140: [
                    1,
                    380
                ],
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vf2, [
                2,
                228
            ], {
                141: 77,
                132: 102,
                138: 103,
                134: [
                    1,
                    381
                ],
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vf2, [
                2,
                234
            ], {
                141: 77,
                132: 102,
                138: 103,
                134: [
                    1,
                    382
                ],
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                6: $Vg2,
                31: $Vh2,
                94: [
                    1,
                    383
                ]
            },
            o($Vi2, $V22, {
                39: 80,
                57: 205,
                59: 206,
                11: 207,
                37: 208,
                33: 209,
                35: 210,
                60: 211,
                56: 386,
                34: $V2,
                36: $Vq1,
                38: $V3,
                40: $V4,
                41: $V5,
                63: $Vf,
                118: $Ve1
            }),
            {
                7: 387,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: [
                    1,
                    388
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 389,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: [
                    1,
                    390
                ],
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($V91, [
                2,
                39
            ]),
            o($Vv1, [
                2,
                37
            ]),
            o($Vs1, [
                2,
                106
            ]),
            {
                7: 391,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                89: [
                    2,
                    180
                ],
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                89: [
                    2,
                    181
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            o($Vz1, [
                2,
                49
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                32: [
                    1,
                    392
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            {
                30: 393,
                31: $Vg1
            },
            o($VC1, [
                2,
                76
            ]),
            {
                33: 129,
                34: $V2,
                60: 130,
                62: 132,
                72: 394,
                73: 127,
                74: $Vd1,
                75: 131,
                92: $Vj,
                118: $Ve1,
                119: $Vf1
            },
            o($Vj2, $Vc1, {
                72: 126,
                73: 127,
                33: 129,
                60: 130,
                75: 131,
                62: 132,
                65: 395,
                34: $V2,
                74: $Vd1,
                92: $Vj,
                118: $Ve1,
                119: $Vf1
            }),
            o($VC1, [
                2,
                81
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VP1, $Vb2),
            o($V52, [
                2,
                31
            ]),
            {
                32: [
                    1,
                    396
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            o($Vz1, [
                2,
                274
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                30: 397,
                31: $Vg1,
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            {
                30: 398,
                31: $Vg1
            },
            o($VY, [
                2,
                195
            ]),
            {
                30: 399,
                31: $Vg1
            },
            {
                30: 400,
                31: $Vg1
            },
            o($Vk2, [
                2,
                199
            ]),
            {
                32: [
                    1,
                    401
                ],
                151: [
                    1,
                    402
                ],
                152: 341,
                153: $VG1
            },
            o($VY, [
                2,
                238
            ]),
            {
                30: 403,
                31: $Vg1
            },
            o($V62, [
                2,
                241
            ]),
            {
                30: 404,
                31: $Vg1,
                71: [
                    1,
                    405
                ]
            },
            o($Vl2, [
                2,
                191
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VY, [
                2,
                119
            ]),
            o($V72, [
                2,
                122
            ], {
                141: 77,
                132: 102,
                138: 103,
                30: 406,
                31: $Vg1,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($V51, [
                2,
                63
            ]),
            o($V51, [
                2,
                125
            ]),
            {
                29: [
                    1,
                    407
                ]
            },
            {
                31: $VI1,
                33: 282,
                34: $V2,
                100: 408,
                101: 280,
                103: $VJ1
            },
            o($V51, [
                2,
                126
            ]),
            {
                39: 409,
                40: $V4,
                41: $V5
            },
            {
                6: $Vm2,
                31: $Vn2,
                94: [
                    1,
                    410
                ]
            },
            o($Vi2, $V22, {
                33: 282,
                101: 413,
                34: $V2,
                103: $VJ1
            }),
            o($V12, $VA1, {
                70: 414,
                71: $V82
            }),
            {
                33: 415,
                34: $V2
            },
            {
                33: 416,
                34: $V2
            },
            {
                29: [
                    2,
                    141
                ]
            },
            {
                6: $Vo2,
                31: $Vp2,
                94: [
                    1,
                    417
                ]
            },
            o($Vi2, $V22, {
                33: 289,
                108: 420,
                34: $V2,
                103: $VL1
            }),
            o($V12, $VA1, {
                70: 421,
                71: $V92
            }),
            {
                33: 422,
                34: $V2,
                103: [
                    1,
                    423
                ]
            },
            {
                33: 424,
                34: $V2
            },
            o($Va2, [
                2,
                145
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                7: 425,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 426,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($V51, [
                2,
                149
            ]),
            {
                131: [
                    1,
                    427
                ]
            },
            {
                120: [
                    1,
                    428
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            o($VN1, [
                2,
                175
            ]),
            {
                7: 255,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                74: $Vo1,
                75: 53,
                76: 180,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                123: 429,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 255,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                31: $Vn1,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                74: $Vo1,
                75: 53,
                76: 180,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                116: 430,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                123: 178,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VP1, [
                2,
                184
            ]),
            {
                6: $Vc2,
                31: $Vd2,
                32: [
                    1,
                    431
                ]
            },
            {
                6: $Vc2,
                31: $Vd2,
                115: [
                    1,
                    432
                ]
            },
            o($VS1, [
                2,
                204
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VS1, [
                2,
                206
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VS1, [
                2,
                217
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VT1, [
                2,
                226
            ]),
            {
                7: 433,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 434,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 435,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 436,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VN1, [
                2,
                110
            ]),
            {
                11: 207,
                33: 209,
                34: $V2,
                35: 210,
                36: $Vq1,
                37: 208,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                56: 437,
                57: 205,
                59: 206,
                60: 211,
                63: $Vf,
                118: $Ve1
            },
            o($Vj2, $Vt1, {
                39: 80,
                56: 204,
                57: 205,
                59: 206,
                11: 207,
                37: 208,
                33: 209,
                35: 210,
                60: 211,
                93: 438,
                34: $V2,
                36: $Vq1,
                38: $V3,
                40: $V4,
                41: $V5,
                63: $Vf,
                118: $Ve1
            }),
            o($VX1, [
                2,
                113
            ]),
            o($VX1, [
                2,
                52
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                7: 439,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VX1, [
                2,
                54
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                7: 440,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                89: [
                    2,
                    179
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            o($VY, [
                2,
                50
            ]),
            o($VY, [
                2,
                68
            ]),
            o($VC1, [
                2,
                77
            ]),
            o($V12, $VA1, {
                70: 441,
                71: $VB1
            }),
            o($VY, [
                2,
                273
            ]),
            o($Ve2, [
                2,
                245
            ]),
            o($VY, [
                2,
                196
            ]),
            o($Vk2, [
                2,
                197
            ]),
            o($Vk2, [
                2,
                198
            ]),
            o($VY, [
                2,
                236
            ]),
            {
                30: 442,
                31: $Vg1
            },
            {
                32: [
                    1,
                    443
                ]
            },
            o($V62, [
                2,
                242
            ], {
                6: [
                    1,
                    444
                ]
            }),
            {
                7: 445,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            o($VY, [
                2,
                123
            ]),
            {
                39: 446,
                40: $V4,
                41: $V5
            },
            o($VV1, $VA1, {
                70: 447,
                71: $V82
            }),
            o($V51, [
                2,
                127
            ]),
            {
                29: [
                    1,
                    448
                ]
            },
            {
                33: 282,
                34: $V2,
                101: 449,
                103: $VJ1
            },
            {
                31: $VI1,
                33: 282,
                34: $V2,
                100: 450,
                101: 280,
                103: $VJ1
            },
            o($VX1, [
                2,
                132
            ]),
            {
                6: $Vm2,
                31: $Vn2,
                32: [
                    1,
                    451
                ]
            },
            o($VX1, [
                2,
                137
            ]),
            o($VX1, [
                2,
                139
            ]),
            o($V51, [
                2,
                143
            ], {
                29: [
                    1,
                    452
                ]
            }),
            {
                33: 289,
                34: $V2,
                103: $VL1,
                108: 453
            },
            {
                31: $VK1,
                33: 289,
                34: $V2,
                103: $VL1,
                106: 454,
                108: 287
            },
            o($VX1, [
                2,
                152
            ]),
            {
                6: $Vo2,
                31: $Vp2,
                32: [
                    1,
                    455
                ]
            },
            o($VX1, [
                2,
                157
            ]),
            o($VX1, [
                2,
                158
            ]),
            o($VX1, [
                2,
                160
            ]),
            o($Va2, [
                2,
                146
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            {
                32: [
                    1,
                    456
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            o($V91, [
                2,
                202
            ]),
            o($V91, [
                2,
                178
            ]),
            o($VP1, [
                2,
                185
            ]),
            o($V12, $VA1, {
                70: 457,
                71: $VO1
            }),
            o($VP1, [
                2,
                186
            ]),
            o($Vb1, [
                2,
                170
            ]),
            o([
                1,
                6,
                31,
                32,
                42,
                66,
                71,
                74,
                89,
                94,
                115,
                120,
                122,
                131,
                133,
                134,
                135,
                139,
                156
            ], [
                2,
                229
            ], {
                141: 77,
                132: 102,
                138: 103,
                140: [
                    1,
                    458
                ],
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vf2, [
                2,
                231
            ], {
                141: 77,
                132: 102,
                138: 103,
                134: [
                    1,
                    459
                ],
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vz1, [
                2,
                230
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vz1, [
                2,
                235
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VX1, [
                2,
                114
            ]),
            o($V12, $VA1, {
                70: 460,
                71: $VW1
            }),
            {
                32: [
                    1,
                    461
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            {
                32: [
                    1,
                    462
                ],
                132: 102,
                133: $Vu,
                135: $Vv,
                138: 103,
                139: $Vx,
                141: 77,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            },
            {
                6: $V32,
                31: $V42,
                32: [
                    1,
                    463
                ]
            },
            {
                32: [
                    1,
                    464
                ]
            },
            o($VY, [
                2,
                239
            ]),
            o($V62, [
                2,
                243
            ]),
            o($Vl2, [
                2,
                192
            ], {
                141: 77,
                132: 102,
                138: 103,
                133: $Vu,
                135: $Vv,
                139: $Vx,
                156: $VI,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($V51, [
                2,
                129
            ]),
            {
                6: $Vm2,
                31: $Vn2,
                94: [
                    1,
                    465
                ]
            },
            {
                39: 466,
                40: $V4,
                41: $V5
            },
            o($VX1, [
                2,
                133
            ]),
            o($V12, $VA1, {
                70: 467,
                71: $V82
            }),
            o($VX1, [
                2,
                134
            ]),
            {
                39: 468,
                40: $V4,
                41: $V5
            },
            o($VX1, [
                2,
                153
            ]),
            o($V12, $VA1, {
                70: 469,
                71: $V92
            }),
            o($VX1, [
                2,
                154
            ]),
            o($V51, [
                2,
                147
            ]),
            {
                6: $Vc2,
                31: $Vd2,
                32: [
                    1,
                    470
                ]
            },
            {
                7: 471,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                7: 472,
                8: 122,
                10: 20,
                11: 21,
                12: $V0,
                13: 23,
                14: 24,
                15: 7,
                16: 8,
                17: 9,
                18: 10,
                19: 11,
                20: 12,
                21: 13,
                22: 14,
                23: 15,
                24: 16,
                25: 17,
                26: 18,
                27: 19,
                28: $V71,
                33: 70,
                34: $V2,
                37: 55,
                38: $V3,
                39: 80,
                40: $V4,
                41: $V5,
                43: 57,
                44: $V6,
                45: $V7,
                47: 27,
                48: $V8,
                49: $V9,
                50: $Va,
                51: $Vb,
                52: $Vc,
                53: $Vd,
                54: 26,
                60: 71,
                61: $Ve,
                62: 54,
                63: $Vf,
                64: $Vg,
                67: 33,
                68: $Vh,
                69: $Vi,
                75: 53,
                77: 40,
                79: 28,
                80: 29,
                81: 30,
                92: $Vj,
                95: $Vk,
                97: $Vl,
                105: $Vm,
                111: 31,
                112: $Vn,
                117: $Vo,
                118: $Vp,
                119: $Vq,
                125: $Vr,
                129: $Vs,
                130: $Vt,
                132: 43,
                133: $Vu,
                135: $Vv,
                136: 44,
                137: $Vw,
                138: 45,
                139: $Vx,
                141: 77,
                149: $Vy,
                154: 41,
                155: $Vz,
                157: $VA,
                158: $VB,
                159: $VC,
                160: $VD,
                161: $VE,
                162: $VF
            },
            {
                6: $Vg2,
                31: $Vh2,
                32: [
                    1,
                    473
                ]
            },
            o($VX1, [
                2,
                53
            ]),
            o($VX1, [
                2,
                55
            ]),
            o($VC1, [
                2,
                78
            ]),
            o($VY, [
                2,
                237
            ]),
            {
                29: [
                    1,
                    474
                ]
            },
            o($V51, [
                2,
                128
            ]),
            {
                6: $Vm2,
                31: $Vn2,
                32: [
                    1,
                    475
                ]
            },
            o($V51, [
                2,
                150
            ]),
            {
                6: $Vo2,
                31: $Vp2,
                32: [
                    1,
                    476
                ]
            },
            o($VP1, [
                2,
                187
            ]),
            o($Vz1, [
                2,
                232
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($Vz1, [
                2,
                233
            ], {
                141: 77,
                132: 102,
                138: 103,
                159: $VJ,
                160: $VK,
                163: $VL,
                164: $VM,
                165: $VN,
                166: $VO,
                167: $VP,
                168: $VQ,
                169: $VR,
                170: $VS,
                171: $VT,
                172: $VU,
                173: $VV,
                174: $VW
            }),
            o($VX1, [
                2,
                115
            ]),
            {
                39: 477,
                40: $V4,
                41: $V5
            },
            o($VX1, [
                2,
                135
            ]),
            o($VX1, [
                2,
                155
            ]),
            o($V51, [
                2,
                130
            ])
        ],
        defaultActions: {
            68: [
                2,
                70
            ],
            69: [
                2,
                71
            ],
            239: [
                2,
                109
            ],
            357: [
                2,
                141
            ]
        },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str);
            } else {
                function _parseError(msg, hash) {
                    this.message = msg;
                    this.hash = hash;
                }
                _parseError.prototype = Error;
                throw new _parseError(str, hash);
            }
        },
        parse: function parse(input) {
            var self = this, stack = [
                0
            ], tstack = [], vstack = [
                null
            ], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            var lexer = Object.create(this.lexer);
            var sharedState = {
                yy: {}
            };
            for(var k in this.yy){
                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                    sharedState.yy[k] = this.yy[k];
                }
            }
            lexer.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer;
            sharedState.yy.parser = this;
            if (typeof lexer.yylloc == "undefined") {
                lexer.yylloc = {};
            }
            var yyloc = lexer.yylloc;
            lstack.push(yyloc);
            var ranges = lexer.options && lexer.options.ranges;
            if (typeof sharedState.yy.parseError === "function") {
                this.parseError = sharedState.yy.parseError;
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError;
            }
            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }
            _token_stack: var lex = function() {
                var token;
                token = lexer.lex() || EOF;
                if (typeof token !== "number") {
                    token = self.symbols_[token] || token;
                }
                return token;
            };
            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while(true){
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex();
                    }
                    action = table[state] && table[state][symbol];
                }
                if (typeof action === "undefined" || !action.length || !action[0]) {
                    var errStr = "";
                    expected = [];
                    for(p in table[state]){
                        if (this.terminals_[p] && p > TERROR) {
                            expected.push("'" + this.terminals_[p] + "'");
                        }
                    }
                    if (lexer.showPosition) {
                        errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                    } else {
                        errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                    }
                    this.parseError(errStr, {
                        text: lexer.match,
                        token: this.terminals_[symbol] || symbol,
                        line: lexer.yylineno,
                        loc: yyloc,
                        expected: expected
                    });
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch(action[0]){
                    case 1:
                        stack.push(symbol);
                        vstack.push(lexer.yytext);
                        lstack.push(lexer.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        if (!preErrorSymbol) {
                            yyleng = lexer.yyleng;
                            yytext = lexer.yytext;
                            yylineno = lexer.yylineno;
                            yyloc = lexer.yylloc;
                            if (recovering > 0) {
                                recovering--;
                            }
                        } else {
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [
                                lstack[lstack.length - (len || 1)].range[0],
                                lstack[lstack.length - 1].range[1]
                            ];
                        }
                        r = this.performAction.apply(yyval, [
                            yytext,
                            yyleng,
                            yylineno,
                            sharedState.yy,
                            action[1],
                            vstack,
                            lstack
                        ].concat(args));
                        if (typeof r !== "undefined") {
                            return r;
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        }
    };
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser;
}();
if (true) {
    exports.parser = parser;
    exports.Parser = parser.Parser;
    exports.parse = function() {
        return parser.parse.apply(parser, arguments);
    };
    exports.main = function commonjsMain(args) {
        if (!args[1]) {
            console.log("Usage: " + args[0] + " FILE");
            process.exit(1);
        }
        var source = "";
        var fs = __webpack_require__(57147);
        if (typeof fs !== "undefined" && fs !== null) source = fs.readFileSync((__webpack_require__(71017).normalize)(args[1]), "utf8");
        return exports.parser.parse(source);
    };
    if ( true && __webpack_require__.c[__webpack_require__.s] === module) {
        exports.main(process.argv.slice(1));
    }
}


/***/ }),

/***/ 21957:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
    var CoffeeScript, Module, binary, child_process, ext, findExtension, fork, helpers, i, len, loadFile, path, ref;
    CoffeeScript = __webpack_require__(88933);
    child_process = __webpack_require__(32081);
    helpers = __webpack_require__(18765);
    path = __webpack_require__(71017);
    loadFile = function(module, filename) {
        var answer;
        answer = CoffeeScript._compileFile(filename, false, true);
        return module._compile(answer, filename);
    };
    if ((void 0)) {
        ref = CoffeeScript.FILE_EXTENSIONS;
        for(i = 0, len = ref.length; i < len; i++){
            ext = ref[i];
            (void 0)[ext] = loadFile;
        }
        Module = __webpack_require__(98188);
        findExtension = function(filename) {
            var curExtension, extensions;
            extensions = path.basename(filename).split(".");
            if (extensions[0] === "") {
                extensions.shift();
            }
            while(extensions.shift()){
                curExtension = "." + extensions.join(".");
                if (Module._extensions[curExtension]) {
                    return curExtension;
                }
            }
            return ".js";
        };
        Module.prototype.load = function(filename) {
            var extension;
            this.filename = filename;
            this.paths = Module._nodeModulePaths(path.dirname(filename));
            extension = findExtension(filename);
            Module._extensions[extension](this, filename);
            return this.loaded = true;
        };
    }
    if (child_process) {
        fork = child_process.fork;
        binary = /*require.resolve*/(70442);
        child_process.fork = function(path, args, options) {
            if (helpers.isCoffee(path)) {
                if (!Array.isArray(args)) {
                    options = args || {};
                    args = [];
                }
                args = [
                    path
                ].concat(args);
                path = binary;
            }
            return fork(path, args, options);
        };
    }
}).call(this);


/***/ }),

/***/ 56106:
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
    var BALANCED_PAIRS, CALL_CLOSERS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, Rewriter, SINGLE_CLOSERS, SINGLE_LINERS, generate, k, left, len, ref, rite, indexOf = [].indexOf || function(item) {
        for(var i = 0, l = this.length; i < l; i++){
            if (i in this && this[i] === item) return i;
        }
        return -1;
    }, slice = [].slice;
    generate = function(tag, value, origin) {
        var tok;
        tok = [
            tag,
            value
        ];
        tok.generated = true;
        if (origin) {
            tok.origin = origin;
        }
        return tok;
    };
    exports.Rewriter = Rewriter = function() {
        function Rewriter() {}
        Rewriter.prototype.rewrite = function(tokens1) {
            this.tokens = tokens1;
            this.removeLeadingNewlines();
            this.closeOpenCalls();
            this.closeOpenIndexes();
            this.normalizeLines();
            this.tagPostfixConditionals();
            this.addImplicitBracesAndParens();
            this.addLocationDataToGeneratedTokens();
            this.fixOutdentLocationData();
            return this.tokens;
        };
        Rewriter.prototype.scanTokens = function(block) {
            var i, token, tokens;
            tokens = this.tokens;
            i = 0;
            while(token = tokens[i]){
                i += block.call(this, token, i, tokens);
            }
            return true;
        };
        Rewriter.prototype.detectEnd = function(i, condition, action) {
            var levels, ref, ref1, token, tokens;
            tokens = this.tokens;
            levels = 0;
            while(token = tokens[i]){
                if (levels === 0 && condition.call(this, token, i)) {
                    return action.call(this, token, i);
                }
                if (!token || levels < 0) {
                    return action.call(this, token, i - 1);
                }
                if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) {
                    levels += 1;
                } else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) {
                    levels -= 1;
                }
                i += 1;
            }
            return i - 1;
        };
        Rewriter.prototype.removeLeadingNewlines = function() {
            var i, k, len, ref, tag;
            ref = this.tokens;
            for(i = k = 0, len = ref.length; k < len; i = ++k){
                tag = ref[i][0];
                if (tag !== "TERMINATOR") {
                    break;
                }
            }
            if (i) {
                return this.tokens.splice(0, i);
            }
        };
        Rewriter.prototype.closeOpenCalls = function() {
            var action, condition;
            condition = function(token, i) {
                var ref;
                return (ref = token[0]) === ")" || ref === "CALL_END" || token[0] === "OUTDENT" && this.tag(i - 1) === ")";
            };
            action = function(token, i) {
                return this.tokens[token[0] === "OUTDENT" ? i - 1 : i][0] = "CALL_END";
            };
            return this.scanTokens(function(token, i) {
                if (token[0] === "CALL_START") {
                    this.detectEnd(i + 1, condition, action);
                }
                return 1;
            });
        };
        Rewriter.prototype.closeOpenIndexes = function() {
            var action, condition;
            condition = function(token, i) {
                var ref;
                return (ref = token[0]) === "]" || ref === "INDEX_END";
            };
            action = function(token, i) {
                return token[0] = "INDEX_END";
            };
            return this.scanTokens(function(token, i) {
                if (token[0] === "INDEX_START") {
                    this.detectEnd(i + 1, condition, action);
                }
                return 1;
            });
        };
        Rewriter.prototype.indexOfTag = function() {
            var fuzz, i, j, k, pattern, ref, ref1;
            i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            fuzz = 0;
            for(j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k){
                while(this.tag(i + j + fuzz) === "HERECOMMENT"){
                    fuzz += 2;
                }
                if (pattern[j] == null) {
                    continue;
                }
                if (typeof pattern[j] === "string") {
                    pattern[j] = [
                        pattern[j]
                    ];
                }
                if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) {
                    return -1;
                }
            }
            return i + j + fuzz - 1;
        };
        Rewriter.prototype.looksObjectish = function(j) {
            var end, index;
            if (this.indexOfTag(j, "@", null, ":") > -1 || this.indexOfTag(j, null, ":") > -1) {
                return true;
            }
            index = this.indexOfTag(j, EXPRESSION_START);
            if (index > -1) {
                end = null;
                this.detectEnd(index + 1, function(token) {
                    var ref;
                    return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;
                }, function(token, i) {
                    return end = i;
                });
                if (this.tag(end + 1) === ":") {
                    return true;
                }
            }
            return false;
        };
        Rewriter.prototype.findTagsBackwards = function(i, tags) {
            var backStack, ref, ref1, ref2, ref3, ref4, ref5;
            backStack = [];
            while(i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))){
                if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) {
                    backStack.push(this.tag(i));
                }
                if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) {
                    backStack.pop();
                }
                i -= 1;
            }
            return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;
        };
        Rewriter.prototype.addImplicitBracesAndParens = function() {
            var stack, start;
            stack = [];
            start = null;
            return this.scanTokens(function(token, i, tokens) {
                var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, isImplicit, isImplicitCall, isImplicitObject, k, newLine, nextTag, offset, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackItem, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;
                tag = token[0];
                prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];
                nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];
                stackTop = function() {
                    return stack[stack.length - 1];
                };
                startIdx = i;
                forward = function(n) {
                    return i - startIdx + n;
                };
                isImplicit = function(stackItem) {
                    var ref;
                    return stackItem != null ? (ref = stackItem[2]) != null ? ref.ours : void 0 : void 0;
                };
                isImplicitObject = function(stackItem) {
                    return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === "{";
                };
                isImplicitCall = function(stackItem) {
                    return isImplicit(stackItem) && (stackItem != null ? stackItem[0] : void 0) === "(";
                };
                inImplicit = function() {
                    return isImplicit(stackTop());
                };
                inImplicitCall = function() {
                    return isImplicitCall(stackTop());
                };
                inImplicitObject = function() {
                    return isImplicitObject(stackTop());
                };
                inImplicitControl = function() {
                    var ref;
                    return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === "CONTROL";
                };
                startImplicitCall = function(j) {
                    var idx;
                    idx = j != null ? j : i;
                    stack.push([
                        "(",
                        idx,
                        {
                            ours: true
                        }
                    ]);
                    tokens.splice(idx, 0, generate("CALL_START", "(", [
                        "",
                        "implicit function call",
                        token[2]
                    ]));
                    if (j == null) {
                        return i += 1;
                    }
                };
                endImplicitCall = function() {
                    stack.pop();
                    tokens.splice(i, 0, generate("CALL_END", ")", [
                        "",
                        "end of input",
                        token[2]
                    ]));
                    return i += 1;
                };
                startImplicitObject = function(j, startsLine) {
                    var idx, val;
                    if (startsLine == null) {
                        startsLine = true;
                    }
                    idx = j != null ? j : i;
                    stack.push([
                        "{",
                        idx,
                        {
                            sameLine: true,
                            startsLine: startsLine,
                            ours: true
                        }
                    ]);
                    val = new String("{");
                    val.generated = true;
                    tokens.splice(idx, 0, generate("{", val, token));
                    if (j == null) {
                        return i += 1;
                    }
                };
                endImplicitObject = function(j) {
                    j = j != null ? j : i;
                    stack.pop();
                    tokens.splice(j, 0, generate("}", "}", token));
                    return i += 1;
                };
                if (inImplicitCall() && (tag === "IF" || tag === "TRY" || tag === "FINALLY" || tag === "CATCH" || tag === "CLASS" || tag === "SWITCH")) {
                    stack.push([
                        "CONTROL",
                        i,
                        {
                            ours: true
                        }
                    ]);
                    return forward(1);
                }
                if (tag === "INDENT" && inImplicit()) {
                    if (prevTag !== "=>" && prevTag !== "->" && prevTag !== "[" && prevTag !== "(" && prevTag !== "," && prevTag !== "{" && prevTag !== "TRY" && prevTag !== "ELSE" && prevTag !== "=") {
                        while(inImplicitCall()){
                            endImplicitCall();
                        }
                    }
                    if (inImplicitControl()) {
                        stack.pop();
                    }
                    stack.push([
                        tag,
                        i
                    ]);
                    return forward(1);
                }
                if (indexOf.call(EXPRESSION_START, tag) >= 0) {
                    stack.push([
                        tag,
                        i
                    ]);
                    return forward(1);
                }
                if (indexOf.call(EXPRESSION_END, tag) >= 0) {
                    while(inImplicit()){
                        if (inImplicitCall()) {
                            endImplicitCall();
                        } else if (inImplicitObject()) {
                            endImplicitObject();
                        } else {
                            stack.pop();
                        }
                    }
                    start = stack.pop();
                }
                if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === "?" && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) {
                    if (tag === "?") {
                        tag = token[0] = "FUNC_EXIST";
                    }
                    startImplicitCall(i + 1);
                    return forward(2);
                }
                if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, "INDENT") > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, [
                    "CLASS",
                    "EXTENDS",
                    "IF",
                    "CATCH",
                    "SWITCH",
                    "LEADING_WHEN",
                    "FOR",
                    "WHILE",
                    "UNTIL"
                ])) {
                    startImplicitCall(i + 1);
                    stack.push([
                        "INDENT",
                        i + 2
                    ]);
                    return forward(3);
                }
                if (tag === ":") {
                    s = (function() {
                        var ref2;
                        switch(false){
                            case ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0:
                                return start[1];
                            case this.tag(i - 2) !== "@":
                                return i - 2;
                            default:
                                return i - 1;
                        }
                    }).call(this);
                    while(this.tag(s - 2) === "HERECOMMENT"){
                        s -= 2;
                    }
                    this.insideForDeclaration = nextTag === "FOR";
                    startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;
                    if (stackTop()) {
                        ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];
                        if ((stackTag === "{" || stackTag === "INDENT" && this.tag(stackIdx - 1) === "{") && (startsLine || this.tag(s - 1) === "," || this.tag(s - 1) === "{")) {
                            return forward(1);
                        }
                    }
                    startImplicitObject(s, !!startsLine);
                    return forward(2);
                }
                if (indexOf.call(LINEBREAKS, tag) >= 0) {
                    for(k = stack.length - 1; k >= 0; k += -1){
                        stackItem = stack[k];
                        if (!isImplicit(stackItem)) {
                            break;
                        }
                        if (isImplicitObject(stackItem)) {
                            stackItem[2].sameLine = false;
                        }
                    }
                }
                newLine = prevTag === "OUTDENT" || prevToken.newLine;
                if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {
                    while(inImplicit()){
                        ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine;
                        if (inImplicitCall() && prevTag !== ",") {
                            endImplicitCall();
                        } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== "TERMINATOR" && prevTag !== ":") {
                            endImplicitObject();
                        } else if (inImplicitObject() && tag === "TERMINATOR" && prevTag !== "," && !(startsLine && this.looksObjectish(i + 1))) {
                            if (nextTag === "HERECOMMENT") {
                                return forward(1);
                            }
                            endImplicitObject();
                        } else {
                            break;
                        }
                    }
                }
                if (tag === "," && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== "TERMINATOR" || !this.looksObjectish(i + 2))) {
                    offset = nextTag === "OUTDENT" ? 1 : 0;
                    while(inImplicitObject()){
                        endImplicitObject(i + offset);
                    }
                }
                return forward(1);
            });
        };
        Rewriter.prototype.addLocationDataToGeneratedTokens = function() {
            return this.scanTokens(function(token, i, tokens) {
                var column, line, nextLocation, prevLocation, ref, ref1;
                if (token[2]) {
                    return 1;
                }
                if (!(token.generated || token.explicit)) {
                    return 1;
                }
                if (token[0] === "{" && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) {
                    line = nextLocation.first_line, column = nextLocation.first_column;
                } else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) {
                    line = prevLocation.last_line, column = prevLocation.last_column;
                } else {
                    line = column = 0;
                }
                token[2] = {
                    first_line: line,
                    first_column: column,
                    last_line: line,
                    last_column: column
                };
                return 1;
            });
        };
        Rewriter.prototype.fixOutdentLocationData = function() {
            return this.scanTokens(function(token, i, tokens) {
                var prevLocationData;
                if (!(token[0] === "OUTDENT" || token.generated && token[0] === "CALL_END" || token.generated && token[0] === "}")) {
                    return 1;
                }
                prevLocationData = tokens[i - 1][2];
                token[2] = {
                    first_line: prevLocationData.last_line,
                    first_column: prevLocationData.last_column,
                    last_line: prevLocationData.last_line,
                    last_column: prevLocationData.last_column
                };
                return 1;
            });
        };
        Rewriter.prototype.normalizeLines = function() {
            var action, condition, indent, outdent, starter;
            starter = indent = outdent = null;
            condition = function(token, i) {
                var ref, ref1, ref2, ref3;
                return token[1] !== ";" && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === "TERMINATOR" && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === "ELSE" && starter !== "THEN") && !(((ref2 = token[0]) === "CATCH" || ref2 === "FINALLY") && (starter === "->" || starter === "=>")) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && (this.tokens[i - 1].newLine || this.tokens[i - 1][0] === "OUTDENT");
            };
            action = function(token, i) {
                return this.tokens.splice(this.tag(i - 1) === "," ? i - 1 : i, 0, outdent);
            };
            return this.scanTokens(function(token, i, tokens) {
                var j, k, ref, ref1, ref2, tag;
                tag = token[0];
                if (tag === "TERMINATOR") {
                    if (this.tag(i + 1) === "ELSE" && this.tag(i - 1) !== "OUTDENT") {
                        tokens.splice.apply(tokens, [
                            i,
                            1
                        ].concat(slice.call(this.indentation())));
                        return 1;
                    }
                    if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) {
                        tokens.splice(i, 1);
                        return 0;
                    }
                }
                if (tag === "CATCH") {
                    for(j = k = 1; k <= 2; j = ++k){
                        if (!((ref1 = this.tag(i + j)) === "OUTDENT" || ref1 === "TERMINATOR" || ref1 === "FINALLY")) {
                            continue;
                        }
                        tokens.splice.apply(tokens, [
                            i + j,
                            0
                        ].concat(slice.call(this.indentation())));
                        return 2 + j;
                    }
                }
                if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== "INDENT" && !(tag === "ELSE" && this.tag(i + 1) === "IF")) {
                    starter = tag;
                    ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];
                    if (starter === "THEN") {
                        indent.fromThen = true;
                    }
                    tokens.splice(i + 1, 0, indent);
                    this.detectEnd(i + 2, condition, action);
                    if (tag === "THEN") {
                        tokens.splice(i, 1);
                    }
                    return 1;
                }
                return 1;
            });
        };
        Rewriter.prototype.tagPostfixConditionals = function() {
            var action, condition, original;
            original = null;
            condition = function(token, i) {
                var prevTag, tag;
                tag = token[0];
                prevTag = this.tokens[i - 1][0];
                return tag === "TERMINATOR" || tag === "INDENT" && indexOf.call(SINGLE_LINERS, prevTag) < 0;
            };
            action = function(token, i) {
                if (token[0] !== "INDENT" || token.generated && !token.fromThen) {
                    return original[0] = "POST_" + original[0];
                }
            };
            return this.scanTokens(function(token, i) {
                if (token[0] !== "IF") {
                    return 1;
                }
                original = token;
                this.detectEnd(i + 1, condition, action);
                return 1;
            });
        };
        Rewriter.prototype.indentation = function(origin) {
            var indent, outdent;
            indent = [
                "INDENT",
                2
            ];
            outdent = [
                "OUTDENT",
                2
            ];
            if (origin) {
                indent.generated = outdent.generated = true;
                indent.origin = outdent.origin = origin;
            } else {
                indent.explicit = outdent.explicit = true;
            }
            return [
                indent,
                outdent
            ];
        };
        Rewriter.prototype.generate = generate;
        Rewriter.prototype.tag = function(i) {
            var ref;
            return (ref = this.tokens[i]) != null ? ref[0] : void 0;
        };
        return Rewriter;
    }();
    BALANCED_PAIRS = [
        [
            "(",
            ")"
        ],
        [
            "[",
            "]"
        ],
        [
            "{",
            "}"
        ],
        [
            "INDENT",
            "OUTDENT"
        ],
        [
            "CALL_START",
            "CALL_END"
        ],
        [
            "PARAM_START",
            "PARAM_END"
        ],
        [
            "INDEX_START",
            "INDEX_END"
        ],
        [
            "STRING_START",
            "STRING_END"
        ],
        [
            "REGEX_START",
            "REGEX_END"
        ]
    ];
    exports.INVERSES = INVERSES = {};
    EXPRESSION_START = [];
    EXPRESSION_END = [];
    for(k = 0, len = BALANCED_PAIRS.length; k < len; k++){
        ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];
        EXPRESSION_START.push(INVERSES[rite] = left);
        EXPRESSION_END.push(INVERSES[left] = rite);
    }
    EXPRESSION_CLOSE = [
        "CATCH",
        "THEN",
        "ELSE",
        "FINALLY"
    ].concat(EXPRESSION_END);
    IMPLICIT_FUNC = [
        "IDENTIFIER",
        "PROPERTY",
        "SUPER",
        ")",
        "CALL_END",
        "]",
        "INDEX_END",
        "@",
        "THIS"
    ];
    IMPLICIT_CALL = [
        "IDENTIFIER",
        "PROPERTY",
        "NUMBER",
        "INFINITY",
        "NAN",
        "STRING",
        "STRING_START",
        "REGEX",
        "REGEX_START",
        "JS",
        "NEW",
        "PARAM_START",
        "CLASS",
        "IF",
        "TRY",
        "SWITCH",
        "THIS",
        "UNDEFINED",
        "NULL",
        "BOOL",
        "UNARY",
        "YIELD",
        "UNARY_MATH",
        "SUPER",
        "THROW",
        "@",
        "->",
        "=>",
        "[",
        "(",
        "{",
        "--",
        "++"
    ];
    IMPLICIT_UNSPACED_CALL = [
        "+",
        "-"
    ];
    IMPLICIT_END = [
        "POST_IF",
        "FOR",
        "WHILE",
        "UNTIL",
        "WHEN",
        "BY",
        "LOOP",
        "TERMINATOR"
    ];
    SINGLE_LINERS = [
        "ELSE",
        "->",
        "=>",
        "TRY",
        "FINALLY",
        "THEN"
    ];
    SINGLE_CLOSERS = [
        "TERMINATOR",
        "CATCH",
        "FINALLY",
        "ELSE",
        "OUTDENT",
        "LEADING_WHEN"
    ];
    LINEBREAKS = [
        "TERMINATOR",
        "INDENT",
        "OUTDENT"
    ];
    CALL_CLOSERS = [
        ".",
        "?.",
        "::",
        "?::"
    ];
}).call(this);


/***/ }),

/***/ 35533:
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
    var Scope, indexOf = [].indexOf || function(item) {
        for(var i = 0, l = this.length; i < l; i++){
            if (i in this && this[i] === item) return i;
        }
        return -1;
    };
    exports.Scope = Scope = function() {
        function Scope(parent, expressions, method, referencedVars) {
            var ref, ref1;
            this.parent = parent;
            this.expressions = expressions;
            this.method = method;
            this.referencedVars = referencedVars;
            this.variables = [
                {
                    name: "arguments",
                    type: "arguments"
                }
            ];
            this.positions = {};
            if (!this.parent) {
                this.utilities = {};
            }
            this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;
        }
        Scope.prototype.add = function(name, type, immediate) {
            if (this.shared && !immediate) {
                return this.parent.add(name, type, immediate);
            }
            if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
                return this.variables[this.positions[name]].type = type;
            } else {
                return this.positions[name] = this.variables.push({
                    name: name,
                    type: type
                }) - 1;
            }
        };
        Scope.prototype.namedMethod = function() {
            var ref;
            if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {
                return this.method;
            }
            return this.parent.namedMethod();
        };
        Scope.prototype.find = function(name, type) {
            if (type == null) {
                type = "var";
            }
            if (this.check(name)) {
                return true;
            }
            this.add(name, type);
            return false;
        };
        Scope.prototype.parameter = function(name) {
            if (this.shared && this.parent.check(name, true)) {
                return;
            }
            return this.add(name, "param");
        };
        Scope.prototype.check = function(name) {
            var ref;
            return !!(this.type(name) || ((ref = this.parent) != null ? ref.check(name) : void 0));
        };
        Scope.prototype.temporary = function(name, index, single) {
            var diff, endCode, letter, newCode, num, startCode;
            if (single == null) {
                single = false;
            }
            if (single) {
                startCode = name.charCodeAt(0);
                endCode = "z".charCodeAt(0);
                diff = endCode - startCode;
                newCode = startCode + index % (diff + 1);
                letter = String.fromCharCode(newCode);
                num = Math.floor(index / (diff + 1));
                return "" + letter + (num || "");
            } else {
                return "" + name + (index || "");
            }
        };
        Scope.prototype.type = function(name) {
            var i, len, ref, v;
            ref = this.variables;
            for(i = 0, len = ref.length; i < len; i++){
                v = ref[i];
                if (v.name === name) {
                    return v.type;
                }
            }
            return null;
        };
        Scope.prototype.freeVariable = function(name, options) {
            var index, ref, temp;
            if (options == null) {
                options = {};
            }
            index = 0;
            while(true){
                temp = this.temporary(name, index, options.single);
                if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) >= 0)) {
                    break;
                }
                index++;
            }
            if ((ref = options.reserve) != null ? ref : true) {
                this.add(temp, "var", true);
            }
            return temp;
        };
        Scope.prototype.assign = function(name, value) {
            this.add(name, {
                value: value,
                assigned: true
            }, true);
            return this.hasAssignments = true;
        };
        Scope.prototype.hasDeclarations = function() {
            return !!this.declaredVariables().length;
        };
        Scope.prototype.declaredVariables = function() {
            var v;
            return (function() {
                var i, len, ref, results;
                ref = this.variables;
                results = [];
                for(i = 0, len = ref.length; i < len; i++){
                    v = ref[i];
                    if (v.type === "var") {
                        results.push(v.name);
                    }
                }
                return results;
            }).call(this).sort();
        };
        Scope.prototype.assignedVariables = function() {
            var i, len, ref, results, v;
            ref = this.variables;
            results = [];
            for(i = 0, len = ref.length; i < len; i++){
                v = ref[i];
                if (v.type.assigned) {
                    results.push(v.name + " = " + v.type.value);
                }
            }
            return results;
        };
        return Scope;
    }();
}).call(this);


/***/ }),

/***/ 56313:
/***/ ((module) => {

"use strict";

// Generated by CoffeeScript 1.12.7
(function() {
    var LineMap, SourceMap;
    LineMap = function() {
        function LineMap(line1) {
            this.line = line1;
            this.columns = [];
        }
        LineMap.prototype.add = function(column, arg, options) {
            var sourceColumn, sourceLine;
            sourceLine = arg[0], sourceColumn = arg[1];
            if (options == null) {
                options = {};
            }
            if (this.columns[column] && options.noReplace) {
                return;
            }
            return this.columns[column] = {
                line: this.line,
                column: column,
                sourceLine: sourceLine,
                sourceColumn: sourceColumn
            };
        };
        LineMap.prototype.sourceLocation = function(column) {
            var mapping;
            while(!((mapping = this.columns[column]) || column <= 0)){
                column--;
            }
            return mapping && [
                mapping.sourceLine,
                mapping.sourceColumn
            ];
        };
        return LineMap;
    }();
    SourceMap = function() {
        var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;
        function SourceMap() {
            this.lines = [];
        }
        SourceMap.prototype.add = function(sourceLocation, generatedLocation, options) {
            var base, column, line, lineMap;
            if (options == null) {
                options = {};
            }
            line = generatedLocation[0], column = generatedLocation[1];
            lineMap = (base = this.lines)[line] || (base[line] = new LineMap(line));
            return lineMap.add(column, sourceLocation, options);
        };
        SourceMap.prototype.sourceLocation = function(arg) {
            var column, line, lineMap;
            line = arg[0], column = arg[1];
            while(!((lineMap = this.lines[line]) || line <= 0)){
                line--;
            }
            return lineMap && lineMap.sourceLocation(column);
        };
        SourceMap.prototype.generate = function(options, code) {
            var buffer, i, j, lastColumn, lastSourceColumn, lastSourceLine, len, len1, lineMap, lineNumber, mapping, needComma, ref, ref1, v3, writingline;
            if (options == null) {
                options = {};
            }
            if (code == null) {
                code = null;
            }
            writingline = 0;
            lastColumn = 0;
            lastSourceLine = 0;
            lastSourceColumn = 0;
            needComma = false;
            buffer = "";
            ref = this.lines;
            for(lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i){
                lineMap = ref[lineNumber];
                if (lineMap) {
                    ref1 = lineMap.columns;
                    for(j = 0, len1 = ref1.length; j < len1; j++){
                        mapping = ref1[j];
                        if (!mapping) {
                            continue;
                        }
                        while(writingline < mapping.line){
                            lastColumn = 0;
                            needComma = false;
                            buffer += ";";
                            writingline++;
                        }
                        if (needComma) {
                            buffer += ",";
                            needComma = false;
                        }
                        buffer += this.encodeVlq(mapping.column - lastColumn);
                        lastColumn = mapping.column;
                        buffer += this.encodeVlq(0);
                        buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
                        lastSourceLine = mapping.sourceLine;
                        buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
                        lastSourceColumn = mapping.sourceColumn;
                        needComma = true;
                    }
                }
            }
            v3 = {
                version: 3,
                file: options.generatedFile || "",
                sourceRoot: options.sourceRoot || "",
                sources: options.sourceFiles || [
                    ""
                ],
                names: [],
                mappings: buffer
            };
            if (options.inlineMap) {
                v3.sourcesContent = [
                    code
                ];
            }
            return v3;
        };
        VLQ_SHIFT = 5;
        VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;
        VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;
        SourceMap.prototype.encodeVlq = function(value) {
            var answer, nextChunk, signBit, valueToEncode;
            answer = "";
            signBit = value < 0 ? 1 : 0;
            valueToEncode = (Math.abs(value) << 1) + signBit;
            while(valueToEncode || !answer){
                nextChunk = valueToEncode & VLQ_VALUE_MASK;
                valueToEncode = valueToEncode >> VLQ_SHIFT;
                if (valueToEncode) {
                    nextChunk |= VLQ_CONTINUATION_BIT;
                }
                answer += this.encodeBase64(nextChunk);
            }
            return answer;
        };
        BASE64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        SourceMap.prototype.encodeBase64 = function(value) {
            return BASE64_CHARS[value] || function() {
                throw new Error("Cannot Base64 encode value: " + value);
            }();
        };
        return SourceMap;
    }();
    module.exports = SourceMap;
}).call(void 0);


/***/ }),

/***/ 82151:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * __        ___    ____  _   _ ___ _   _  ____
 * \ \      / / \  |  _ \| \ | |_ _| \ | |/ ___|
 *  \ \ /\ / / _ \ | |_) |  \| || ||  \| | |  _
 *   \ V  V / ___ \|  _ <| |\  || || |\  | |_| |
 *    \_/\_/_/   \_\_| \_\_| \_|___|_| \_|\____|
 *
 * This file is critical for vm2. It implements the bridge between the host and the sandbox.
 * If you do not know exactly what you are doing, you should NOT edit this file.
 *
 * The file is loaded in the host and sandbox to handle objects in both directions.
 * This is done to ensure that RangeErrors are from the correct context.
 * The boundary between the sandbox and host might throw RangeErrors from both contexts.
 * Therefore, thisFromOther and friends can handle objects from both domains.
 *
 * Method parameters have comments to tell from which context they came.
 *
 */ const globalsList = [
    "Number",
    "String",
    "Boolean",
    "Date",
    "RegExp",
    "Map",
    "WeakMap",
    "Set",
    "WeakSet",
    "Promise",
    "Function"
];
const errorsList = [
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "EvalError",
    "URIError",
    "Error"
];
const OPNA = "Operation not allowed on contextified object.";
const thisGlobalPrototypes = {
    __proto__: null,
    Object: Object.prototype,
    Array: Array.prototype
};
for(let i = 0; i < globalsList.length; i++){
    const key = globalsList[i];
    const g = global[key];
    if (g) thisGlobalPrototypes[key] = g.prototype;
}
for(let i = 0; i < errorsList.length; i++){
    const key = errorsList[i];
    const g = global[key];
    if (g) thisGlobalPrototypes[key] = g.prototype;
}
const { getPrototypeOf: thisReflectGetPrototypeOf, setPrototypeOf: thisReflectSetPrototypeOf, defineProperty: thisReflectDefineProperty, deleteProperty: thisReflectDeleteProperty, getOwnPropertyDescriptor: thisReflectGetOwnPropertyDescriptor, isExtensible: thisReflectIsExtensible, preventExtensions: thisReflectPreventExtensions, apply: thisReflectApply, construct: thisReflectConstruct, set: thisReflectSet, get: thisReflectGet, has: thisReflectHas, ownKeys: thisReflectOwnKeys, enumerate: thisReflectEnumerate } = Reflect;
const thisObject = Object;
const { freeze: thisObjectFreeze, prototype: thisObjectPrototype } = thisObject;
const thisObjectHasOwnProperty = thisObjectPrototype.hasOwnProperty;
const ThisProxy = Proxy;
const ThisWeakMap = WeakMap;
const { get: thisWeakMapGet, set: thisWeakMapSet } = ThisWeakMap.prototype;
const ThisMap = Map;
const thisMapGet = ThisMap.prototype.get;
const thisMapSet = ThisMap.prototype.set;
const thisFunction = Function;
const thisFunctionBind = thisFunction.prototype.bind;
const thisArrayIsArray = Array.isArray;
const thisErrorCaptureStackTrace = Error.captureStackTrace;
const thisSymbolToString = Symbol.prototype.toString;
const thisSymbolToStringTag = Symbol.toStringTag;
const thisSymbolIterator = Symbol.iterator;
const thisSymbolNodeJSUtilInspectCustom = Symbol.for("nodejs.util.inspect.custom");
/**
 * VMError.
 *
 * @public
 * @extends {Error}
 */ class VMError extends Error {
    /**
	 * Create VMError instance.
	 *
	 * @public
	 * @param {string} message - Error message.
	 * @param {string} code - Error code.
	 */ constructor(message, code){
        super(message);
        this.name = "VMError";
        this.code = code;
        thisErrorCaptureStackTrace(this, this.constructor);
    }
}
thisGlobalPrototypes["VMError"] = VMError.prototype;
function thisUnexpected() {
    return new VMError("Unexpected");
}
if (!thisReflectSetPrototypeOf(exports, null)) throw thisUnexpected();
function thisSafeGetOwnPropertyDescriptor(obj, key) {
    const desc = thisReflectGetOwnPropertyDescriptor(obj, key);
    if (!desc) return desc;
    if (!thisReflectSetPrototypeOf(desc, null)) throw thisUnexpected();
    return desc;
}
function thisThrowCallerCalleeArgumentsAccess(key) {
    "use strict";
    thisThrowCallerCalleeArgumentsAccess[key];
    return thisUnexpected();
}
function thisIdMapping(factory, other) {
    return other;
}
const thisThrowOnKeyAccessHandler = thisObjectFreeze({
    __proto__: null,
    get (target, key, receiver) {
        if (typeof key === "symbol") {
            key = thisReflectApply(thisSymbolToString, key, []);
        }
        throw new VMError(`Unexpected access to key '${key}'`);
    }
});
const emptyForzenObject = thisObjectFreeze({
    __proto__: null
});
const thisThrowOnKeyAccess = new ThisProxy(emptyForzenObject, thisThrowOnKeyAccessHandler);
function SafeBase() {}
if (!thisReflectDefineProperty(SafeBase, "prototype", {
    __proto__: null,
    value: thisThrowOnKeyAccess
})) throw thisUnexpected();
function SHARED_FUNCTION() {}
const TEST_PROXY_HANDLER = thisObjectFreeze({
    __proto__: thisThrowOnKeyAccess,
    construct () {
        return this;
    }
});
function thisIsConstructor(obj) {
    // Note: obj@any(unsafe)
    const Func = new ThisProxy(obj, TEST_PROXY_HANDLER);
    try {
        // eslint-disable-next-line no-new
        new Func();
        return true;
    } catch (e) {
        return false;
    }
}
function thisCreateTargetObject(obj, proto) {
    // Note: obj@any(unsafe) proto@any(unsafe) returns@this(unsafe) throws@this(unsafe)
    let base;
    if (typeof obj === "function") {
        if (thisIsConstructor(obj)) {
            // Bind the function since bound functions do not have a prototype property.
            base = thisReflectApply(thisFunctionBind, SHARED_FUNCTION, [
                null
            ]);
        } else {
            base = ()=>{};
        }
    } else if (thisArrayIsArray(obj)) {
        base = [];
    } else {
        return {
            __proto__: proto
        };
    }
    if (!thisReflectSetPrototypeOf(base, proto)) throw thisUnexpected();
    return base;
}
function createBridge(otherInit, registerProxy) {
    const mappingOtherToThis = new ThisWeakMap();
    const protoMappings = new ThisMap();
    const protoName = new ThisMap();
    function thisAddProtoMapping(proto, other, name) {
        // Note: proto@this(unsafe) other@other(unsafe) name@this(unsafe) throws@this(unsafe)
        thisReflectApply(thisMapSet, protoMappings, [
            proto,
            thisIdMapping
        ]);
        thisReflectApply(thisMapSet, protoMappings, [
            other,
            (factory, object)=>thisProxyOther(factory, object, proto)
        ]);
        if (name) thisReflectApply(thisMapSet, protoName, [
            proto,
            name
        ]);
    }
    function thisAddProtoMappingFactory(protoFactory, other, name) {
        // Note: protoFactory@this(unsafe) other@other(unsafe) name@this(unsafe) throws@this(unsafe)
        let proto;
        thisReflectApply(thisMapSet, protoMappings, [
            other,
            (factory, object)=>{
                if (!proto) {
                    proto = protoFactory();
                    thisReflectApply(thisMapSet, protoMappings, [
                        proto,
                        thisIdMapping
                    ]);
                    if (name) thisReflectApply(thisMapSet, protoName, [
                        proto,
                        name
                    ]);
                }
                return thisProxyOther(factory, object, proto);
            }
        ]);
    }
    const result = {
        __proto__: null,
        globalPrototypes: thisGlobalPrototypes,
        safeGetOwnPropertyDescriptor: thisSafeGetOwnPropertyDescriptor,
        fromArguments: thisFromOtherArguments,
        from: thisFromOther,
        fromWithFactory: thisFromOtherWithFactory,
        ensureThis: thisEnsureThis,
        mapping: mappingOtherToThis,
        connect: thisConnect,
        reflectSet: thisReflectSet,
        reflectGet: thisReflectGet,
        reflectDefineProperty: thisReflectDefineProperty,
        reflectDeleteProperty: thisReflectDeleteProperty,
        reflectApply: thisReflectApply,
        reflectConstruct: thisReflectConstruct,
        reflectHas: thisReflectHas,
        reflectOwnKeys: thisReflectOwnKeys,
        reflectEnumerate: thisReflectEnumerate,
        reflectGetPrototypeOf: thisReflectGetPrototypeOf,
        reflectIsExtensible: thisReflectIsExtensible,
        reflectPreventExtensions: thisReflectPreventExtensions,
        objectHasOwnProperty: thisObjectHasOwnProperty,
        weakMapSet: thisWeakMapSet,
        addProtoMapping: thisAddProtoMapping,
        addProtoMappingFactory: thisAddProtoMappingFactory,
        defaultFactory,
        protectedFactory,
        readonlyFactory,
        VMError
    };
    const isHost = typeof otherInit !== "object";
    if (isHost) {
        otherInit = otherInit(result, registerProxy);
    }
    result.other = otherInit;
    const { globalPrototypes: otherGlobalPrototypes, safeGetOwnPropertyDescriptor: otherSafeGetOwnPropertyDescriptor, fromArguments: otherFromThisArguments, from: otherFromThis, mapping: mappingThisToOther, reflectSet: otherReflectSet, reflectGet: otherReflectGet, reflectDefineProperty: otherReflectDefineProperty, reflectDeleteProperty: otherReflectDeleteProperty, reflectApply: otherReflectApply, reflectConstruct: otherReflectConstruct, reflectHas: otherReflectHas, reflectOwnKeys: otherReflectOwnKeys, reflectEnumerate: otherReflectEnumerate, reflectGetPrototypeOf: otherReflectGetPrototypeOf, reflectIsExtensible: otherReflectIsExtensible, reflectPreventExtensions: otherReflectPreventExtensions, objectHasOwnProperty: otherObjectHasOwnProperty, weakMapSet: otherWeakMapSet } = otherInit;
    function thisOtherHasOwnProperty(object, key) {
        // Note: object@other(safe) key@prim throws@this(unsafe)
        try {
            return otherReflectApply(otherObjectHasOwnProperty, object, [
                key
            ]) === true;
        } catch (e) {
            throw thisFromOtherForThrow(e);
        }
    }
    function thisDefaultGet(handler, object, key, desc) {
        // Note: object@other(unsafe) key@prim desc@other(safe)
        let ret; // @other(unsafe)
        if (desc.get || desc.set) {
            const getter = desc.get;
            if (!getter) return undefined;
            try {
                ret = otherReflectApply(getter, object, [
                    key
                ]);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
        } else {
            ret = desc.value;
        }
        return handler.fromOtherWithContext(ret);
    }
    function otherFromThisIfAvailable(to, from, key) {
        // Note: to@other(safe) from@this(safe) key@prim throws@this(unsafe)
        if (!thisReflectApply(thisObjectHasOwnProperty, from, [
            key
        ])) return false;
        try {
            to[key] = otherFromThis(from[key]);
        } catch (e) {
            throw thisFromOtherForThrow(e);
        }
        return true;
    }
    class BaseHandler extends SafeBase {
        constructor(object){
            // Note: object@other(unsafe) throws@this(unsafe)
            super();
            this.objectWrapper = ()=>object;
        }
        getObject() {
            return this.objectWrapper();
        }
        getFactory() {
            return defaultFactory;
        }
        fromOtherWithContext(other) {
            // Note: other@other(unsafe) throws@this(unsafe)
            return thisFromOtherWithFactory(this.getFactory(), other);
        }
        doPreventExtensions(target, object, factory) {
            // Note: target@this(unsafe) object@other(unsafe) throws@this(unsafe)
            let keys; // @other(safe-array-of-prim)
            try {
                keys = otherReflectOwnKeys(object);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            for(let i = 0; i < keys.length; i++){
                const key = keys[i]; // @prim
                let desc;
                try {
                    desc = otherSafeGetOwnPropertyDescriptor(object, key);
                } catch (e) {
                    throw thisFromOtherForThrow(e);
                }
                if (!desc) continue;
                if (!desc.configurable) {
                    const current = thisSafeGetOwnPropertyDescriptor(target, key);
                    if (current && !current.configurable) continue;
                    if (desc.get || desc.set) {
                        desc.get = this.fromOtherWithContext(desc.get);
                        desc.set = this.fromOtherWithContext(desc.set);
                    } else if (typeof object === "function" && (key === "caller" || key === "callee" || key === "arguments")) {
                        desc.value = null;
                    } else {
                        desc.value = this.fromOtherWithContext(desc.value);
                    }
                } else {
                    if (desc.get || desc.set) {
                        desc = {
                            __proto__: null,
                            configurable: true,
                            enumerable: desc.enumerable,
                            writable: true,
                            value: null
                        };
                    } else {
                        desc.value = null;
                    }
                }
                if (!thisReflectDefineProperty(target, key, desc)) throw thisUnexpected();
            }
            if (!thisReflectPreventExtensions(target)) throw thisUnexpected();
        }
        get(target, key, receiver) {
            // Note: target@this(unsafe) key@prim receiver@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            switch(key){
                case "constructor":
                    {
                        const desc = otherSafeGetOwnPropertyDescriptor(object, key);
                        if (desc) return thisDefaultGet(this, object, key, desc);
                        const proto = thisReflectGetPrototypeOf(target);
                        return proto === null ? undefined : proto.constructor;
                    }
                case "__proto__":
                    {
                        const desc = otherSafeGetOwnPropertyDescriptor(object, key);
                        if (desc) return thisDefaultGet(this, object, key, desc);
                        return thisReflectGetPrototypeOf(target);
                    }
                case thisSymbolToStringTag:
                    if (!thisOtherHasOwnProperty(object, thisSymbolToStringTag)) {
                        const proto = thisReflectGetPrototypeOf(target);
                        const name = thisReflectApply(thisMapGet, protoName, [
                            proto
                        ]);
                        if (name) return name;
                    }
                    break;
                case "arguments":
                case "caller":
                case "callee":
                    if (typeof object === "function" && thisOtherHasOwnProperty(object, key)) {
                        throw thisThrowCallerCalleeArgumentsAccess(key);
                    }
                    break;
            }
            let ret; // @other(unsafe)
            try {
                ret = otherReflectGet(object, key);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            return this.fromOtherWithContext(ret);
        }
        set(target, key, value, receiver) {
            // Note: target@this(unsafe) key@prim value@this(unsafe) receiver@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            if (key === "__proto__" && !thisOtherHasOwnProperty(object, key)) {
                return this.setPrototypeOf(target, value);
            }
            try {
                value = otherFromThis(value);
                return otherReflectSet(object, key, value) === true;
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
        }
        getPrototypeOf(target) {
            // Note: target@this(unsafe)
            return thisReflectGetPrototypeOf(target);
        }
        setPrototypeOf(target, value) {
            // Note: target@this(unsafe) throws@this(unsafe)
            throw new VMError(OPNA);
        }
        apply(target, context, args) {
            // Note: target@this(unsafe) context@this(unsafe) args@this(safe-array) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            let ret; // @other(unsafe)
            try {
                context = otherFromThis(context);
                args = otherFromThisArguments(args);
                ret = otherReflectApply(object, context, args);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            return thisFromOther(ret);
        }
        construct(target, args, newTarget) {
            // Note: target@this(unsafe) args@this(safe-array) newTarget@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            let ret; // @other(unsafe)
            try {
                args = otherFromThisArguments(args);
                ret = otherReflectConstruct(object, args);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            return thisFromOtherWithFactory(this.getFactory(), ret, thisFromOther(object));
        }
        getOwnPropertyDescriptorDesc(target, prop, desc) {
            // Note: target@this(unsafe) prop@prim desc@other{safe} throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            if (desc && typeof object === "function" && (prop === "arguments" || prop === "caller" || prop === "callee")) desc.value = null;
            return desc;
        }
        getOwnPropertyDescriptor(target, prop) {
            // Note: target@this(unsafe) prop@prim throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            let desc; // @other(safe)
            try {
                desc = otherSafeGetOwnPropertyDescriptor(object, prop);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            desc = this.getOwnPropertyDescriptorDesc(target, prop, desc);
            if (!desc) return undefined;
            let thisDesc;
            if (desc.get || desc.set) {
                thisDesc = {
                    __proto__: null,
                    get: this.fromOtherWithContext(desc.get),
                    set: this.fromOtherWithContext(desc.set),
                    enumerable: desc.enumerable === true,
                    configurable: desc.configurable === true
                };
            } else {
                thisDesc = {
                    __proto__: null,
                    value: this.fromOtherWithContext(desc.value),
                    writable: desc.writable === true,
                    enumerable: desc.enumerable === true,
                    configurable: desc.configurable === true
                };
            }
            if (!thisDesc.configurable) {
                const oldDesc = thisSafeGetOwnPropertyDescriptor(target, prop);
                if (!oldDesc || oldDesc.configurable || oldDesc.writable !== thisDesc.writable) {
                    if (!thisReflectDefineProperty(target, prop, thisDesc)) throw thisUnexpected();
                }
            }
            return thisDesc;
        }
        definePropertyDesc(target, prop, desc) {
            // Note: target@this(unsafe) prop@prim desc@this(safe) throws@this(unsafe)
            return desc;
        }
        defineProperty(target, prop, desc) {
            // Note: target@this(unsafe) prop@prim desc@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            if (!thisReflectSetPrototypeOf(desc, null)) throw thisUnexpected();
            desc = this.definePropertyDesc(target, prop, desc);
            if (!desc) return false;
            let otherDesc = {
                __proto__: null
            };
            let hasFunc = true;
            let hasValue = true;
            let hasBasic = true;
            hasFunc &= otherFromThisIfAvailable(otherDesc, desc, "get");
            hasFunc &= otherFromThisIfAvailable(otherDesc, desc, "set");
            hasValue &= otherFromThisIfAvailable(otherDesc, desc, "value");
            hasValue &= otherFromThisIfAvailable(otherDesc, desc, "writable");
            hasBasic &= otherFromThisIfAvailable(otherDesc, desc, "enumerable");
            hasBasic &= otherFromThisIfAvailable(otherDesc, desc, "configurable");
            try {
                if (!otherReflectDefineProperty(object, prop, otherDesc)) return false;
                if (otherDesc.configurable !== true && (!hasBasic || !(hasFunc || hasValue))) {
                    otherDesc = otherSafeGetOwnPropertyDescriptor(object, prop);
                }
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            if (!otherDesc.configurable) {
                let thisDesc;
                if (otherDesc.get || otherDesc.set) {
                    thisDesc = {
                        __proto__: null,
                        get: this.fromOtherWithContext(otherDesc.get),
                        set: this.fromOtherWithContext(otherDesc.set),
                        enumerable: otherDesc.enumerable,
                        configurable: otherDesc.configurable
                    };
                } else {
                    thisDesc = {
                        __proto__: null,
                        value: this.fromOtherWithContext(otherDesc.value),
                        writable: otherDesc.writable,
                        enumerable: otherDesc.enumerable,
                        configurable: otherDesc.configurable
                    };
                }
                if (!thisReflectDefineProperty(target, prop, thisDesc)) throw thisUnexpected();
            }
            return true;
        }
        deleteProperty(target, prop) {
            // Note: target@this(unsafe) prop@prim throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            try {
                return otherReflectDeleteProperty(object, prop) === true;
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
        }
        has(target, key) {
            // Note: target@this(unsafe) key@prim throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            try {
                return otherReflectHas(object, key) === true;
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
        }
        isExtensible(target) {
            // Note: target@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            try {
                if (otherReflectIsExtensible(object)) return true;
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            if (thisReflectIsExtensible(target)) {
                this.doPreventExtensions(target, object, this);
            }
            return false;
        }
        ownKeys(target) {
            // Note: target@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            let res; // @other(unsafe)
            try {
                res = otherReflectOwnKeys(object);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            return thisFromOther(res);
        }
        preventExtensions(target) {
            // Note: target@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            try {
                if (!otherReflectPreventExtensions(object)) return false;
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            if (thisReflectIsExtensible(target)) {
                this.doPreventExtensions(target, object, this);
            }
            return true;
        }
        enumerate(target) {
            // Note: target@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            let res; // @other(unsafe)
            try {
                res = otherReflectEnumerate(object);
            } catch (e) {
                throw thisFromOtherForThrow(e);
            }
            return this.fromOtherWithContext(res);
        }
    }
    BaseHandler.prototype[thisSymbolNodeJSUtilInspectCustom] = undefined;
    BaseHandler.prototype[thisSymbolToStringTag] = "VM2 Wrapper";
    BaseHandler.prototype[thisSymbolIterator] = undefined;
    function defaultFactory(object) {
        // Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)
        return new BaseHandler(object);
    }
    class ProtectedHandler extends BaseHandler {
        getFactory() {
            return protectedFactory;
        }
        set(target, key, value, receiver) {
            // Note: target@this(unsafe) key@prim value@this(unsafe) receiver@this(unsafe) throws@this(unsafe)
            if (typeof value === "function") {
                return thisReflectDefineProperty(receiver, key, {
                    __proto__: null,
                    value: value,
                    writable: true,
                    enumerable: true,
                    configurable: true
                }) === true;
            }
            return super.set(target, key, value, receiver);
        }
        definePropertyDesc(target, prop, desc) {
            // Note: target@this(unsafe) prop@prim desc@this(safe) throws@this(unsafe)
            if (desc && (desc.set || desc.get || typeof desc.value === "function")) return undefined;
            return desc;
        }
    }
    function protectedFactory(object) {
        // Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)
        return new ProtectedHandler(object);
    }
    class ReadOnlyHandler extends BaseHandler {
        getFactory() {
            return readonlyFactory;
        }
        set(target, key, value, receiver) {
            // Note: target@this(unsafe) key@prim value@this(unsafe) receiver@this(unsafe) throws@this(unsafe)
            return thisReflectDefineProperty(receiver, key, {
                __proto__: null,
                value: value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
        setPrototypeOf(target, value) {
            // Note: target@this(unsafe) throws@this(unsafe)
            return false;
        }
        defineProperty(target, prop, desc) {
            // Note: target@this(unsafe) prop@prim desc@this(unsafe) throws@this(unsafe)
            return false;
        }
        deleteProperty(target, prop) {
            // Note: target@this(unsafe) prop@prim throws@this(unsafe)
            return false;
        }
        isExtensible(target) {
            // Note: target@this(unsafe) throws@this(unsafe)
            return false;
        }
        preventExtensions(target) {
            // Note: target@this(unsafe) throws@this(unsafe)
            return false;
        }
    }
    function readonlyFactory(object) {
        // Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)
        return new ReadOnlyHandler(object);
    }
    class ReadOnlyMockHandler extends ReadOnlyHandler {
        constructor(object, mock){
            // Note: object@other(unsafe) mock:this(unsafe) throws@this(unsafe)
            super(object);
            this.mock = mock;
        }
        get(target, key, receiver) {
            // Note: target@this(unsafe) key@prim receiver@this(unsafe) throws@this(unsafe)
            const object = this.getObject(); // @other(unsafe)
            const mock = this.mock;
            if (thisReflectApply(thisObjectHasOwnProperty, mock, key) && !thisOtherHasOwnProperty(object, key)) {
                return mock[key];
            }
            return super.get(target, key, receiver);
        }
    }
    function thisFromOther(other) {
        // Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)
        return thisFromOtherWithFactory(defaultFactory, other);
    }
    function thisProxyOther(factory, other, proto) {
        const target = thisCreateTargetObject(other, proto);
        const handler = factory(other);
        const proxy = new ThisProxy(target, handler);
        try {
            otherReflectApply(otherWeakMapSet, mappingThisToOther, [
                proxy,
                other
            ]);
            registerProxy(proxy, handler);
        } catch (e) {
            throw new VMError("Unexpected error");
        }
        if (!isHost) {
            thisReflectApply(thisWeakMapSet, mappingOtherToThis, [
                other,
                proxy
            ]);
            return proxy;
        }
        const proxy2 = new ThisProxy(proxy, emptyForzenObject);
        try {
            otherReflectApply(otherWeakMapSet, mappingThisToOther, [
                proxy2,
                other
            ]);
            registerProxy(proxy2, handler);
        } catch (e) {
            throw new VMError("Unexpected error");
        }
        thisReflectApply(thisWeakMapSet, mappingOtherToThis, [
            other,
            proxy2
        ]);
        return proxy2;
    }
    function thisEnsureThis(other) {
        const type = typeof other;
        switch(type){
            case "object":
                if (other === null) {
                    return null;
                }
            // fallthrough
            case "function":
                let proto = thisReflectGetPrototypeOf(other);
                if (!proto) {
                    return other;
                }
                while(proto){
                    const mapping = thisReflectApply(thisMapGet, protoMappings, [
                        proto
                    ]);
                    if (mapping) {
                        const mapped = thisReflectApply(thisWeakMapGet, mappingOtherToThis, [
                            other
                        ]);
                        if (mapped) return mapped;
                        return mapping(defaultFactory, other);
                    }
                    proto = thisReflectGetPrototypeOf(proto);
                }
                return other;
            case "undefined":
            case "string":
            case "number":
            case "boolean":
            case "symbol":
            case "bigint":
                return other;
            default:
                throw new VMError(`Unknown type '${type}'`);
        }
    }
    function thisFromOtherForThrow(other) {
        for(let loop = 0; loop < 10; loop++){
            const type = typeof other;
            switch(type){
                case "object":
                    if (other === null) {
                        return null;
                    }
                // fallthrough
                case "function":
                    const mapped = thisReflectApply(thisWeakMapGet, mappingOtherToThis, [
                        other
                    ]);
                    if (mapped) return mapped;
                    let proto;
                    try {
                        proto = otherReflectGetPrototypeOf(other);
                    } catch (e) {
                        other = e;
                        break;
                    }
                    if (!proto) {
                        return thisProxyOther(defaultFactory, other, null);
                    }
                    for(;;){
                        const mapping = thisReflectApply(thisMapGet, protoMappings, [
                            proto
                        ]);
                        if (mapping) return mapping(defaultFactory, other);
                        try {
                            proto = otherReflectGetPrototypeOf(proto);
                        } catch (e) {
                            other = e;
                            break;
                        }
                        if (!proto) return thisProxyOther(defaultFactory, other, thisObjectPrototype);
                    }
                    break;
                case "undefined":
                case "string":
                case "number":
                case "boolean":
                case "symbol":
                case "bigint":
                    return other;
                default:
                    throw new VMError(`Unknown type '${type}'`);
            }
        }
        throw new VMError("Exception recursion depth");
    }
    function thisFromOtherWithFactory(factory, other, proto) {
        const type = typeof other;
        switch(type){
            case "object":
                if (other === null) {
                    return null;
                }
            // fallthrough
            case "function":
                const mapped = thisReflectApply(thisWeakMapGet, mappingOtherToThis, [
                    other
                ]);
                if (mapped) return mapped;
                if (proto) {
                    return thisProxyOther(factory, other, proto);
                }
                try {
                    proto = otherReflectGetPrototypeOf(other);
                } catch (e) {
                    throw thisFromOtherForThrow(e);
                }
                if (!proto) {
                    return thisProxyOther(factory, other, null);
                }
                do {
                    const mapping = thisReflectApply(thisMapGet, protoMappings, [
                        proto
                    ]);
                    if (mapping) return mapping(factory, other);
                    try {
                        proto = otherReflectGetPrototypeOf(proto);
                    } catch (e) {
                        throw thisFromOtherForThrow(e);
                    }
                }while (proto);
                return thisProxyOther(factory, other, thisObjectPrototype);
            case "undefined":
            case "string":
            case "number":
            case "boolean":
            case "symbol":
            case "bigint":
                return other;
            default:
                throw new VMError(`Unknown type '${type}'`);
        }
    }
    function thisFromOtherArguments(args) {
        // Note: args@other(safe-array) returns@this(safe-array) throws@this(unsafe)
        const arr = [];
        for(let i = 0; i < args.length; i++){
            const value = thisFromOther(args[i]);
            thisReflectDefineProperty(arr, i, {
                __proto__: null,
                value: value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
        return arr;
    }
    function thisConnect(obj, other) {
        // Note: obj@this(unsafe) other@other(unsafe) throws@this(unsafe)
        try {
            otherReflectApply(otherWeakMapSet, mappingThisToOther, [
                obj,
                other
            ]);
        } catch (e) {
            throw new VMError("Unexpected error");
        }
        thisReflectApply(thisWeakMapSet, mappingOtherToThis, [
            other,
            obj
        ]);
    }
    thisAddProtoMapping(thisGlobalPrototypes.Object, otherGlobalPrototypes.Object);
    thisAddProtoMapping(thisGlobalPrototypes.Array, otherGlobalPrototypes.Array);
    for(let i = 0; i < globalsList.length; i++){
        const key = globalsList[i];
        const tp = thisGlobalPrototypes[key];
        const op = otherGlobalPrototypes[key];
        if (tp && op) thisAddProtoMapping(tp, op, key);
    }
    for(let i = 0; i < errorsList.length; i++){
        const key = errorsList[i];
        const tp = thisGlobalPrototypes[key];
        const op = otherGlobalPrototypes[key];
        if (tp && op) thisAddProtoMapping(tp, op, "Error");
    }
    thisAddProtoMapping(thisGlobalPrototypes.VMError, otherGlobalPrototypes.VMError, "Error");
    result.BaseHandler = BaseHandler;
    result.ProtectedHandler = ProtectedHandler;
    result.ReadOnlyHandler = ReadOnlyHandler;
    result.ReadOnlyMockHandler = ReadOnlyMockHandler;
    return result;
}
exports.createBridge = createBridge;
exports.VMError = VMError;


/***/ }),

/***/ 19297:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const fs = __webpack_require__(57147);
const nmod = __webpack_require__(98188);
const { EventEmitter } = __webpack_require__(82361);
const util = __webpack_require__(73837);
const { VMScript } = __webpack_require__(94458);
const { VM } = __webpack_require__(930);
const eventsModules = new WeakMap();
function defaultBuiltinLoaderEvents(vm) {
    return eventsModules.get(vm);
}
let cacheBufferScript;
function defaultBuiltinLoaderBuffer(vm) {
    if (!cacheBufferScript) {
        cacheBufferScript = new VMScript("return buffer=>({Buffer: buffer});", {
            __proto__: null,
            filename: "buffer.js"
        });
    }
    const makeBuffer = vm.run(cacheBufferScript, {
        __proto__: null,
        strict: true,
        wrapper: "none"
    });
    return makeBuffer(Buffer);
}
let cacheUtilScript;
function defaultBuiltinLoaderUtil(vm) {
    if (!cacheUtilScript) {
        cacheUtilScript = new VMScript(`return function inherits(ctor, superCtor) {
			ctor.super_ = superCtor;
			Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
		}`, {
            __proto__: null,
            filename: "util.js"
        });
    }
    const inherits = vm.run(cacheUtilScript, {
        __proto__: null,
        strict: true,
        wrapper: "none"
    });
    const copy = Object.assign({}, util);
    copy.inherits = inherits;
    return vm.readonly(copy);
}
const BUILTIN_MODULES = (nmod.builtinModules || Object.getOwnPropertyNames(process.binding("natives"))).filter((s)=>!s.startsWith("internal/"));
let EventEmitterReferencingAsyncResourceClass = null;
if (EventEmitter.EventEmitterAsyncResource) {
    // eslint-disable-next-line global-require
    const { AsyncResource } = __webpack_require__(50852);
    const kEventEmitter = Symbol("kEventEmitter");
    class EventEmitterReferencingAsyncResource extends AsyncResource {
        constructor(ee, type, options){
            super(type, options);
            this[kEventEmitter] = ee;
        }
        get eventEmitter() {
            return this[kEventEmitter];
        }
    }
    EventEmitterReferencingAsyncResourceClass = EventEmitterReferencingAsyncResource;
}
let cacheEventsScript;
const SPECIAL_MODULES = {
    events: {
        init (vm) {
            if (!cacheEventsScript) {
                const eventsSource = fs.readFileSync(`${__dirname}/events.js`, "utf8");
                cacheEventsScript = new VMScript(`(function (fromhost) { const module = {}; module.exports={};{ ${eventsSource}
	} return module.exports;})`, {
                    filename: "events.js"
                });
            }
            const closure = VM.prototype.run.call(vm, cacheEventsScript);
            const eventsInstance = closure(vm.readonly({
                kErrorMonitor: EventEmitter.errorMonitor,
                once: EventEmitter.once,
                on: EventEmitter.on,
                getEventListeners: EventEmitter.getEventListeners,
                EventEmitterReferencingAsyncResource: EventEmitterReferencingAsyncResourceClass
            }));
            eventsModules.set(vm, eventsInstance);
            vm._addProtoMapping(EventEmitter.prototype, eventsInstance.EventEmitter.prototype);
        },
        load: defaultBuiltinLoaderEvents
    },
    buffer: defaultBuiltinLoaderBuffer,
    util: defaultBuiltinLoaderUtil
};
function addDefaultBuiltin(builtins, key, hostRequire) {
    if (builtins.has(key)) return;
    const special = SPECIAL_MODULES[key];
    builtins.set(key, special ? special : (vm)=>vm.readonly(hostRequire(key)));
}
function makeBuiltinsFromLegacyOptions(builtins, hostRequire, mocks, overrides) {
    const res = new Map();
    if (mocks) {
        const keys = Object.getOwnPropertyNames(mocks);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            res.set(key, (tvm)=>tvm.readonly(mocks[key]));
        }
    }
    if (overrides) {
        const keys = Object.getOwnPropertyNames(overrides);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            res.set(key, overrides[key]);
        }
    }
    if (Array.isArray(builtins)) {
        const def = builtins.indexOf("*") >= 0;
        if (def) {
            for(let i = 0; i < BUILTIN_MODULES.length; i++){
                const name = BUILTIN_MODULES[i];
                if (builtins.indexOf(`-${name}`) === -1) {
                    addDefaultBuiltin(res, name, hostRequire);
                }
            }
        } else {
            for(let i = 0; i < BUILTIN_MODULES.length; i++){
                const name = BUILTIN_MODULES[i];
                if (builtins.indexOf(name) !== -1) {
                    addDefaultBuiltin(res, name, hostRequire);
                }
            }
        }
    } else if (builtins) {
        for(let i = 0; i < BUILTIN_MODULES.length; i++){
            const name = BUILTIN_MODULES[i];
            if (builtins[name]) {
                addDefaultBuiltin(res, name, hostRequire);
            }
        }
    }
    return res;
}
function makeBuiltins(builtins, hostRequire) {
    const res = new Map();
    for(let i = 0; i < builtins.length; i++){
        const name = builtins[i];
        addDefaultBuiltin(res, name, hostRequire);
    }
    return res;
}
exports.makeBuiltinsFromLegacyOptions = makeBuiltinsFromLegacyOptions;
exports.makeBuiltins = makeBuiltins;


/***/ }),

/***/ 75573:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const { VMError } = __webpack_require__(82151);
let cacheCoffeeScriptCompiler;
/**
 * Returns the cached coffee script compiler or loads it
 * if it is not found in the cache.
 *
 * @private
 * @return {compileCallback} The coffee script compiler.
 * @throws {VMError} If the coffee-script module can't be found.
 */ function getCoffeeScriptCompiler() {
    if (!cacheCoffeeScriptCompiler) {
        try {
            // The warning generated by webpack can be disabled by setting:
            // ignoreWarnings[].message = /Can't resolve 'coffee-script'/
            /* eslint-disable-next-line global-require */ const coffeeScript = __webpack_require__(88933);
            cacheCoffeeScriptCompiler = (code, filename)=>{
                return coffeeScript.compile(code, {
                    header: false,
                    bare: true
                });
            };
        } catch (e) {
            throw new VMError("Coffee-Script compiler is not installed.");
        }
    }
    return cacheCoffeeScriptCompiler;
}
/**
 * Remove the shebang from source code.
 *
 * @private
 * @param {string} code - Code from which to remove the shebang.
 * @return {string} code without the shebang.
 */ function removeShebang(code) {
    if (!code.startsWith("#!")) return code;
    return "//" + code.substring(2);
}
/**
 * The JavaScript compiler, just a identity function.
 *
 * @private
 * @type {compileCallback}
 * @param {string} code - The JavaScript code.
 * @param {string} filename - Filename of this script.
 * @return {string} The code.
 */ function jsCompiler(code, filename) {
    return removeShebang(code);
}
/**
 * Look up the compiler for a specific name.
 *
 * @private
 * @param {(string|compileCallback)} compiler - A compile callback or the name of the compiler.
 * @return {compileCallback} The resolved compiler.
 * @throws {VMError} If the compiler is unknown or the coffee script module was needed and couldn't be found.
 */ function lookupCompiler(compiler) {
    if ("function" === typeof compiler) return compiler;
    switch(compiler){
        case "coffeescript":
        case "coffee-script":
        case "cs":
        case "text/coffeescript":
            return getCoffeeScriptCompiler();
        case "javascript":
        case "java-script":
        case "js":
        case "text/javascript":
            return jsCompiler;
        default:
            throw new VMError(`Unsupported compiler '${compiler}'.`);
    }
}
exports.removeShebang = removeShebang;
exports.lookupCompiler = lookupCompiler;


/***/ }),

/***/ 24137:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const pa = __webpack_require__(71017);
const fs = __webpack_require__(57147);
class DefaultFileSystem {
    resolve(path) {
        return pa.resolve(path);
    }
    isSeparator(char) {
        return char === "/" || char === pa.sep;
    }
    isAbsolute(path) {
        return pa.isAbsolute(path);
    }
    join(...paths) {
        return pa.join(...paths);
    }
    basename(path) {
        return pa.basename(path);
    }
    dirname(path) {
        return pa.dirname(path);
    }
    statSync(path, options) {
        return fs.statSync(path, options);
    }
    readFileSync(path, options) {
        return fs.readFileSync(path, options);
    }
}
class VMFileSystem {
    constructor({ fs: fsModule = fs, path: pathModule = pa } = {}){
        this.fs = fsModule;
        this.path = pathModule;
    }
    resolve(path) {
        return this.path.resolve(path);
    }
    isSeparator(char) {
        return char === "/" || char === this.path.sep;
    }
    isAbsolute(path) {
        return this.path.isAbsolute(path);
    }
    join(...paths) {
        return this.path.join(...paths);
    }
    basename(path) {
        return this.path.basename(path);
    }
    dirname(path) {
        return this.path.dirname(path);
    }
    statSync(path, options) {
        return this.fs.statSync(path, options);
    }
    readFileSync(path, options) {
        return this.fs.readFileSync(path, options);
    }
}
exports.DefaultFileSystem = DefaultFileSystem;
exports.VMFileSystem = VMFileSystem;


/***/ }),

/***/ 75846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

const { VMError } = __webpack_require__(82151);
const { VMScript } = __webpack_require__(94458);
const { VM } = __webpack_require__(930);
const { NodeVM } = __webpack_require__(28820);
const { VMFileSystem } = __webpack_require__(24137);
const { Resolver } = __webpack_require__(90061);
const { makeResolverFromLegacyOptions } = __webpack_require__(64401);
__webpack_unused_export__ = VMError;
__webpack_unused_export__ = VMScript;
__webpack_unused_export__ = NodeVM;
exports.VM = VM;
__webpack_unused_export__ = VMFileSystem;
__webpack_unused_export__ = Resolver;
__webpack_unused_export__ = makeResolverFromLegacyOptions;


/***/ }),

/***/ 28820:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * This callback will be called to resolve a module if it couldn't be found.
 *
 * @callback resolveCallback
 * @param {string} moduleName - Name of the module used to resolve.
 * @param {string} dirname - Name of the current directory.
 * @return {(string|undefined)} The file or directory to use to load the requested module.
 */ /**
 * This callback will be called to require a module instead of node's require.
 *
 * @callback customRequire
 * @param {string} moduleName - Name of the module requested.
 * @return {*} The required module object.
 */ /**
 * This callback will be called to specify the context to use "per" module. Defaults to 'sandbox' if no return value provided.
 *
 * NOTE: many interoperating modules must live in the same context.
 *
 * @callback pathContextCallback
 * @param {string} modulePath - The full path to the module filename being requested.
 * @param {string} extensionType - The module type (node = native, js = cjs/esm module)
 * @return {("host"|"sandbox")} The context for this module.
 */ const fs = __webpack_require__(57147);
const pa = __webpack_require__(71017);
const { Script } = __webpack_require__(26144);
const { VMError } = __webpack_require__(82151);
const { VMScript, MODULE_PREFIX, STRICT_MODULE_PREFIX, MODULE_SUFFIX } = __webpack_require__(94458);
const { transformer } = __webpack_require__(31615);
const { VM } = __webpack_require__(930);
const { makeResolverFromLegacyOptions } = __webpack_require__(64401);
const { Resolver } = __webpack_require__(90061);
const objectDefineProperty = Object.defineProperty;
const objectDefineProperties = Object.defineProperties;
/**
 * Host objects
 *
 * @private
 */ const HOST = Object.freeze({
    __proto__: null,
    version: parseInt(process.versions.node.split(".")[0]),
    process,
    console,
    setTimeout,
    setInterval,
    setImmediate,
    clearTimeout,
    clearInterval,
    clearImmediate
});
/**
 * Compile a script.
 *
 * @private
 * @param {string} filename - Filename of the script.
 * @param {string} script - Script.
 * @return {vm.Script} The compiled script.
 */ function compileScript(filename, script) {
    return new Script(script, {
        __proto__: null,
        filename,
        displayErrors: false
    });
}
let cacheSandboxScript = null;
let cacheMakeNestingScript = null;
const NESTING_OVERRIDE = Object.freeze({
    __proto__: null,
    vm2: vm2NestingLoader
});
function makeCustomExtensions(vm, resolver, sourceExtensions) {
    const extensions = {
        __proto__: null
    };
    const loadJS = resolver.makeExtensionHandler(vm, "loadJS");
    for(let i = 0; i < sourceExtensions.length; i++){
        extensions["." + sourceExtensions[i]] = loadJS;
    }
    if (!extensions[".json"]) extensions[".json"] = resolver.makeExtensionHandler(vm, "loadJSON");
    if (!extensions[".node"]) extensions[".node"] = resolver.makeExtensionHandler(vm, "loadNode");
    return extensions;
}
function makeSafePaths(unsafePaths) {
    if (unsafePaths === undefined) return undefined;
    if (!Array.isArray(unsafePaths)) return true;
    const paths = [
        ...unsafePaths
    ];
    if (paths.some((path)=>typeof path !== "string")) return true;
    return paths;
}
function makeSafeOptions(unsafeOptions) {
    if (unsafeOptions === undefined || unsafeOptions == null) return unsafeOptions;
    if (typeof unsafeOptions !== "object" && typeof unsafeOptions !== "function") return unsafeOptions;
    return {
        unsafeOptions,
        paths: makeSafePaths(unsafeOptions.paths)
    };
}
/**
 * Event caused by a <code>console.debug</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.debug"
 * @type {...*}
 */ /**
 * Event caused by a <code>console.log</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.log"
 * @type {...*}
 */ /**
 * Event caused by a <code>console.info</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.info"
 * @type {...*}
 */ /**
 * Event caused by a <code>console.warn</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.warn"
 * @type {...*}
 */ /**
 * Event caused by a <code>console.error</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.error"
 * @type {...*}
 */ /**
 * Event caused by a <code>console.dir</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.dir"
 * @type {...*}
 */ /**
 * Event caused by a <code>console.trace</code> call if <code>options.console="redirect"</code> is specified.
 *
 * @public
 * @event NodeVM."console.trace"
 * @type {...*}
 */ /**
 * Class NodeVM.
 *
 * @public
 * @extends {VM}
 * @extends {EventEmitter}
 */ class NodeVM extends VM {
    /**
	 * Create a new NodeVM instance.<br>
	 *
	 * Unlike VM, NodeVM lets you use require same way like in regular node.<br>
	 *
	 * However, it does not use the timeout.
	 *
	 * @public
	 * @param {Object} [options] - VM options.
	 * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.
	 * @param {(string|compileCallback)} [options.compiler="javascript"] - The compiler to use.
	 * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>
	 * Only available for node v10+.
	 * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>
	 * Only available for node v10+.
	 * @param {("inherit"|"redirect"|"off")} [options.console="inherit"] - Sets the behavior of the console in the sandbox.
	 * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.
	 * @param {Object|boolean|Resolver} [options.require=false] - Allow require inside the sandbox.
	 * @param {(boolean|string[]|Object)} [options.require.external=false] - <b>WARNING: When allowing require the option <code>options.require.root</code>
	 * should be set to restrict the script from requiring any module. Values can be true, an array of allowed external modules or an object.
	 * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??],
	 * for instance, will allow using all modules having a name of the form @scope/something-ver-aa, @scope/other-ver-11, etc.
	 * @param {boolean} [options.require.external.transitive=false] - Boolean which indicates if transitive dependencies of external modules are allowed.
	 * @param {string[]} [options.require.builtin=[]] - Array of allowed built-in modules, accepts ["*"] for all.
	 * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.
	 * @param {Object} [options.require.mock] - Collection of mock modules (both external or built-in).
	 * @param {("host"|"sandbox"|pathContextCallback)} [options.require.context="host"] -
	 * <code>host</code> to require modules in host and proxy them to sandbox.
	 * <code>sandbox</code> to load, compile and require modules in sandbox.
	 * <code>pathContext(modulePath, ext)</code> to choose a mode per module (full path provided).
	 * Builtin modules except <code>events</code> always required in host and proxied to sandbox.
	 * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.
	 * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't
	 * found in one of the traditional node lookup paths.
	 * @param {customRequire} [options.require.customRequire=require] - Custom require to require host and built-in modules.
	 * @param {boolean} [options.require.strict=true] - Load required modules in strict mode.
	 * @param {boolean} [options.nesting=false] -
	 * <b>WARNING: Allowing this is a security risk as scripts can create a NodeVM which can require any host module.</b>
	 * Allow nesting of VMs.
	 * @param {("commonjs"|"none")} [options.wrapper="commonjs"] - <code>commonjs</code> to wrap script into CommonJS wrapper,
	 * <code>none</code> to retrieve value returned by the script.
	 * @param {string[]} [options.sourceExtensions=["js"]] - Array of file extensions to treat as source code.
	 * @param {string[]} [options.argv=[]] - Array of arguments passed to <code>process.argv</code>.
	 * This object will not be copied and the script can change this object.
	 * @param {Object} [options.env={}] - Environment map passed to <code>process.env</code>.
	 * This object will not be copied and the script can change this object.
	 * @param {boolean} [options.strict=false] - If modules should be loaded in strict mode.
	 * @throws {VMError} If the compiler is unknown.
	 */ constructor(options = {}){
        const { compiler, eval: allowEval, wasm, console: consoleType = "inherit", require: requireOpts = false, nesting = false, wrapper = "commonjs", sourceExtensions = [
            "js"
        ], argv, env, strict = false, sandbox } = options;
        // Throw this early
        if (sandbox && "object" !== typeof sandbox) {
            throw new VMError("Sandbox must be an object.");
        }
        super({
            __proto__: null,
            compiler: compiler,
            eval: allowEval,
            wasm
        });
        const customResolver = requireOpts instanceof Resolver;
        const resolver = customResolver ? requireOpts : makeResolverFromLegacyOptions(requireOpts, nesting && NESTING_OVERRIDE, this._compiler);
        // This is only here for backwards compatibility.
        objectDefineProperty(this, "options", {
            __proto__: null,
            value: {
                console: consoleType,
                require: requireOpts,
                nesting,
                wrapper,
                sourceExtensions,
                strict
            }
        });
        objectDefineProperty(this, "resolver", {
            __proto__: null,
            value: resolver,
            enumerable: true
        });
        if (!cacheSandboxScript) {
            cacheSandboxScript = compileScript(`${__dirname}/setup-node-sandbox.js`, `(function (host, data) { ${fs.readFileSync(`${__dirname}/setup-node-sandbox.js`, "utf8")}\n})`);
        }
        const closure = this._runScript(cacheSandboxScript);
        const extensions = makeCustomExtensions(this, resolver, sourceExtensions);
        this.readonly(HOST);
        const { Module, jsonParse, createRequireForModule, requireImpl } = closure(HOST, {
            __proto__: null,
            argv,
            env,
            console: consoleType,
            extensions,
            emitArgs: (event, args)=>{
                if (typeof event !== "string" && typeof event !== "symbol") throw new Error("Event is not a string");
                return this.emit(event, ...args);
            },
            globalPaths: [
                ...resolver.globalPaths
            ],
            getLookupPathsFor: (path)=>{
                if (typeof path !== "string") return [];
                return [
                    ...resolver.genLookupPaths(path)
                ];
            },
            resolve: (mod, id, opt, ext, direct)=>{
                if (typeof id !== "string") throw new Error("Id is not a string");
                const extList = Object.getOwnPropertyNames(ext);
                return resolver.resolve(mod, id, makeSafeOptions(opt), extList, !!direct);
            },
            lookupPaths: (mod, id)=>{
                if (typeof id !== "string") throw new Error("Id is not a string");
                return [
                    ...resolver.lookupPaths(mod, id)
                ];
            },
            loadBuiltinModule: (id)=>{
                if (typeof id !== "string") throw new Error("Id is not a string");
                return resolver.loadBuiltinModule(this, id);
            },
            registerModule: (mod, filename, path, parent, direct)=>{
                return resolver.registerModule(mod, filename, path, parent, direct);
            },
            builtinModules: [
                ...resolver.getBuiltinModulesList(this)
            ],
            dirname: (path)=>{
                if (typeof path !== "string") return path;
                return resolver.fs.dirname(path);
            },
            basename: (path)=>{
                if (typeof path !== "string") return path;
                return resolver.fs.basename(path);
            }
        });
        objectDefineProperties(this, {
            __proto__: null,
            _Module: {
                __proto__: null,
                value: Module
            },
            _jsonParse: {
                __proto__: null,
                value: jsonParse
            },
            _createRequireForModule: {
                __proto__: null,
                value: createRequireForModule
            },
            _requireImpl: {
                __proto__: null,
                value: requireImpl
            },
            _cacheRequireModule: {
                __proto__: null,
                value: null,
                writable: true
            }
        });
        resolver.init(this);
        // prepare global sandbox
        if (sandbox) {
            this.setGlobals(sandbox);
        }
        if (!customResolver && requireOpts && requireOpts.import) {
            if (Array.isArray(requireOpts.import)) {
                for(let i = 0, l = requireOpts.import.length; i < l; i++){
                    this.require(requireOpts.import[i]);
                }
            } else {
                this.require(requireOpts.import);
            }
        }
    }
    /**
	 * @ignore
	 * @deprecated
	 */ get _resolver() {
        return this.resolver;
    }
    /**
	 * @ignore
	 * @deprecated Just call the method yourself like <code>method(args);</code>
	 * @param {function} method - Function to invoke.
	 * @param {...*} args - Arguments to pass to the function.
	 * @return {*} Return value of the function.
	 * @todo Can we remove this function? It even had a bug that would use args as this parameter.
	 * @throws {*} Rethrows anything the method throws.
	 * @throws {VMError} If method is not a function.
	 * @throws {Error} If method is a class.
	 */ call(method, ...args) {
        if ("function" === typeof method) {
            return method(...args);
        } else {
            throw new VMError("Unrecognized method type.");
        }
    }
    /**
	 * Require a module in VM and return it's exports.
	 *
	 * @public
	 * @param {string} module - Module name.
	 * @return {*} Exported module.
	 * @throws {*} If the module couldn't be found or loading it threw an error.
	 */ require(module) {
        const path = this.resolver.fs.resolve(".");
        let mod = this._cacheRequireModule;
        if (!mod || mod.path !== path) {
            const filename = this.resolver.fs.join(path, "/vm.js");
            mod = new this._Module(filename, path);
            this.resolver.registerModule(mod, filename, path, null, false);
            this._cacheRequireModule = mod;
        }
        return this._requireImpl(mod, module, true);
    }
    /**
	 * Run the code in NodeVM.
	 *
	 * First time you run this method, code is executed same way like in node's regular `require` - it's executed with
	 * `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.
	 *
	 * @param {(string|VMScript)} code - Code to run.
	 * @param {(string|Object)} [options] - Options map or filename.
	 * @param {string} [options.filename="vm.js"] - Filename that shows up in any stack traces produced from this script.<br>
	 * This is only used if code is a String.
	 * @param {boolean} [options.strict] - If modules should be loaded in strict mode. Defaults to NodeVM options.
	 * @param {("commonjs"|"none")} [options.wrapper] - <code>commonjs</code> to wrap script into CommonJS wrapper,
	 * <code>none</code> to retrieve value returned by the script. Defaults to NodeVM options.
	 * @return {*} Result of executed code.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 * @fires NodeVM."console.debug"
	 * @fires NodeVM."console.log"
	 * @fires NodeVM."console.info"
	 * @fires NodeVM."console.warn"
	 * @fires NodeVM."console.error"
	 * @fires NodeVM."console.dir"
	 * @fires NodeVM."console.trace"
	 */ run(code, options) {
        let script;
        let filename;
        if (typeof options === "object") {
            filename = options.filename;
        } else {
            filename = options;
            options = {
                __proto__: null
            };
        }
        const { strict = this.options.strict, wrapper = this.options.wrapper, module: customModule, require: customRequire, dirname: customDirname = null } = options;
        let sandboxModule = customModule;
        let dirname = customDirname;
        if (code instanceof VMScript) {
            script = strict ? code._compileNodeVMStrict() : code._compileNodeVM();
            if (!sandboxModule) {
                const resolvedFilename = this.resolver.fs.resolve(code.filename);
                dirname = this.resolver.fs.dirname(resolvedFilename);
                sandboxModule = new this._Module(resolvedFilename, dirname);
                this.resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);
            }
        } else {
            const unresolvedFilename = filename || "vm.js";
            if (!sandboxModule) {
                if (filename) {
                    const resolvedFilename = this.resolver.fs.resolve(filename);
                    dirname = this.resolver.fs.dirname(resolvedFilename);
                    sandboxModule = new this._Module(resolvedFilename, dirname);
                    this.resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);
                } else {
                    sandboxModule = new this._Module(null, null);
                    sandboxModule.id = unresolvedFilename;
                }
            }
            const prefix = strict ? STRICT_MODULE_PREFIX : MODULE_PREFIX;
            let scriptCode = this._compiler(code, unresolvedFilename);
            scriptCode = transformer(null, scriptCode, false, false, unresolvedFilename).code;
            script = new Script(prefix + scriptCode + MODULE_SUFFIX, {
                __proto__: null,
                filename: unresolvedFilename,
                displayErrors: false
            });
        }
        const closure = this._runScript(script);
        const usedRequire = customRequire || this._createRequireForModule(sandboxModule);
        const ret = Reflect.apply(closure, this.sandbox, [
            sandboxModule.exports,
            usedRequire,
            sandboxModule,
            filename,
            dirname
        ]);
        return wrapper === "commonjs" ? sandboxModule.exports : ret;
    }
    /**
	 * Create NodeVM and run code inside it.
	 *
	 * @public
	 * @static
	 * @param {string} script - Code to execute.
	 * @param {string} [filename] - File name (used in stack traces only).
	 * @param {Object} [options] - VM options.
	 * @param {string} [options.filename] - File name (used in stack traces only). Used if <code>filename</code> is omitted.
	 * @return {*} Result of executed code.
	 * @see {@link NodeVM} for the options.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */ static code(script, filename, options) {
        let unresolvedFilename;
        if (filename != null) {
            if ("object" === typeof filename) {
                options = filename;
                unresolvedFilename = options.filename;
            } else if ("string" === typeof filename) {
                unresolvedFilename = filename;
            } else {
                throw new VMError("Invalid arguments.");
            }
        } else if ("object" === typeof options) {
            unresolvedFilename = options.filename;
        }
        if (arguments.length > 3) {
            throw new VMError("Invalid number of arguments.");
        }
        const resolvedFilename = typeof unresolvedFilename === "string" ? pa.resolve(unresolvedFilename) : undefined;
        return new NodeVM(options).run(script, resolvedFilename);
    }
    /**
	 * Create NodeVM and run script from file inside it.
	 *
	 * @public
	 * @static
	 * @param {string} filename - Filename of file to load and execute in a NodeVM.
	 * @param {Object} [options] - NodeVM options.
	 * @return {*} Result of executed code.
	 * @see {@link NodeVM} for the options.
	 * @throws {Error} If filename is not a valid filename.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */ static file(filename, options) {
        const resolvedFilename = pa.resolve(filename);
        if (!fs.existsSync(resolvedFilename)) {
            throw new VMError(`Script '${filename}' not found.`);
        }
        if (fs.statSync(resolvedFilename).isDirectory()) {
            throw new VMError("Script must be file, got directory.");
        }
        return new NodeVM(options).run(fs.readFileSync(resolvedFilename, "utf8"), resolvedFilename);
    }
}
function vm2NestingLoader(vm) {
    if (!cacheMakeNestingScript) {
        cacheMakeNestingScript = compileScript("nesting.js", "(vm, nodevm) => ({VM: vm, NodeVM: nodevm})");
    }
    const makeNesting = vm._runScript(cacheMakeNestingScript);
    return makeNesting(vm.readonly(VM), vm.readonly(NodeVM));
}
exports.NodeVM = NodeVM;


/***/ }),

/***/ 64401:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Translate the old options to the new Resolver functionality.
const { Resolver, DefaultResolver } = __webpack_require__(90061);
const { VMError } = __webpack_require__(82151);
const { DefaultFileSystem } = __webpack_require__(24137);
const { makeBuiltinsFromLegacyOptions } = __webpack_require__(19297);
const { jsCompiler } = __webpack_require__(75573);
/**
 * Require wrapper to be able to annotate require with webpackIgnore.
 *
 * @private
 * @param {string} moduleName - Name of module to load.
 * @return {*} Module exports.
 */ function defaultRequire(moduleName) {
    // Set module.parser.javascript.commonjsMagicComments=true in your webpack config.
    // eslint-disable-next-line global-require
    return __webpack_require__(53952)(moduleName);
}
// source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
function escapeRegExp(string) {
    return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
function makeExternalMatcherRegex(obj) {
    return escapeRegExp(obj).replace(/\\\\|\//g, "[\\\\/]").replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^\\\\/]*").replace(/\\\?/g, "[^\\\\/]");
}
function makeExternalMatcher(obj) {
    const regexString = makeExternalMatcherRegex(obj);
    return new RegExp(`[\\\\/]node_modules[\\\\/]${regexString}(?:[\\\\/](?!(?:.*[\\\\/])?node_modules[\\\\/]).*)?$`);
}
class CustomResolver extends DefaultResolver {
    constructor(fileSystem, globalPaths, builtinModules, rootPaths, pathContext, customResolver, hostRequire, compiler, strict){
        super(fileSystem, globalPaths, builtinModules);
        this.rootPaths = rootPaths;
        this.pathContext = pathContext;
        this.customResolver = customResolver;
        this.hostRequire = hostRequire;
        this.compiler = compiler;
        this.strict = strict;
    }
    isPathAllowed(filename) {
        return this.rootPaths === undefined || this.rootPaths.some((path)=>{
            if (!filename.startsWith(path)) return false;
            const len = path.length;
            if (filename.length === len || len > 0 && this.fs.isSeparator(path[len - 1])) return true;
            return this.fs.isSeparator(filename[len]);
        });
    }
    loadJS(vm, mod, filename) {
        if (this.pathContext(filename, "js") !== "host") return super.loadJS(vm, mod, filename);
        const m = this.hostRequire(filename);
        mod.exports = vm.readonly(m);
    }
    loadNode(vm, mod, filename) {
        if (this.pathContext(filename, "node") !== "host") return super.loadNode(vm, mod, filename);
        const m = this.hostRequire(filename);
        mod.exports = vm.readonly(m);
    }
    customResolve(x, path, extList) {
        if (this.customResolver === undefined) return undefined;
        const resolved = this.customResolver(x, path);
        if (!resolved) return undefined;
        if (typeof resolved === "string") {
            return this.loadAsFileOrDirectory(resolved, extList);
        }
        const { module = x, path: resolvedPath } = resolved;
        return this.loadNodeModules(module, [
            resolvedPath
        ], extList);
    }
    getCompiler(filename) {
        return this.compiler;
    }
    isStrict(filename) {
        return this.strict;
    }
}
class LegacyResolver extends CustomResolver {
    constructor(fileSystem, globalPaths, builtinModules, rootPaths, pathContext, customResolver, hostRequire, compiler, strict, externals, allowTransitive){
        super(fileSystem, globalPaths, builtinModules, rootPaths, pathContext, customResolver, hostRequire, compiler, strict);
        this.externals = externals.map(makeExternalMatcher);
        this.externalCache = externals.map((pattern)=>new RegExp(makeExternalMatcherRegex(pattern)));
        this.currMod = undefined;
        this.trustedMods = new WeakMap();
        this.allowTransitive = allowTransitive;
    }
    isPathAllowed(path) {
        return this.isPathAllowedForModule(path, this.currMod);
    }
    isPathAllowedForModule(path, mod) {
        if (!super.isPathAllowed(path)) return false;
        if (mod) {
            if (mod.allowTransitive) return true;
            if (path.startsWith(mod.path)) {
                const rem = path.slice(mod.path.length);
                if (!/(?:^|[\\\\/])node_modules(?:$|[\\\\/])/.test(rem)) return true;
            }
        }
        return this.externals.some((regex)=>regex.test(path));
    }
    registerModule(mod, filename, path, parent, direct) {
        const trustedParent = this.trustedMods.get(parent);
        this.trustedMods.set(mod, {
            filename,
            path,
            paths: this.genLookupPaths(path),
            allowTransitive: this.allowTransitive && (direct && trustedParent && trustedParent.allowTransitive || this.externals.some((regex)=>regex.test(filename)))
        });
    }
    resolveFull(mod, x, options, extList, direct) {
        this.currMod = undefined;
        if (!direct) return super.resolveFull(mod, x, options, extList, false);
        const trustedMod = this.trustedMods.get(mod);
        if (!trustedMod || mod.path !== trustedMod.path) return super.resolveFull(mod, x, options, extList, false);
        const paths = [
            ...mod.paths
        ];
        if (paths.length !== trustedMod.paths.length) return super.resolveFull(mod, x, options, extList, false);
        for(let i = 0; i < paths.length; i++){
            if (paths[i] !== trustedMod.paths[i]) {
                return super.resolveFull(mod, x, options, extList, false);
            }
        }
        try {
            this.currMod = trustedMod;
            return super.resolveFull(trustedMod, x, options, extList, true);
        } finally{
            this.currMod = undefined;
        }
    }
    checkAccess(mod, filename) {
        const trustedMod = this.trustedMods.get(mod);
        if ((!trustedMod || trustedMod.filename !== filename) && !this.isPathAllowedForModule(filename, undefined)) {
            throw new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, "EDENIED");
        }
    }
    loadJS(vm, mod, filename) {
        if (this.pathContext(filename, "js") !== "host") {
            const trustedMod = this.trustedMods.get(mod);
            const script = this.readScript(filename);
            vm.run(script, {
                filename,
                strict: this.isStrict(filename),
                module: mod,
                wrapper: "none",
                dirname: trustedMod ? trustedMod.path : mod.path
            });
        } else {
            const m = this.hostRequire(filename);
            mod.exports = vm.readonly(m);
        }
    }
    customResolve(x, path, extList) {
        if (this.customResolver === undefined) return undefined;
        if (!(this.pathIsAbsolute(x) || this.pathIsRelative(x))) {
            if (!this.externalCache.some((regex)=>regex.test(x))) return undefined;
        }
        const resolved = this.customResolver(x, path);
        if (!resolved) return undefined;
        if (typeof resolved === "string") {
            this.externals.push(new RegExp("^" + escapeRegExp(resolved)));
            return this.loadAsFileOrDirectory(resolved, extList);
        }
        const { module = x, path: resolvedPath } = resolved;
        this.externals.push(new RegExp("^" + escapeRegExp(resolvedPath)));
        return this.loadNodeModules(module, [
            resolvedPath
        ], extList);
    }
}
const DEFAULT_FS = new DefaultFileSystem();
const DENY_RESOLVER = new Resolver(DEFAULT_FS, [], new Map());
function makeResolverFromLegacyOptions(options, override, compiler) {
    if (!options) {
        if (!override) return DENY_RESOLVER;
        const builtins = makeBuiltinsFromLegacyOptions(undefined, defaultRequire, undefined, override);
        return new Resolver(DEFAULT_FS, [], builtins);
    }
    const { builtin: builtinOpt, mock: mockOpt, external: externalOpt, root: rootPaths, resolve: customResolver, customRequire: hostRequire = defaultRequire, context = "host", strict = true, fs: fsOpt = DEFAULT_FS } = options;
    const builtins = makeBuiltinsFromLegacyOptions(builtinOpt, hostRequire, mockOpt, override);
    if (!externalOpt) return new Resolver(fsOpt, [], builtins);
    if (!compiler) compiler = jsCompiler;
    const checkedRootPaths = rootPaths ? (Array.isArray(rootPaths) ? rootPaths : [
        rootPaths
    ]).map((f)=>fsOpt.resolve(f)) : undefined;
    const pathContext = typeof context === "function" ? context : ()=>context;
    if (typeof externalOpt !== "object") {
        return new CustomResolver(fsOpt, [], builtins, checkedRootPaths, pathContext, customResolver, hostRequire, compiler, strict);
    }
    let transitive = false;
    let external = undefined;
    if (Array.isArray(externalOpt)) {
        external = externalOpt;
    } else {
        external = externalOpt.modules;
        transitive = context !== "host" && externalOpt.transitive;
    }
    return new LegacyResolver(fsOpt, [], builtins, checkedRootPaths, pathContext, customResolver, hostRequire, compiler, strict, external, transitive);
}
exports.makeResolverFromLegacyOptions = makeResolverFromLegacyOptions;


/***/ }),

/***/ 90061:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// The Resolver is currently experimental and might be exposed to users in the future.
const { VMError } = __webpack_require__(82151);
const { VMScript } = __webpack_require__(94458);
const { jsCopmiler } = __webpack_require__(75573);
// This should match. Note that '\', '%' are invalid characters
// 1. name/.*
// 2. @scope/name/.*
const EXPORTS_PATTERN = /^((?:@[^/\\%]+\/)?[^/\\%]+)(\/.*)?$/;
// See https://tc39.es/ecma262/#integer-index
function isArrayIndex(key) {
    const keyNum = +key;
    if (`${keyNum}` !== key) return false;
    return keyNum >= 0 && keyNum < 0xFFFFFFFF;
}
class Resolver {
    constructor(fs, globalPaths, builtins){
        this.fs = fs;
        this.globalPaths = globalPaths;
        this.builtins = builtins;
    }
    init(vm) {}
    isPathAllowed(path) {
        return false;
    }
    checkAccess(mod, filename) {
        if (!this.isPathAllowed(filename)) {
            throw new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, "EDENIED");
        }
    }
    pathIsRelative(path) {
        if (path === "" || path[0] !== ".") return false;
        if (path.length === 1) return true;
        const idx = path[1] === "." ? 2 : 1;
        if (path.length <= idx) return false;
        return this.fs.isSeparator(path[idx]);
    }
    pathIsAbsolute(path) {
        return path !== "" && (this.fs.isSeparator(path[0]) || this.fs.isAbsolute(path));
    }
    lookupPaths(mod, id) {
        if (this.pathIsRelative(id)) return [
            mod.path || "."
        ];
        return [
            ...mod.paths,
            ...this.globalPaths
        ];
    }
    getBuiltinModulesList(vm) {
        if (this.builtins === undefined) return [];
        const res = [];
        this.builtins.forEach((value, key)=>{
            if (typeof value === "object") value.init(vm);
            res.push(key);
        });
        return res;
    }
    loadBuiltinModule(vm, id) {
        if (this.builtins === undefined) return undefined;
        const builtin = this.builtins.get(id);
        if (!builtin) return undefined;
        if (typeof builtin === "function") return builtin(vm);
        return builtin.load(vm);
    }
    makeExtensionHandler(vm, name) {
        return (mod, filename)=>{
            filename = this.fs.resolve(filename);
            this.checkAccess(mod, filename);
            this[name](vm, mod, filename);
        };
    }
    getExtensions(vm) {
        return {
            // eslint-disable-next-line quote-props
            __proto__: null,
            ".js": this.makeExtensionHandler(vm, "loadJS"),
            ".json": this.makeExtensionHandler(vm, "loadJSON"),
            " .node": this.makeExtensionHandler(vm, "loadNode")
        };
    }
    loadJS(vm, mod, filename) {
        throw new VMError(`Access denied to require '${filename}'`, "EDENIED");
    }
    loadJSON(vm, mod, filename) {
        throw new VMError(`Access denied to require '${filename}'`, "EDENIED");
    }
    loadNode(vm, mod, filename) {
        throw new VMError(`Access denied to require '${filename}'`, "EDENIED");
    }
    registerModule(mod, filename, path, parent, direct) {}
    resolve(mod, x, options, extList, direct) {
        if (x.startsWith("node:") || this.builtins.has(x)) {
            // a. return the core module
            // b. STOP
            return x;
        }
        return this.resolveFull(mod, x, options, extList, direct);
    }
    resolveFull(mod, x, options, extList, direct) {
        // 7. THROW "not found"
        throw new VMError(`Cannot find module '${x}'`, "ENOTFOUND");
    }
    // NODE_MODULES_PATHS(START)
    genLookupPaths(path) {
        // 1. let PARTS = path split(START)
        // 2. let I = count of PARTS - 1
        // 3. let DIRS = []
        const dirs = [];
        // 4. while I >= 0,
        while(true){
            const name = this.fs.basename(path);
            // a. if PARTS[I] = "node_modules" CONTINUE
            if (name !== "node_modules") {
                // b. DIR = path join(PARTS[0 .. I] + "node_modules")
                // c. DIRS = DIR + DIRS // Note: this seems wrong. Should be DIRS + DIR
                dirs.push(this.fs.join(path, "node_modules"));
            }
            const dir = this.fs.dirname(path);
            if (dir == path) break;
            // d. let I = I - 1
            path = dir;
        }
        return dirs;
    // This is done later on
    // 5. return DIRS + GLOBAL_FOLDERS
    }
}
function pathTestIsDirectory(fs, path) {
    try {
        const stat = fs.statSync(path, {
            __proto__: null,
            throwIfNoEntry: false
        });
        return stat && stat.isDirectory();
    } catch (e) {
        return false;
    }
}
function pathTestIsFile(fs, path) {
    try {
        const stat = fs.statSync(path, {
            __proto__: null,
            throwIfNoEntry: false
        });
        return stat && stat.isFile();
    } catch (e) {
        return false;
    }
}
function readFile(fs, path) {
    return fs.readFileSync(path, {
        encoding: "utf8"
    });
}
function readFileWhenExists(fs, path) {
    return pathTestIsFile(fs, path) ? readFile(fs, path) : undefined;
}
class DefaultResolver extends Resolver {
    constructor(fs, globalPaths, builtins){
        super(fs, globalPaths, builtins);
        this.packageCache = new Map();
        this.scriptCache = new Map();
    }
    getCompiler(filename) {
        return jsCopmiler;
    }
    isStrict(filename) {
        return true;
    }
    readScript(filename) {
        let script = this.scriptCache.get(filename);
        if (!script) {
            script = new VMScript(readFile(this.fs, filename), {
                filename,
                compiler: this.getCompiler(filename)
            });
            this.scriptCache.set(filename, script);
        }
        return script;
    }
    loadJS(vm, mod, filename) {
        const script = this.readScript(filename);
        vm.run(script, {
            filename,
            strict: this.isStrict(filename),
            module: mod,
            wrapper: "none",
            dirname: mod.path
        });
    }
    loadJSON(vm, mod, filename) {
        const json = readFile(this.fs, filename);
        mod.exports = vm._jsonParse(json);
    }
    loadNode(vm, mod, filename) {
        throw new VMError("Native modules can be required only with context set to 'host'.");
    }
    customResolve(x, path, extList) {
        return undefined;
    }
    // require(X) from module at path Y
    resolveFull(mod, x, options, extList, direct) {
        // Note: core module handled by caller
        const path = mod.path || ".";
        // 5. LOAD_PACKAGE_SELF(X, dirname(Y))
        let f = this.loadPackageSelf(x, path, extList);
        if (f) return f;
        // 4. If X begins with '#'
        if (x[0] === "#") {
            // a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))
            f = this.loadPackageImports(x, path, extList);
            if (f) return f;
        }
        // 2. If X begins with '/'
        if (this.pathIsAbsolute(x)) {
            // a. set Y to be the filesystem root
            f = this.loadAsFileOrDirectory(x, extList);
            if (f) return f;
            // c. THROW "not found"
            throw new VMError(`Cannot find module '${x}'`, "ENOTFOUND");
        // 3. If X begins with './' or '/' or '../'
        } else if (this.pathIsRelative(x)) {
            if (typeof options === "object" && options !== null) {
                const paths = options.paths;
                if (Array.isArray(paths)) {
                    for(let i = 0; i < paths.length; i++){
                        // a. LOAD_AS_FILE(Y + X)
                        // b. LOAD_AS_DIRECTORY(Y + X)
                        f = this.loadAsFileOrDirectory(this.fs.join(paths[i], x), extList);
                        if (f) return f;
                    }
                } else if (paths === undefined) {
                    // a. LOAD_AS_FILE(Y + X)
                    // b. LOAD_AS_DIRECTORY(Y + X)
                    f = this.loadAsFileOrDirectory(this.fs.join(path, x), extList);
                    if (f) return f;
                } else {
                    throw new VMError("Invalid options.paths option.");
                }
            } else {
                // a. LOAD_AS_FILE(Y + X)
                // b. LOAD_AS_DIRECTORY(Y + X)
                f = this.loadAsFileOrDirectory(this.fs.join(path, x), extList);
                if (f) return f;
            }
            // c. THROW "not found"
            throw new VMError(`Cannot find module '${x}'`, "ENOTFOUND");
        }
        let dirs;
        if (typeof options === "object" && options !== null) {
            const paths = options.paths;
            if (Array.isArray(paths)) {
                dirs = [];
                for(let i = 0; i < paths.length; i++){
                    const lookups = this.genLookupPaths(paths[i]);
                    for(let j = 0; j < lookups.length; j++){
                        if (!dirs.includes(lookups[j])) dirs.push(lookups[j]);
                    }
                    if (i === 0) {
                        const globalPaths = this.globalPaths;
                        for(let j = 0; j < globalPaths.length; j++){
                            if (!dirs.includes(globalPaths[j])) dirs.push(globalPaths[j]);
                        }
                    }
                }
            } else if (paths === undefined) {
                dirs = [
                    ...mod.paths,
                    ...this.globalPaths
                ];
            } else {
                throw new VMError("Invalid options.paths option.");
            }
        } else {
            dirs = [
                ...mod.paths,
                ...this.globalPaths
            ];
        }
        // 6. LOAD_NODE_MODULES(X, dirname(Y))
        f = this.loadNodeModules(x, dirs, extList);
        if (f) return f;
        f = this.customResolve(x, path, extList);
        if (f) return f;
        return super.resolveFull(mod, x, options, extList, direct);
    }
    loadAsFileOrDirectory(x, extList) {
        // a. LOAD_AS_FILE(X)
        const f = this.loadAsFile(x, extList);
        if (f) return f;
        // b. LOAD_AS_DIRECTORY(X)
        return this.loadAsDirectory(x, extList);
    }
    tryFile(x) {
        x = this.fs.resolve(x);
        return this.isPathAllowed(x) && pathTestIsFile(this.fs, x) ? x : undefined;
    }
    tryWithExtension(x, extList) {
        for(let i = 0; i < extList.length; i++){
            const ext = extList[i];
            if (ext !== this.fs.basename(ext)) continue;
            const f = this.tryFile(x + ext);
            if (f) return f;
        }
        return undefined;
    }
    readPackage(path) {
        const packagePath = this.fs.resolve(this.fs.join(path, "package.json"));
        const cache = this.packageCache.get(packagePath);
        if (cache !== undefined) return cache;
        if (!this.isPathAllowed(packagePath)) return undefined;
        const content = readFileWhenExists(this.fs, packagePath);
        if (!content) {
            this.packageCache.set(packagePath, false);
            return false;
        }
        let parsed;
        try {
            parsed = JSON.parse(content);
        } catch (e) {
            e.path = packagePath;
            e.message = "Error parsing " + packagePath + ": " + e.message;
            throw e;
        }
        const filtered = {
            name: parsed.name,
            main: parsed.main,
            exports: parsed.exports,
            imports: parsed.imports,
            type: parsed.type
        };
        this.packageCache.set(packagePath, filtered);
        return filtered;
    }
    readPackageScope(path) {
        while(true){
            const dir = this.fs.dirname(path);
            if (dir === path) break;
            const basename = this.fs.basename(dir);
            if (basename === "node_modules") break;
            const pack = this.readPackage(dir);
            if (pack) return {
                data: pack,
                scope: dir
            };
            path = dir;
        }
        return {
            data: undefined,
            scope: undefined
        };
    }
    // LOAD_AS_FILE(X)
    loadAsFile(x, extList) {
        // 1. If X is a file, load X as its file extension format. STOP
        const f = this.tryFile(x);
        if (f) return f;
        // 2. If X.js is a file, load X.js as JavaScript text. STOP
        // 3. If X.json is a file, parse X.json to a JavaScript Object. STOP
        // 4. If X.node is a file, load X.node as binary addon. STOP
        return this.tryWithExtension(x, extList);
    }
    // LOAD_INDEX(X)
    loadIndex(x, extList) {
        // 1. If X/index.js is a file, load X/index.js as JavaScript text. STOP
        // 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
        // 3. If X/index.node is a file, load X/index.node as binary addon. STOP
        return this.tryWithExtension(this.fs.join(x, "index"), extList);
    }
    // LOAD_AS_DIRECTORY(X)
    loadAsPackage(x, pack, extList) {
        // 1. If X/package.json is a file,
        // already done.
        if (pack) {
            // a. Parse X/package.json, and look for "main" field.
            // b. If "main" is a falsy value, GOTO 2.
            if (typeof pack.main === "string") {
                // c. let M = X + (json main field)
                const m = this.fs.join(x, pack.main);
                // d. LOAD_AS_FILE(M)
                let f = this.loadAsFile(m, extList);
                if (f) return f;
                // e. LOAD_INDEX(M)
                f = this.loadIndex(m, extList);
                if (f) return f;
                // f. LOAD_INDEX(X) DEPRECATED
                f = this.loadIndex(x, extList);
                if (f) return f;
                // g. THROW "not found"
                throw new VMError(`Cannot find module '${x}'`, "ENOTFOUND");
            }
        }
        // 2. LOAD_INDEX(X)
        return this.loadIndex(x, extList);
    }
    // LOAD_AS_DIRECTORY(X)
    loadAsDirectory(x, extList) {
        // 1. If X/package.json is a file,
        const pack = this.readPackage(x);
        return this.loadAsPackage(x, pack, extList);
    }
    // LOAD_NODE_MODULES(X, START)
    loadNodeModules(x, dirs, extList) {
        // 1. let DIRS = NODE_MODULES_PATHS(START)
        // This step is already done.
        // 2. for each DIR in DIRS:
        for(let i = 0; i < dirs.length; i++){
            const dir = dirs[i];
            // a. LOAD_PACKAGE_EXPORTS(X, DIR)
            let f = this.loadPackageExports(x, dir, extList);
            if (f) return f;
            // b. LOAD_AS_FILE(DIR/X)
            f = this.loadAsFile(dir + "/" + x, extList);
            if (f) return f;
            // c. LOAD_AS_DIRECTORY(DIR/X)
            f = this.loadAsDirectory(dir + "/" + x, extList);
            if (f) return f;
        }
        return undefined;
    }
    // LOAD_PACKAGE_IMPORTS(X, DIR)
    loadPackageImports(x, dir, extList) {
        // 1. Find the closest package scope SCOPE to DIR.
        const { data, scope } = this.readPackageScope(dir);
        // 2. If no scope was found, return.
        if (!data) return undefined;
        // 3. If the SCOPE/package.json "imports" is null or undefined, return.
        if (typeof data.imports !== "object" || data.imports === null || Array.isArray(data.imports)) return undefined;
        // 4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),
        //   ["node", "require"]) defined in the ESM resolver.
        // PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)
        // 1. Assert: specifier begins with "#".
        // 2. If specifier is exactly equal to "#" or starts with "#/", then
        if (x === "#" || x.startsWith("#/")) {
            // a. Throw an Invalid Module Specifier error.
            throw new VMError(`Invalid module specifier '${x}'`, "ERR_INVALID_MODULE_SPECIFIER");
        }
        // 3. Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).
        // Note: packageURL === parentURL === scope
        // 4. If packageURL is not null, then
        // Always true
        // a. Let pjson be the result of READ_PACKAGE_JSON(packageURL).
        // pjson === data
        // b. If pjson.imports is a non-null Object, then
        // Already tested
        // x. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( specifier, pjson.imports, packageURL, true, conditions).
        const match = this.packageImportsExportsResolve(x, data.imports, scope, true, [
            "node",
            "require"
        ], extList);
        // y. If resolved is not null or undefined, return resolved.
        if (!match) {
            // 5. Throw a Package Import Not Defined error.
            throw new VMError(`Package import not defined for '${x}'`, "ERR_PACKAGE_IMPORT_NOT_DEFINED");
        }
        // END PACKAGE_IMPORTS_RESOLVE
        // 5. RESOLVE_ESM_MATCH(MATCH).
        return this.resolveEsmMatch(match, x, extList);
    }
    // LOAD_PACKAGE_EXPORTS(X, DIR)
    loadPackageExports(x, dir, extList) {
        // 1. Try to interpret X as a combination of NAME and SUBPATH where the name
        //    may have a @scope/ prefix and the subpath begins with a slash (`/`).
        const res = x.match(EXPORTS_PATTERN);
        // 2. If X does not match this pattern or DIR/NAME/package.json is not a file,
        //    return.
        if (!res) return undefined;
        const scope = this.fs.join(dir, res[1]);
        const pack = this.readPackage(scope);
        if (!pack) return undefined;
        // 3. Parse DIR/NAME/package.json, and look for "exports" field.
        // 4. If "exports" is null or undefined, return.
        if (!pack.exports) return undefined;
        // 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), "." + SUBPATH,
        //    `package.json` "exports", ["node", "require"]) defined in the ESM resolver.
        const match = this.packageExportsResolve(scope, "." + (res[2] || ""), pack.exports, [
            "node",
            "require"
        ], extList);
        // 6. RESOLVE_ESM_MATCH(MATCH)
        return this.resolveEsmMatch(match, x, extList);
    }
    // LOAD_PACKAGE_SELF(X, DIR)
    loadPackageSelf(x, dir, extList) {
        // 1. Find the closest package scope SCOPE to DIR.
        const { data, scope } = this.readPackageScope(dir);
        // 2. If no scope was found, return.
        if (!data) return undefined;
        // 3. If the SCOPE/package.json "exports" is null or undefined, return.
        if (!data.exports) return undefined;
        // 4. If the SCOPE/package.json "name" is not the first segment of X, return.
        if (x !== data.name && !x.startsWith(data.name + "/")) return undefined;
        // 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),
        //    "." + X.slice("name".length), `package.json` "exports", ["node", "require"])
        //    defined in the ESM resolver.
        const match = this.packageExportsResolve(scope, "." + x.slice(data.name.length), data.exports, [
            "node",
            "require"
        ], extList);
        // 6. RESOLVE_ESM_MATCH(MATCH)
        return this.resolveEsmMatch(match, x, extList);
    }
    // RESOLVE_ESM_MATCH(MATCH)
    resolveEsmMatch(match, x, extList) {
        // 1. let { RESOLVED, EXACT } = MATCH
        const resolved = match;
        const exact = true;
        // 2. let RESOLVED_PATH = fileURLToPath(RESOLVED)
        const resolvedPath = resolved;
        let f;
        // 3. If EXACT is true,
        if (exact) {
            // a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension
            // format. STOP
            f = this.tryFile(resolvedPath);
        // 4. Otherwise, if EXACT is false,
        } else {
            // a. LOAD_AS_FILE(RESOLVED_PATH)
            // b. LOAD_AS_DIRECTORY(RESOLVED_PATH)
            f = this.loadAsFileOrDirectory(resolvedPath, extList);
        }
        if (f) return f;
        // 5. THROW "not found"
        throw new VMError(`Cannot find module '${x}'`, "ENOTFOUND");
    }
    // PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)
    packageExportsResolve(packageURL, subpath, rexports, conditions, extList) {
        // 1. If exports is an Object with both a key starting with "." and a key not starting with ".", throw an Invalid Package Configuration error.
        let hasDots = false;
        if (typeof rexports === "object" && !Array.isArray(rexports)) {
            const keys = Object.getOwnPropertyNames(rexports);
            if (keys.length > 0) {
                hasDots = keys[0][0] === ".";
                for(let i = 0; i < keys.length; i++){
                    if (hasDots !== (keys[i][0] === ".")) {
                        throw new VMError("Invalid package configuration", "ERR_INVALID_PACKAGE_CONFIGURATION");
                    }
                }
            }
        }
        // 2. If subpath is equal to ".", then
        if (subpath === ".") {
            // a. Let mainExport be undefined.
            let mainExport = undefined;
            // b. If exports is a String or Array, or an Object containing no keys starting with ".", then
            if (typeof rexports === "string" || Array.isArray(rexports) || !hasDots) {
                // x. Set mainExport to exports.
                mainExport = rexports;
            // c. Otherwise if exports is an Object containing a "." property, then
            } else if (hasDots) {
                // x. Set mainExport to exports["."].
                mainExport = rexports["."];
            }
            // d. If mainExport is not undefined, then
            if (mainExport) {
                // x. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, "", false, false, conditions).
                const resolved = this.packageTargetResolve(packageURL, mainExport, "", false, false, conditions, extList);
                // y. If resolved is not null or undefined, return resolved.
                if (resolved) return resolved;
            }
        // 3. Otherwise, if exports is an Object and all keys of exports start with ".", then
        } else if (hasDots) {
            // a. Let matchKey be the string "./" concatenated with subpath.
            // Note: Here subpath starts already with './'
            // b. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( matchKey, exports, packageURL, false, conditions).
            const resolved = this.packageImportsExportsResolve(subpath, rexports, packageURL, false, conditions, extList);
            // c. If resolved is not null or undefined, return resolved.
            if (resolved) return resolved;
        }
        // 4. Throw a Package Path Not Exported error.
        throw new VMError(`Package path '${subpath}' is not exported`, "ERR_PACKAGE_PATH_NOT_EXPORTED");
    }
    // PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports, conditions)
    packageImportsExportsResolve(matchKey, matchObj, packageURL, isImports, conditions, extList) {
        // 1. If matchKey is a key of matchObj and does not contain "*", then
        let target = matchObj[matchKey];
        if (target && matchKey.indexOf("*") === -1) {
            // a. Let target be the value of matchObj[matchKey].
            // b. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, "", false, isImports, conditions).
            return this.packageTargetResolve(packageURL, target, "", false, isImports, conditions, extList);
        }
        // 2. Let expansionKeys be the list of keys of matchObj containing only a single "*",
        //    sorted by the sorting function PATTERN_KEY_COMPARE which orders in descending order of specificity.
        const expansionKeys = Object.getOwnPropertyNames(matchObj);
        let bestKey = "";
        let bestSubpath;
        // 3. For each key expansionKey in expansionKeys, do
        for(let i = 0; i < expansionKeys.length; i++){
            const expansionKey = expansionKeys[i];
            if (matchKey.length < expansionKey.length) continue;
            // a. Let patternBase be the substring of expansionKey up to but excluding the first "*" character.
            const star = expansionKey.indexOf("*");
            if (star === -1) continue; // Note: expansionKeys was not filtered
            const patternBase = expansionKey.slice(0, star);
            // b. If matchKey starts with but is not equal to patternBase, then
            if (matchKey.startsWith(patternBase) && expansionKey.indexOf("*", star + 1) === -1) {
                // 1. Let patternTrailer be the substring of expansionKey from the index after the first "*" character.
                const patternTrailer = expansionKey.slice(star + 1);
                // 2. If patternTrailer has zero length, or if matchKey ends with patternTrailer and the length of matchKey is greater than or
                //    equal to the length of expansionKey, then
                if (matchKey.endsWith(patternTrailer) && this.patternKeyCompare(bestKey, expansionKey) === 1) {
                    // a. Let target be the value of matchObj[expansionKey].
                    target = matchObj[expansionKey];
                    // b. Let subpath be the substring of matchKey starting at the index of the length of patternBase up to the length of
                    //    matchKey minus the length of patternTrailer.
                    bestKey = expansionKey;
                    bestSubpath = matchKey.slice(patternBase.length, matchKey.length - patternTrailer.length);
                }
            }
        }
        if (bestSubpath) {
            // c. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, true, isImports, conditions).
            return this.packageTargetResolve(packageURL, target, bestSubpath, true, isImports, conditions, extList);
        }
        // 4. Return null.
        return null;
    }
    // PATTERN_KEY_COMPARE(keyA, keyB)
    patternKeyCompare(keyA, keyB) {
        // 1. Assert: keyA ends with "/" or contains only a single "*".
        // 2. Assert: keyB ends with "/" or contains only a single "*".
        // 3. Let baseLengthA be the index of "*" in keyA plus one, if keyA contains "*", or the length of keyA otherwise.
        const baseAStar = keyA.indexOf("*");
        const baseLengthA = baseAStar === -1 ? keyA.length : baseAStar + 1;
        // 4. Let baseLengthB be the index of "*" in keyB plus one, if keyB contains "*", or the length of keyB otherwise.
        const baseBStar = keyB.indexOf("*");
        const baseLengthB = baseBStar === -1 ? keyB.length : baseBStar + 1;
        // 5. If baseLengthA is greater than baseLengthB, return -1.
        if (baseLengthA > baseLengthB) return -1;
        // 6. If baseLengthB is greater than baseLengthA, return 1.
        if (baseLengthB > baseLengthA) return 1;
        // 7. If keyA does not contain "*", return 1.
        if (baseAStar === -1) return 1;
        // 8. If keyB does not contain "*", return -1.
        if (baseBStar === -1) return -1;
        // 9. If the length of keyA is greater than the length of keyB, return -1.
        if (keyA.length > keyB.length) return -1;
        // 10. If the length of keyB is greater than the length of keyA, return 1.
        if (keyB.length > keyA.length) return 1;
        // 11. Return 0.
        return 0;
    }
    // PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, pattern, internal, conditions)
    packageTargetResolve(packageURL, target, subpath, pattern, internal, conditions, extList) {
        // 1. If target is a String, then
        if (typeof target === "string") {
            // a. If pattern is false, subpath has non-zero length and target does not end with "/", throw an Invalid Module Specifier error.
            if (!pattern && subpath.length > 0 && !target.endsWith("/")) {
                throw new VMError(`Invalid package specifier '${subpath}'`, "ERR_INVALID_MODULE_SPECIFIER");
            }
            // b. If target does not start with "./", then
            if (!target.startsWith("./")) {
                // 1. If internal is true and target does not start with "../" or "/" and is not a valid URL, then
                if (internal && !target.startsWith("../") && !target.startsWith("/")) {
                    let isURL = false;
                    try {
                        // eslint-disable-next-line no-new
                        new URL(target);
                        isURL = true;
                    } catch (e) {}
                    if (!isURL) {
                        // a. If pattern is true, then
                        if (pattern) {
                            // 1. Return PACKAGE_RESOLVE(target with every instance of "*" replaced by subpath, packageURL + "/").
                            return this.packageResolve(target.replace(/\*/g, subpath), packageURL, conditions, extList);
                        }
                        // b. Return PACKAGE_RESOLVE(target + subpath, packageURL + "/").
                        return this.packageResolve(this.fs.join(target, subpath), packageURL, conditions, extList);
                    }
                }
                // Otherwise, throw an Invalid Package Target error.
                throw new VMError(`Invalid package target for '${subpath}'`, "ERR_INVALID_PACKAGE_TARGET");
            }
            target = decodeURI(target);
            // c. If target split on "/" or "\" contains any ".", ".." or "node_modules" segments after the first segment, case insensitive
            //    and including percent encoded variants, throw an Invalid Package Target error.
            if (target.split(/[/\\]/).slice(1).findIndex((x)=>x === "." || x === ".." || x.toLowerCase() === "node_modules") !== -1) {
                throw new VMError(`Invalid package target for '${subpath}'`, "ERR_INVALID_PACKAGE_TARGET");
            }
            // d. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.
            const resolvedTarget = this.fs.join(packageURL, target);
            // e. Assert: resolvedTarget is contained in packageURL.
            subpath = decodeURI(subpath);
            // f. If subpath split on "/" or "\" contains any ".", ".." or "node_modules" segments, case insensitive and including percent
            //    encoded variants, throw an Invalid Module Specifier error.
            if (subpath.split(/[/\\]/).findIndex((x)=>x === "." || x === ".." || x.toLowerCase() === "node_modules") !== -1) {
                throw new VMError(`Invalid package specifier '${subpath}'`, "ERR_INVALID_MODULE_SPECIFIER");
            }
            // g. If pattern is true, then
            if (pattern) {
                // 1. Return the URL resolution of resolvedTarget with every instance of "*" replaced with subpath.
                return resolvedTarget.replace(/\*/g, subpath);
            }
            // h. Otherwise,
            // 1. Return the URL resolution of the concatenation of subpath and resolvedTarget.
            return this.fs.join(resolvedTarget, subpath);
        // 3. Otherwise, if target is an Array, then
        } else if (Array.isArray(target)) {
            // a. If target.length is zero, return null.
            if (target.length === 0) return null;
            let lastException = undefined;
            // b. For each item targetValue in target, do
            for(let i = 0; i < target.length; i++){
                const targetValue = target[i];
                // 1. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions),
                //    continuing the loop on any Invalid Package Target error.
                let resolved;
                try {
                    resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);
                } catch (e) {
                    if (e.code !== "ERR_INVALID_PACKAGE_TARGET") throw e;
                    lastException = e;
                    continue;
                }
                // 2. If resolved is undefined, continue the loop.
                // 3. Return resolved.
                if (resolved !== undefined) return resolved;
                if (resolved === null) {
                    lastException = null;
                }
            }
            // c. Return or throw the last fallback resolution null return or error.
            if (lastException === undefined || lastException === null) return lastException;
            throw lastException;
        // 2. Otherwise, if target is a non-null Object, then
        } else if (typeof target === "object" && target !== null) {
            const keys = Object.getOwnPropertyNames(target);
            // a. If exports contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error.
            for(let i = 0; i < keys.length; i++){
                const p = keys[i];
                if (isArrayIndex(p)) throw new VMError(`Invalid package configuration for '${subpath}'`, "ERR_INVALID_PACKAGE_CONFIGURATION");
            }
            // b. For each property p of target, in object insertion order as,
            for(let i = 0; i < keys.length; i++){
                const p = keys[i];
                // 1. If p equals "default" or conditions contains an entry for p, then
                if (p === "default" || conditions.includes(p)) {
                    // a. Let targetValue be the value of the p property in target.
                    const targetValue = target[p];
                    // b. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions).
                    const resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);
                    // c. If resolved is equal to undefined, continue the loop.
                    // d. Return resolved.
                    if (resolved !== undefined) return resolved;
                }
            }
            // c. Return undefined.
            return undefined;
        // 4. Otherwise, if target is null, return null.
        } else if (target == null) {
            return null;
        }
        // Otherwise throw an Invalid Package Target error.
        throw new VMError(`Invalid package target for '${subpath}'`, "ERR_INVALID_PACKAGE_TARGET");
    }
    // PACKAGE_RESOLVE(packageSpecifier, parentURL)
    packageResolve(packageSpecifier, parentURL, conditions, extList) {
        // 1. Let packageName be undefined.
        let packageName = undefined;
        // 2. If packageSpecifier is an empty string, then
        if (packageSpecifier === "") {
            // a. Throw an Invalid Module Specifier error.
            throw new VMError(`Invalid package specifier '${packageSpecifier}'`, "ERR_INVALID_MODULE_SPECIFIER");
        }
        // 3. If packageSpecifier is a Node.js builtin module name, then
        if (this.builtins.has(packageSpecifier)) {
            // a. Return the string "node:" concatenated with packageSpecifier.
            return "node:" + packageSpecifier;
        }
        let idx = packageSpecifier.indexOf("/");
        // 5. Otherwise,
        if (packageSpecifier[0] === "@") {
            // a. If packageSpecifier does not contain a "/" separator, then
            if (idx === -1) {
                // x. Throw an Invalid Module Specifier error.
                throw new VMError(`Invalid package specifier '${packageSpecifier}'`, "ERR_INVALID_MODULE_SPECIFIER");
            }
            // b. Set packageName to the substring of packageSpecifier until the second "/" separator or the end of the string.
            idx = packageSpecifier.indexOf("/", idx + 1);
        }
        // else
        // 4. If packageSpecifier does not start with "@", then
        // a. Set packageName to the substring of packageSpecifier until the first "/" separator or the end of the string.
        packageName = idx === -1 ? packageSpecifier : packageSpecifier.slice(0, idx);
        // 6. If packageName starts with "." or contains "\" or "%", then
        if (idx !== 0 && (packageName[0] === "." || packageName.indexOf("\\") >= 0 || packageName.indexOf("%") >= 0)) {
            // a. Throw an Invalid Module Specifier error.
            throw new VMError(`Invalid package specifier '${packageSpecifier}'`, "ERR_INVALID_MODULE_SPECIFIER");
        }
        // 7. Let packageSubpath be "." concatenated with the substring of packageSpecifier from the position at the length of packageName.
        const packageSubpath = "." + packageSpecifier.slice(packageName.length);
        // 8. If packageSubpath ends in "/", then
        if (packageSubpath[packageSubpath.length - 1] === "/") {
            // a. Throw an Invalid Module Specifier error.
            throw new VMError(`Invalid package specifier '${packageSpecifier}'`, "ERR_INVALID_MODULE_SPECIFIER");
        }
        // 9. Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL).
        const selfUrl = this.packageSelfResolve(packageName, packageSubpath, parentURL);
        // 10. If selfUrl is not undefined, return selfUrl.
        if (selfUrl) return selfUrl;
        // 11. While parentURL is not the file system root,
        let packageURL;
        while(true){
            // a. Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
            packageURL = this.fs.resolve(this.fs.join(parentURL, "node_modules", packageSpecifier));
            // b. Set parentURL to the parent folder URL of parentURL.
            const parentParentURL = this.fs.dirname(parentURL);
            // c. If the folder at packageURL does not exist, then
            if (this.isPathAllowed(packageURL) && pathTestIsDirectory(this.fs, packageURL)) break;
            // 1. Continue the next loop iteration.
            if (parentParentURL === parentURL) {
                // 12. Throw a Module Not Found error.
                throw new VMError(`Cannot find module '${packageSpecifier}'`, "ENOTFOUND");
            }
            parentURL = parentParentURL;
        }
        // d. Let pjson be the result of READ_PACKAGE_JSON(packageURL).
        const pack = this.readPackage(packageURL);
        // e. If pjson is not null and pjson.exports is not null or undefined, then
        if (pack && pack.exports) {
            // 1. Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).
            return this.packageExportsResolve(packageURL, packageSubpath, pack.exports, conditions, extList);
        }
        // f. Otherwise, if packageSubpath is equal to ".", then
        if (packageSubpath === ".") {
            // 1. If pjson.main is a string, then
            // a. Return the URL resolution of main in packageURL.
            return this.loadAsPackage(packageSubpath, pack, extList);
        }
        // g. Otherwise,
        // 1. Return the URL resolution of packageSubpath in packageURL.
        return this.fs.join(packageURL, packageSubpath);
    }
}
exports.Resolver = Resolver;
exports.DefaultResolver = DefaultResolver;


/***/ }),

/***/ 94458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const { Script } = __webpack_require__(26144);
const { lookupCompiler, removeShebang } = __webpack_require__(75573);
const { transformer } = __webpack_require__(31615);
const objectDefineProperties = Object.defineProperties;
const MODULE_PREFIX = "(function (exports, require, module, __filename, __dirname) { ";
const STRICT_MODULE_PREFIX = MODULE_PREFIX + '"use strict"; ';
const MODULE_SUFFIX = "\n});";
/**
 * Class Script
 *
 * @public
 */ class VMScript {
    /**
	 * The script code with wrapping. If set will invalidate the cache.<br>
	 * Writable only for backwards compatibility.
	 *
	 * @public
	 * @readonly
	 * @member {string} code
	 * @memberOf VMScript#
	 */ /**
	 * The filename used for this script.
	 *
	 * @public
	 * @readonly
	 * @since v3.9.0
	 * @member {string} filename
	 * @memberOf VMScript#
	 */ /**
	 * The line offset use for stack traces.
	 *
	 * @public
	 * @readonly
	 * @since v3.9.0
	 * @member {number} lineOffset
	 * @memberOf VMScript#
	 */ /**
	 * The column offset use for stack traces.
	 *
	 * @public
	 * @readonly
	 * @since v3.9.0
	 * @member {number} columnOffset
	 * @memberOf VMScript#
	 */ /**
	 * The compiler to use to get the JavaScript code.
	 *
	 * @public
	 * @readonly
	 * @since v3.9.0
	 * @member {(string|compileCallback)} compiler
	 * @memberOf VMScript#
	 */ /**
	 * The prefix for the script.
	 *
	 * @private
	 * @member {string} _prefix
	 * @memberOf VMScript#
	 */ /**
	 * The suffix for the script.
	 *
	 * @private
	 * @member {string} _suffix
	 * @memberOf VMScript#
	 */ /**
	 * The compiled vm.Script for the VM or if not compiled <code>null</code>.
	 *
	 * @private
	 * @member {?vm.Script} _compiledVM
	 * @memberOf VMScript#
	 */ /**
	 * The compiled vm.Script for the NodeVM or if not compiled <code>null</code>.
	 *
	 * @private
	 * @member {?vm.Script} _compiledNodeVM
	 * @memberOf VMScript#
	 */ /**
	 * The compiled vm.Script for the NodeVM in strict mode or if not compiled <code>null</code>.
	 *
	 * @private
	 * @member {?vm.Script} _compiledNodeVMStrict
	 * @memberOf VMScript#
	 */ /**
	 * The resolved compiler to use to get the JavaScript code.
	 *
	 * @private
	 * @readonly
	 * @member {compileCallback} _compiler
	 * @memberOf VMScript#
	 */ /**
	 * The script to run without wrapping.
	 *
	 * @private
	 * @member {string} _code
	 * @memberOf VMScript#
	 */ /**
	 * Whether or not the script contains async functions.
	 *
	 * @private
	 * @member {boolean} _hasAsync
	 * @memberOf VMScript#
	 */ /**
	 * Create VMScript instance.
	 *
	 * @public
	 * @param {string} code - Code to run.
	 * @param {(string|Object)} [options] - Options map or filename.
	 * @param {string} [options.filename="vm.js"] - Filename that shows up in any stack traces produced from this script.
	 * @param {number} [options.lineOffset=0] - Passed to vm.Script options.
	 * @param {number} [options.columnOffset=0] - Passed to vm.Script options.
	 * @param {(string|compileCallback)} [options.compiler="javascript"] - The compiler to use.
	 * @throws {VMError} If the compiler is unknown or if coffee-script was requested but the module not found.
	 */ constructor(code, options){
        const sCode = `${code}`;
        let useFileName;
        let useOptions;
        if (arguments.length === 2) {
            if (typeof options === "object") {
                useOptions = options || {
                    __proto__: null
                };
                useFileName = useOptions.filename;
            } else {
                useOptions = {
                    __proto__: null
                };
                useFileName = options;
            }
        } else if (arguments.length > 2) {
            // We do it this way so that there are no more arguments in the function.
            // eslint-disable-next-line prefer-rest-params
            useOptions = arguments[2] || {
                __proto__: null
            };
            useFileName = options || useOptions.filename;
        } else {
            useOptions = {
                __proto__: null
            };
        }
        const { compiler = "javascript", lineOffset = 0, columnOffset = 0 } = useOptions;
        // Throw if the compiler is unknown.
        const resolvedCompiler = lookupCompiler(compiler);
        objectDefineProperties(this, {
            __proto__: null,
            code: {
                __proto__: null,
                // Put this here so that it is enumerable, and looks like a property.
                get () {
                    return this._prefix + this._code + this._suffix;
                },
                set (value) {
                    const strNewCode = String(value);
                    if (strNewCode === this._code && this._prefix === "" && this._suffix === "") return;
                    this._code = strNewCode;
                    this._prefix = "";
                    this._suffix = "";
                    this._compiledVM = null;
                    this._compiledNodeVM = null;
                    this._compiledCode = null;
                },
                enumerable: true
            },
            filename: {
                __proto__: null,
                value: useFileName || "vm.js",
                enumerable: true
            },
            lineOffset: {
                __proto__: null,
                value: lineOffset,
                enumerable: true
            },
            columnOffset: {
                __proto__: null,
                value: columnOffset,
                enumerable: true
            },
            compiler: {
                __proto__: null,
                value: compiler,
                enumerable: true
            },
            _code: {
                __proto__: null,
                value: sCode,
                writable: true
            },
            _prefix: {
                __proto__: null,
                value: "",
                writable: true
            },
            _suffix: {
                __proto__: null,
                value: "",
                writable: true
            },
            _compiledVM: {
                __proto__: null,
                value: null,
                writable: true
            },
            _compiledNodeVM: {
                __proto__: null,
                value: null,
                writable: true
            },
            _compiledNodeVMStrict: {
                __proto__: null,
                value: null,
                writable: true
            },
            _compiledCode: {
                __proto__: null,
                value: null,
                writable: true
            },
            _hasAsync: {
                __proto__: null,
                value: false,
                writable: true
            },
            _compiler: {
                __proto__: null,
                value: resolvedCompiler
            }
        });
    }
    /**
	 * Wraps the code.<br>
	 * This will replace the old wrapping.<br>
	 * Will invalidate the code cache.
	 *
	 * @public
	 * @deprecated Since v3.9.0. Wrap your code before passing it into the VMScript object.
	 * @param {string} prefix - String that will be appended before the script code.
	 * @param {script} suffix - String that will be appended behind the script code.
	 * @return {this} This for chaining.
	 * @throws {TypeError} If prefix or suffix is a Symbol.
	 */ wrap(prefix, suffix) {
        const strPrefix = `${prefix}`;
        const strSuffix = `${suffix}`;
        if (this._prefix === strPrefix && this._suffix === strSuffix) return this;
        this._prefix = strPrefix;
        this._suffix = strSuffix;
        this._compiledVM = null;
        this._compiledNodeVM = null;
        this._compiledNodeVMStrict = null;
        return this;
    }
    /**
	 * Compile this script. <br>
	 * This is useful to detect syntax errors in the script.
	 *
	 * @public
	 * @return {this} This for chaining.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */ compile() {
        this._compileVM();
        return this;
    }
    /**
	 * Get the compiled code.
	 *
	 * @private
	 * @return {string} The code.
	 */ getCompiledCode() {
        if (!this._compiledCode) {
            const comp = this._compiler(this._prefix + removeShebang(this._code) + this._suffix, this.filename);
            const res = transformer(null, comp, false, false, this.filename);
            this._compiledCode = res.code;
            this._hasAsync = res.hasAsync;
        }
        return this._compiledCode;
    }
    /**
	 * Compiles this script to a vm.Script.
	 *
	 * @private
	 * @param {string} prefix - JavaScript code that will be used as prefix.
	 * @param {string} suffix - JavaScript code that will be used as suffix.
	 * @return {vm.Script} The compiled vm.Script.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */ _compile(prefix, suffix) {
        return new Script(prefix + this.getCompiledCode() + suffix, {
            __proto__: null,
            filename: this.filename,
            displayErrors: false,
            lineOffset: this.lineOffset,
            columnOffset: this.columnOffset
        });
    }
    /**
	 * Will return the cached version of the script intended for VM or compile it.
	 *
	 * @private
	 * @return {vm.Script} The compiled script
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */ _compileVM() {
        let script = this._compiledVM;
        if (!script) {
            this._compiledVM = script = this._compile("", "");
        }
        return script;
    }
    /**
	 * Will return the cached version of the script intended for NodeVM or compile it.
	 *
	 * @private
	 * @return {vm.Script} The compiled script
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */ _compileNodeVM() {
        let script = this._compiledNodeVM;
        if (!script) {
            this._compiledNodeVM = script = this._compile(MODULE_PREFIX, MODULE_SUFFIX);
        }
        return script;
    }
    /**
	 * Will return the cached version of the script intended for NodeVM in strict mode or compile it.
	 *
	 * @private
	 * @return {vm.Script} The compiled script
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 */ _compileNodeVMStrict() {
        let script = this._compiledNodeVMStrict;
        if (!script) {
            this._compiledNodeVMStrict = script = this._compile(STRICT_MODULE_PREFIX, MODULE_SUFFIX);
        }
        return script;
    }
}
exports.MODULE_PREFIX = MODULE_PREFIX;
exports.STRICT_MODULE_PREFIX = STRICT_MODULE_PREFIX;
exports.MODULE_SUFFIX = MODULE_SUFFIX;
exports.VMScript = VMScript;


/***/ }),

/***/ 31615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const { Parser: AcornParser, isNewLine: acornIsNewLine, getLineInfo: acornGetLineInfo } = __webpack_require__(66742);
const { full: acornWalkFull } = __webpack_require__(89088);
const INTERNAL_STATE_NAME = "VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL";
function assertType(node, type) {
    if (!node) throw new Error(`None existent node expected '${type}'`);
    if (node.type !== type) throw new Error(`Invalid node type '${node.type}' expected '${type}'`);
    return node;
}
function makeNiceSyntaxError(message, code, filename, location, tokenizer) {
    const loc = acornGetLineInfo(code, location);
    let end = location;
    while(end < code.length && !acornIsNewLine(code.charCodeAt(end))){
        end++;
    }
    let markerEnd = tokenizer.start === location ? tokenizer.end : location + 1;
    if (!markerEnd || markerEnd > end) markerEnd = end;
    let markerLen = markerEnd - location;
    if (markerLen <= 0) markerLen = 1;
    if (message === "Unexpected token") {
        const type = tokenizer.type;
        if (type.label === "name" || type.label === "privateId") {
            message = "Unexpected identifier";
        } else if (type.label === "eof") {
            message = "Unexpected end of input";
        } else if (type.label === "num") {
            message = "Unexpected number";
        } else if (type.label === "string") {
            message = "Unexpected string";
        } else if (type.label === "regexp") {
            message = "Unexpected token '/'";
            markerLen = 1;
        } else {
            const token = tokenizer.value || type.label;
            message = `Unexpected token '${token}'`;
        }
    }
    const error = new SyntaxError(message);
    if (!filename) return error;
    const line = code.slice(location - loc.column, end);
    const marker = line.slice(0, loc.column).replace(/\S/g, " ") + "^".repeat(markerLen);
    error.stack = `${filename}:${loc.line}\n${line}\n${marker}\n\n${error.stack}`;
    return error;
}
function transformer(args, body, isAsync, isGenerator, filename) {
    let code;
    let argsOffset;
    if (args === null) {
        code = body;
        // Note: Keywords are not allows to contain u escapes
        if (!/\b(?:catch|import|async)\b/.test(code)) {
            return {
                __proto__: null,
                code,
                hasAsync: false
            };
        }
    } else {
        code = isAsync ? "(async function" : "(function";
        if (isGenerator) code += "*";
        code += " anonymous(";
        code += args;
        argsOffset = code.length;
        code += "\n) {\n";
        code += body;
        code += "\n})";
    }
    const parser = new AcornParser({
        __proto__: null,
        ecmaVersion: 2022,
        allowAwaitOutsideFunction: args === null && isAsync,
        allowReturnOutsideFunction: args === null
    }, code);
    let ast;
    try {
        ast = parser.parse();
    } catch (e) {
        // Try to generate a nicer error message.
        if (e instanceof SyntaxError && e.pos !== undefined) {
            let message = e.message;
            const match = message.match(/^(.*) \(\d+:\d+\)$/);
            if (match) message = match[1];
            e = makeNiceSyntaxError(message, code, filename, e.pos, parser);
        }
        throw e;
    }
    if (args !== null) {
        const pBody = assertType(ast, "Program").body;
        if (pBody.length !== 1) throw new SyntaxError("Single function literal required");
        const expr = pBody[0];
        if (expr.type !== "ExpressionStatement") throw new SyntaxError("Single function literal required");
        const func = expr.expression;
        if (func.type !== "FunctionExpression") throw new SyntaxError("Single function literal required");
        if (func.body.start !== argsOffset + 3) throw new SyntaxError("Unexpected end of arg string");
    }
    const insertions = [];
    let hasAsync = false;
    const TO_LEFT = -100;
    const TO_RIGHT = 100;
    let internStateValiable = undefined;
    let tmpname = "VM2_INTERNAL_TMPNAME";
    acornWalkFull(ast, (node, state, type)=>{
        if (type === "Function") {
            if (node.async) hasAsync = true;
        }
        const nodeType = node.type;
        if (nodeType === "CatchClause") {
            const param = node.param;
            if (param) {
                if (param.type === "Identifier") {
                    const name = assertType(param, "Identifier").name;
                    const cBody = assertType(node.body, "BlockStatement");
                    if (cBody.body.length > 0) {
                        insertions.push({
                            __proto__: null,
                            pos: cBody.body[0].start,
                            order: TO_LEFT,
                            coder: ()=>`${name}=${INTERNAL_STATE_NAME}.handleException(${name});`
                        });
                    }
                } else {
                    insertions.push({
                        __proto__: null,
                        pos: node.start,
                        order: TO_RIGHT,
                        coder: ()=>`catch(${tmpname}){${tmpname}=${INTERNAL_STATE_NAME}.handleException(${tmpname});try{throw ${tmpname};}`
                    });
                    insertions.push({
                        __proto__: null,
                        pos: node.body.end,
                        order: TO_LEFT,
                        coder: ()=>`}`
                    });
                }
            }
        } else if (nodeType === "WithStatement") {
            insertions.push({
                __proto__: null,
                pos: node.object.start,
                order: TO_LEFT,
                coder: ()=>INTERNAL_STATE_NAME + ".wrapWith("
            });
            insertions.push({
                __proto__: null,
                pos: node.object.end,
                order: TO_RIGHT,
                coder: ()=>")"
            });
        } else if (nodeType === "Identifier") {
            if (node.name === INTERNAL_STATE_NAME) {
                if (internStateValiable === undefined || internStateValiable.start > node.start) {
                    internStateValiable = node;
                }
            } else if (node.name.startsWith(tmpname)) {
                tmpname = node.name + "_UNIQUE";
            }
        } else if (nodeType === "ImportExpression") {
            insertions.push({
                __proto__: null,
                pos: node.start,
                order: TO_RIGHT,
                coder: ()=>INTERNAL_STATE_NAME + "."
            });
        }
    });
    if (internStateValiable) {
        throw makeNiceSyntaxError("Use of internal vm2 state variable", code, filename, internStateValiable.start, {
            __proto__: null,
            start: internStateValiable.start,
            end: internStateValiable.end
        });
    }
    if (insertions.length === 0) return {
        __proto__: null,
        code,
        hasAsync
    };
    insertions.sort((a, b)=>a.pos == b.pos ? a.order - b.order : a.pos - b.pos);
    let ncode = "";
    let curr = 0;
    for(let i = 0; i < insertions.length; i++){
        const change = insertions[i];
        ncode += code.substring(curr, change.pos) + change.coder();
        curr = change.pos;
    }
    ncode += code.substring(curr);
    return {
        __proto__: null,
        code: ncode,
        hasAsync
    };
}
exports.INTERNAL_STATE_NAME = INTERNAL_STATE_NAME;
exports.transformer = transformer;


/***/ }),

/***/ 930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * This callback will be called to transform a script to JavaScript.
 *
 * @callback compileCallback
 * @param {string} code - Script code to transform to JavaScript.
 * @param {string} filename - Filename of this script.
 * @return {string} JavaScript code that represents the script code.
 */ /**
 * This callback will be called to resolve a module if it couldn't be found.
 *
 * @callback resolveCallback
 * @param {string} moduleName - Name of the modulusedRequiree to resolve.
 * @param {string} dirname - Name of the current directory.
 * @return {(string|undefined)} The file or directory to use to load the requested module.
 */ const fs = __webpack_require__(57147);
const pa = __webpack_require__(71017);
const { Script, createContext } = __webpack_require__(26144);
const { EventEmitter } = __webpack_require__(82361);
const { INSPECT_MAX_BYTES } = __webpack_require__(14300);
const { createBridge, VMError } = __webpack_require__(82151);
const { transformer, INTERNAL_STATE_NAME } = __webpack_require__(31615);
const { lookupCompiler } = __webpack_require__(75573);
const { VMScript } = __webpack_require__(94458);
const { inspect } = __webpack_require__(73837);
const objectDefineProperties = Object.defineProperties;
/**
 * Host objects
 *
 * @private
 */ const HOST = Object.freeze({
    Buffer,
    Function,
    Object,
    transformAndCheck,
    INSPECT_MAX_BYTES,
    INTERNAL_STATE_NAME
});
/**
 * Compile a script.
 *
 * @private
 * @param {string} filename - Filename of the script.
 * @param {string} script - Script.
 * @return {vm.Script} The compiled script.
 */ function compileScript(filename, script) {
    return new Script(script, {
        __proto__: null,
        filename,
        displayErrors: false
    });
}
/**
 * Default run options for vm.Script.runInContext
 *
 * @private
 */ const DEFAULT_RUN_OPTIONS = Object.freeze({
    __proto__: null,
    displayErrors: false
});
function checkAsync(allow) {
    if (!allow) throw new VMError("Async not available");
}
function transformAndCheck(args, code, isAsync, isGenerator, allowAsync) {
    const ret = transformer(args, code, isAsync, isGenerator, undefined);
    checkAsync(allowAsync || !ret.hasAsync);
    return ret.code;
}
/**
 *
 * This callback will be called and has a specific time to finish.<br>
 * No parameters will be supplied.<br>
 * If parameters are required, use a closure.
 *
 * @private
 * @callback runWithTimeout
 * @return {*}
 *
 */ let cacheTimeoutContext = null;
let cacheTimeoutScript = null;
/**
 * Run a function with a specific timeout.
 *
 * @private
 * @param {runWithTimeout} fn - Function to run with the specific timeout.
 * @param {number} timeout - The amount of time to give the function to finish.
 * @return {*} The value returned by the function.
 * @throws {Error} If the function took to long.
 */ function doWithTimeout(fn, timeout) {
    if (!cacheTimeoutContext) {
        cacheTimeoutContext = createContext();
        cacheTimeoutScript = new Script("fn()", {
            __proto__: null,
            filename: "timeout_bridge.js",
            displayErrors: false
        });
    }
    cacheTimeoutContext.fn = fn;
    try {
        return cacheTimeoutScript.runInContext(cacheTimeoutContext, {
            __proto__: null,
            displayErrors: false,
            timeout
        });
    } finally{
        cacheTimeoutContext.fn = null;
    }
}
const bridgeScript = compileScript(`${__dirname}/bridge.js`, `(function(global) {"use strict"; const exports = {};${fs.readFileSync(`${__dirname}/bridge.js`, "utf8")}\nreturn exports;})`);
const setupSandboxScript = compileScript(`${__dirname}/setup-sandbox.js`, `(function(global, host, bridge, data, context) { ${fs.readFileSync(`${__dirname}/setup-sandbox.js`, "utf8")}\n})`);
const getGlobalScript = compileScript("get_global.js", "this");
let getGeneratorFunctionScript = null;
let getAsyncFunctionScript = null;
let getAsyncGeneratorFunctionScript = null;
try {
    getGeneratorFunctionScript = compileScript("get_generator_function.js", "(function*(){}).constructor");
} catch (ex) {}
try {
    getAsyncFunctionScript = compileScript("get_async_function.js", "(async function(){}).constructor");
} catch (ex) {}
try {
    getAsyncGeneratorFunctionScript = compileScript("get_async_generator_function.js", "(async function*(){}).constructor");
} catch (ex) {}
/**
 * Class VM.
 *
 * @public
 */ class VM extends EventEmitter {
    /**
	 * The timeout for {@link VM#run} calls.
	 *
	 * @public
	 * @since v3.9.0
	 * @member {number} timeout
	 * @memberOf VM#
	 */ /**
	 * Get the global sandbox object.
	 *
	 * @public
	 * @readonly
	 * @since v3.9.0
	 * @member {Object} sandbox
	 * @memberOf VM#
	 */ /**
	 * The compiler to use to get the JavaScript code.
	 *
	 * @public
	 * @readonly
	 * @since v3.9.0
	 * @member {(string|compileCallback)} compiler
	 * @memberOf VM#
	 */ /**
	 * The resolved compiler to use to get the JavaScript code.
	 *
	 * @private
	 * @readonly
	 * @member {compileCallback} _compiler
	 * @memberOf VM#
	 */ /**
	 * Create a new VM instance.
	 *
	 * @public
	 * @param {Object} [options] - VM options.
	 * @param {number} [options.timeout] - The amount of time until a call to {@link VM#run} will timeout.
	 * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.
	 * @param {(string|compileCallback)} [options.compiler="javascript"] - The compiler to use.
	 * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>
	 * Only available for node v10+.
	 * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>
	 * Only available for node v10+.
	 * @param {boolean} [options.allowAsync=true] - Allows for async functions.
	 * @throws {VMError} If the compiler is unknown.
	 */ constructor(options = {}){
        super();
        // Read all options
        const { timeout, sandbox, compiler = "javascript", allowAsync: optAllowAsync = true } = options;
        const allowEval = options.eval !== false;
        const allowWasm = options.wasm !== false;
        const allowAsync = optAllowAsync && !options.fixAsync;
        // Early error if sandbox is not an object.
        if (sandbox && "object" !== typeof sandbox) {
            throw new VMError("Sandbox must be object.");
        }
        // Early error if compiler can't be found.
        const resolvedCompiler = lookupCompiler(compiler);
        // Create a new context for this vm.
        const _context = createContext(undefined, {
            __proto__: null,
            codeGeneration: {
                __proto__: null,
                strings: allowEval,
                wasm: allowWasm
            }
        });
        const sandboxGlobal = getGlobalScript.runInContext(_context, DEFAULT_RUN_OPTIONS);
        // Initialize the sandbox bridge
        const { createBridge: sandboxCreateBridge } = bridgeScript.runInContext(_context, DEFAULT_RUN_OPTIONS)(sandboxGlobal);
        // Initialize the bridge
        const bridge = createBridge(sandboxCreateBridge, ()=>{});
        const data = {
            __proto__: null,
            allowAsync
        };
        if (getGeneratorFunctionScript) {
            data.GeneratorFunction = getGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);
        }
        if (getAsyncFunctionScript) {
            data.AsyncFunction = getAsyncFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);
        }
        if (getAsyncGeneratorFunctionScript) {
            data.AsyncGeneratorFunction = getAsyncGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);
        }
        // Create the bridge between the host and the sandbox.
        const internal = setupSandboxScript.runInContext(_context, DEFAULT_RUN_OPTIONS)(sandboxGlobal, HOST, bridge.other, data, _context);
        const runScript = (script)=>{
            // This closure is intentional to hide _context and bridge since the allow to access the sandbox directly which is unsafe.
            let ret;
            try {
                ret = script.runInContext(_context, DEFAULT_RUN_OPTIONS);
            } catch (e) {
                throw bridge.from(e);
            }
            return bridge.from(ret);
        };
        const makeReadonly = (value, mock)=>{
            try {
                internal.readonly(value, mock);
            } catch (e) {
                throw bridge.from(e);
            }
            return value;
        };
        const makeProtected = (value)=>{
            const sandboxBridge = bridge.other;
            try {
                sandboxBridge.fromWithFactory(sandboxBridge.protectedFactory, value);
            } catch (e) {
                throw bridge.from(e);
            }
            return value;
        };
        const addProtoMapping = (hostProto, sandboxProto)=>{
            const sandboxBridge = bridge.other;
            let otherProto;
            try {
                otherProto = sandboxBridge.from(sandboxProto);
                sandboxBridge.addProtoMapping(otherProto, hostProto);
            } catch (e) {
                throw bridge.from(e);
            }
            bridge.addProtoMapping(hostProto, otherProto);
        };
        const addProtoMappingFactory = (hostProto, sandboxProtoFactory)=>{
            const sandboxBridge = bridge.other;
            const factory = ()=>{
                const proto = sandboxProtoFactory(this);
                bridge.addProtoMapping(hostProto, proto);
                return proto;
            };
            try {
                const otherProtoFactory = sandboxBridge.from(factory);
                sandboxBridge.addProtoMappingFactory(otherProtoFactory, hostProto);
            } catch (e) {
                throw bridge.from(e);
            }
        };
        // Define the properties of this object.
        // Use Object.defineProperties here to be able to
        // hide and set properties read-only.
        objectDefineProperties(this, {
            __proto__: null,
            timeout: {
                __proto__: null,
                value: timeout,
                writable: true,
                enumerable: true
            },
            compiler: {
                __proto__: null,
                value: compiler,
                enumerable: true
            },
            sandbox: {
                __proto__: null,
                value: bridge.from(sandboxGlobal),
                enumerable: true
            },
            _runScript: {
                __proto__: null,
                value: runScript
            },
            _makeReadonly: {
                __proto__: null,
                value: makeReadonly
            },
            _makeProtected: {
                __proto__: null,
                value: makeProtected
            },
            _addProtoMapping: {
                __proto__: null,
                value: addProtoMapping
            },
            _addProtoMappingFactory: {
                __proto__: null,
                value: addProtoMappingFactory
            },
            _compiler: {
                __proto__: null,
                value: resolvedCompiler
            },
            _allowAsync: {
                __proto__: null,
                value: allowAsync
            }
        });
        this.readonly(inspect);
        // prepare global sandbox
        if (sandbox) {
            this.setGlobals(sandbox);
        }
    }
    /**
	 * Adds all the values to the globals.
	 *
	 * @public
	 * @since v3.9.0
	 * @param {Object} values - All values that will be added to the globals.
	 * @return {this} This for chaining.
	 * @throws {*} If the setter of a global throws an exception it is propagated. And the remaining globals will not be written.
	 */ setGlobals(values) {
        for(const name in values){
            if (Object.prototype.hasOwnProperty.call(values, name)) {
                this.sandbox[name] = values[name];
            }
        }
        return this;
    }
    /**
	 * Set a global value.
	 *
	 * @public
	 * @since v3.9.0
	 * @param {string} name - The name of the global.
	 * @param {*} value - The value of the global.
	 * @return {this} This for chaining.
	 * @throws {*} If the setter of the global throws an exception it is propagated.
	 */ setGlobal(name, value) {
        this.sandbox[name] = value;
        return this;
    }
    /**
	 * Get a global value.
	 *
	 * @public
	 * @since v3.9.0
	 * @param {string} name - The name of the global.
	 * @return {*} The value of the global.
	 * @throws {*} If the getter of the global throws an exception it is propagated.
	 */ getGlobal(name) {
        return this.sandbox[name];
    }
    /**
	 * Freezes the object inside VM making it read-only. Not available for primitive values.
	 *
	 * @public
	 * @param {*} value - Object to freeze.
	 * @param {string} [globalName] - Whether to add the object to global.
	 * @return {*} Object to freeze.
	 * @throws {*} If the setter of the global throws an exception it is propagated.
	 */ freeze(value, globalName) {
        this.readonly(value);
        if (globalName) this.sandbox[globalName] = value;
        return value;
    }
    /**
	 * Freezes the object inside VM making it read-only. Not available for primitive values.
	 *
	 * @public
	 * @param {*} value - Object to freeze.
	 * @param {*} [mock] - When the object does not have a property the mock is used before prototype lookup.
	 * @return {*} Object to freeze.
	 */ readonly(value, mock) {
        return this._makeReadonly(value, mock);
    }
    /**
	 * Protects the object inside VM making impossible to set functions as it's properties. Not available for primitive values.
	 *
	 * @public
	 * @param {*} value - Object to protect.
	 * @param {string} [globalName] - Whether to add the object to global.
	 * @return {*} Object to protect.
	 * @throws {*} If the setter of the global throws an exception it is propagated.
	 */ protect(value, globalName) {
        this._makeProtected(value);
        if (globalName) this.sandbox[globalName] = value;
        return value;
    }
    /**
	 * Run the code in VM.
	 *
	 * @public
	 * @param {(string|VMScript)} code - Code to run.
	 * @param {(string|Object)} [options] - Options map or filename.
	 * @param {string} [options.filename="vm.js"] - Filename that shows up in any stack traces produced from this script.<br>
	 * This is only used if code is a String.
	 * @return {*} Result of executed code.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {Error} An error is thrown when the script took to long and there is a timeout.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */ run(code, options) {
        let script;
        let filename;
        if (typeof options === "object") {
            filename = options.filename;
        } else {
            filename = options;
        }
        if (code instanceof VMScript) {
            script = code._compileVM();
            checkAsync(this._allowAsync || !code._hasAsync);
        } else {
            const useFileName = filename || "vm.js";
            let scriptCode = this._compiler(code, useFileName);
            const ret = transformer(null, scriptCode, false, false, useFileName);
            scriptCode = ret.code;
            checkAsync(this._allowAsync || !ret.hasAsync);
            // Compile the script here so that we don't need to create a instance of VMScript.
            script = new Script(scriptCode, {
                __proto__: null,
                filename: useFileName,
                displayErrors: false
            });
        }
        if (!this.timeout) {
            return this._runScript(script);
        }
        return doWithTimeout(()=>{
            return this._runScript(script);
        }, this.timeout);
    }
    /**
	 * Run the code in VM.
	 *
	 * @public
	 * @since v3.9.0
	 * @param {string} filename - Filename of file to load and execute in a NodeVM.
	 * @return {*} Result of executed code.
	 * @throws {Error} If filename is not a valid filename.
	 * @throws {SyntaxError} If there is a syntax error in the script.
	 * @throws {Error} An error is thrown when the script took to long and there is a timeout.
	 * @throws {*} If the script execution terminated with an exception it is propagated.
	 */ runFile(filename) {
        const resolvedFilename = pa.resolve(filename);
        if (!fs.existsSync(resolvedFilename)) {
            throw new VMError(`Script '${filename}' not found.`);
        }
        if (fs.statSync(resolvedFilename).isDirectory()) {
            throw new VMError("Script must be file, got directory.");
        }
        return this.run(fs.readFileSync(resolvedFilename, "utf8"), resolvedFilename);
    }
}
exports.VM = VM;


/***/ }),

/***/ 82682:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"coffee-script","description":"Unfancy JavaScript","keywords":["javascript","language","coffeescript","compiler"],"author":"Jeremy Ashkenas","version":"1.12.7","license":"MIT","engines":{"node":">=0.8.0"},"directories":{"lib":"./lib/coffee-script"},"main":"./lib/coffee-script/coffee-script","bin":{"coffee":"./bin/coffee","cake":"./bin/cake"},"files":["bin","lib","register.js","repl.js"],"scripts":{"test":"node ./bin/cake test","test-harmony":"node --harmony ./bin/cake test"},"homepage":"http://coffeescript.org","bugs":"https://github.com/jashkenas/coffeescript/issues","repository":{"type":"git","url":"git://github.com/jashkenas/coffeescript.git"},"devDependencies":{"docco":"~0.7.0","google-closure-compiler-js":"^20170626.0.0","highlight.js":"~9.12.0","jison":">=0.4.17","markdown-it":"^8.3.1","underscore":"~1.8.3"}}');

/***/ })

};
;